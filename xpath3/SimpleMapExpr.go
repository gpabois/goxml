package xpath3

import parser "github.com/gpabois/goxml/xpath3/anltr"

// A mapping expression S!E evaluates the expression E once for every item in the sequence obtained by evaluating S.
// The simple mapping operator "!" can be applied to any sequence, regardless of the types of its items,
// and it can deliver a mixed sequence of nodes, atomic values, and functions.
// Unlike the similar "/" operator, it does not sort nodes into document order or eliminate duplicates.
//
// Each operation E1!E2 is evaluated as follows: Expression E1 is evaluated to a sequence S.
// Each item in S then serves in turn to provide an inner focus (the item as the context item,
// its position in S as the context position, the length of S as the context size)
// for an evaluation of E2 in the dynamic context.
// The sequences resulting from all the evaluations of E2 are combined as follows:
// Every evaluation of E2 returns a (possibly empty) sequence of items. These sequences are concatenated and returned.
// The returned sequence preserves the orderings within and among the subsequences generated by the evaluations of E2
//
// Ex: child::div1 / child::para / string() ! concat("id-", .)
//
// Selects the para element children of the div1 element children of the context node;
// that is, the para element grandchildren of the context node that have div1 parents.
//
// It then outputs the strings obtained by prepending "id-" to each of the string values of these grandchildren.
type SimpleMapExpr struct {
	Sequence any
	Map      any
}

func (v *xPathAstVisitor) ExitSimpleMapExpr(c *parser.SimpleMapExprContext) {
	if c.SimpleMapExpr() != nil {
		sequence := v.stack.Pop().Expect()
		mp := v.stack.Pop().Expect()

		v.stack.Push(SimpleMapExpr{
			Sequence: sequence,
			Map:      mp,
		})
	}
}
