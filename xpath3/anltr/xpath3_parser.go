// Code generated from XPath3.g by ANTLR 4.13.0. DO NOT EDIT.

package parser // XPath3

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type XPath3Parser struct {
	*antlr.BaseParser
}

var XPath3ParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func xpath3ParserInit() {
	staticData := &XPath3ParserStaticData
	staticData.LiteralNames = []string{
		"", "','", "'$'", "'{'", "'}'", "'return'", "'for'", "'in'", "'let'",
		"':='", "'some'", "'any'", "'satisfies'", "'if'", "'('", "')'", "'then'",
		"'else'", "'or'", "'and'", "'||'", "'to'", "'+'", "'-'", "'*'", "'div'",
		"'idiv'", "'mod'", "'union'", "'|'", "'intersect'", "'except'", "'instance'",
		"'of'", "'treat'", "'as'", "'castable'", "'cast'", "'='", "'!='", "'<='",
		"'>='", "'<'", "'>'", "'eq'", "'ne'", "'lt'", "'le'", "'gt'", "'ge'",
		"'is'", "'<<'", "'>>'", "'!'", "'/'", "'//'", "'child'", "'::'", "'descendant'",
		"'attribute'", "'self'", "'descendant-or-self'", "'following-sibling'",
		"'following'", "'namespace'", "'@'", "'parent'", "'ancestor'", "'preceding-sibling'",
		"'preceding'", "'ancestor-or-self'", "'..'", "':'", "'['", "']'", "'.'",
		"'?'", "'#'", "'function'", "'empty-sequence'", "'item'", "'node'",
		"'document-node'", "'text'", "'comment'", "'namespace-node'", "'processing-instruction'",
		"'schema-attribute'", "'element'", "'schema-element'", "'\"'", "'''",
		"", "", "", "", "'\\\"'", "'\\''",
	}
	staticData.SymbolicNames = []string{
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "NumericLiteral", "IntegerLiteral", "DecimalLiteral",
		"DoubleLiteral", "ESCAPE_QUOTE", "ESCAPE_APOS", "URIQualifiedName",
		"Comment", "BracedURILiteral", "CommentContents", "QNAME", "PREFIXED_NAME",
		"UNPREFIXED_NAME", "PREFIX", "LOCAL_PART", "NC_NAME", "CHAR", "DIGITS",
	}
	staticData.RuleNames = []string{
		"xPath", "paramList", "param", "functionBody", "enclosedExpr", "expr",
		"exprSingle", "forExpr", "simpleForClause", "forBindingList", "simpleForBinding",
		"letExpr", "simpleLetClause", "letBindingList", "simpleLetBinding",
		"quantifiedExpr", "quantifiedBindingList", "simpleQuantifiedBinding",
		"ifExpr", "orExpr", "andExpr", "comparisonExpr", "stringConcatExpr",
		"rangeExpr", "additiveExpr", "multiplicativeExpr", "unionExpr", "intersectExceptExpr",
		"instanceofExpr", "treatExpr", "castableExpr", "castExpr", "unaryExpr",
		"valueExpr", "generalComp", "valueComp", "nodeComp", "simpleMapExpr",
		"pathExpr", "relativePathExpr", "stepExpr", "axisStep", "forwardStep",
		"forwardAxis", "abbrevForwardStep", "reverseStep", "reverseAxis", "abbrevReverseStep",
		"nodeTest", "nameTest", "wildCard", "postfixExpr", "argumentList", "predicateList",
		"predicate", "primaryExpr", "varRef", "varName", "literal", "parenthesizedExpr",
		"contextItemExpr", "functionCall", "argument", "argumentPlaceholder",
		"functionItemExpr", "namedFunctionRef", "inlineFunctionExpr", "singleType",
		"type_declaration", "sequenceType", "occurenceIndicator", "itemType",
		"atomicOrUnionType", "kindTest", "anyKindTest", "documentTest", "textTest",
		"commentTest", "namespaceNodeTest", "piTest", "attributeTest", "attribNameOrWildcard",
		"schemaAttributeTest", "attributeDeclaration", "elementTest", "elementNameOrWildcard",
		"schemaElementTest", "elementDeclaration", "attributeName", "elementName",
		"simpleTypeName", "typeName", "functionTest", "anyFunctionTest", "typedFunctionTest",
		"parenthesizedItemType", "eqName", "stringLiteral",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 109, 823, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7,
		4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7,
		10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15,
		2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2,
		21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26,
		7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7,
		31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36,
		2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 2,
		42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 47,
		7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7,
		52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 57,
		2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62, 2,
		63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2, 68,
		7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73, 7,
		73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7, 78,
		2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83, 2,
		84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2, 89,
		7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94, 7,
		94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 1, 0, 1, 0, 1, 0, 1, 1, 1,
		1, 1, 1, 5, 1, 203, 8, 1, 10, 1, 12, 1, 206, 9, 1, 1, 2, 1, 2, 1, 2, 3,
		2, 211, 8, 2, 1, 3, 1, 3, 1, 4, 1, 4, 1, 4, 1, 4, 1, 5, 1, 5, 1, 5, 5,
		5, 222, 8, 5, 10, 5, 12, 5, 225, 9, 5, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 3,
		6, 232, 8, 6, 1, 7, 1, 7, 1, 7, 1, 7, 1, 8, 1, 8, 1, 8, 1, 9, 1, 9, 1,
		9, 1, 9, 1, 9, 1, 9, 5, 9, 247, 8, 9, 10, 9, 12, 9, 250, 9, 9, 1, 10, 1,
		10, 1, 10, 1, 10, 1, 10, 1, 11, 1, 11, 1, 11, 1, 11, 1, 12, 1, 12, 1, 12,
		1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 5, 13, 270, 8, 13, 10, 13, 12,
		13, 273, 9, 13, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 15, 1, 15, 1, 15,
		1, 15, 1, 15, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 5, 16, 291, 8,
		16, 10, 16, 12, 16, 294, 9, 16, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 18,
		1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 19, 1, 19, 1,
		19, 1, 19, 1, 19, 1, 19, 5, 19, 316, 8, 19, 10, 19, 12, 19, 319, 9, 19,
		1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 5, 20, 327, 8, 20, 10, 20, 12,
		20, 330, 9, 20, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 3, 21, 337, 8, 21, 1,
		21, 1, 21, 3, 21, 341, 8, 21, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22,
		5, 22, 349, 8, 22, 10, 22, 12, 22, 352, 9, 22, 1, 23, 1, 23, 1, 23, 1,
		23, 1, 23, 1, 23, 5, 23, 360, 8, 23, 10, 23, 12, 23, 363, 9, 23, 1, 24,
		1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 5, 24, 371, 8, 24, 10, 24, 12, 24, 374,
		9, 24, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 5, 25, 382, 8, 25, 10,
		25, 12, 25, 385, 9, 25, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 5, 26,
		393, 8, 26, 10, 26, 12, 26, 396, 9, 26, 1, 27, 1, 27, 1, 27, 1, 27, 1,
		27, 1, 27, 5, 27, 404, 8, 27, 10, 27, 12, 27, 407, 9, 27, 1, 28, 1, 28,
		1, 28, 1, 28, 1, 28, 1, 28, 3, 28, 415, 8, 28, 1, 29, 1, 29, 1, 29, 1,
		29, 1, 29, 1, 29, 3, 29, 423, 8, 29, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30,
		1, 30, 3, 30, 431, 8, 30, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 3,
		31, 439, 8, 31, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 3, 32, 446, 8, 32, 1,
		33, 1, 33, 1, 34, 1, 34, 1, 35, 1, 35, 1, 36, 1, 36, 1, 37, 1, 37, 1, 37,
		5, 37, 459, 8, 37, 10, 37, 12, 37, 462, 9, 37, 1, 38, 1, 38, 3, 38, 466,
		8, 38, 1, 38, 1, 38, 1, 38, 3, 38, 471, 8, 38, 1, 39, 1, 39, 1, 39, 5,
		39, 476, 8, 39, 10, 39, 12, 39, 479, 9, 39, 1, 40, 1, 40, 3, 40, 483, 8,
		40, 1, 41, 1, 41, 3, 41, 487, 8, 41, 1, 41, 1, 41, 1, 42, 1, 42, 1, 42,
		1, 42, 3, 42, 495, 8, 42, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1,
		43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 3, 43,
		513, 8, 43, 1, 44, 3, 44, 516, 8, 44, 1, 44, 1, 44, 1, 45, 1, 45, 1, 45,
		1, 45, 3, 45, 524, 8, 45, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1,
		46, 1, 46, 1, 46, 1, 46, 3, 46, 536, 8, 46, 1, 47, 1, 47, 1, 48, 1, 48,
		3, 48, 542, 8, 48, 1, 49, 1, 49, 3, 49, 546, 8, 49, 1, 50, 1, 50, 1, 50,
		1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 3, 50, 557, 8, 50, 1, 51, 1,
		51, 1, 51, 5, 51, 562, 8, 51, 10, 51, 12, 51, 565, 9, 51, 1, 52, 1, 52,
		1, 52, 1, 52, 5, 52, 571, 8, 52, 10, 52, 12, 52, 574, 9, 52, 3, 52, 576,
		8, 52, 1, 52, 1, 52, 1, 53, 5, 53, 581, 8, 53, 10, 53, 12, 53, 584, 9,
		53, 1, 54, 1, 54, 1, 54, 1, 54, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55,
		3, 55, 596, 8, 55, 1, 56, 1, 56, 1, 56, 1, 57, 1, 57, 1, 58, 1, 58, 3,
		58, 605, 8, 58, 1, 59, 1, 59, 3, 59, 609, 8, 59, 1, 59, 1, 59, 1, 60, 1,
		60, 1, 61, 1, 61, 1, 61, 1, 62, 1, 62, 3, 62, 620, 8, 62, 1, 63, 1, 63,
		1, 64, 1, 64, 3, 64, 626, 8, 64, 1, 65, 1, 65, 1, 65, 1, 65, 1, 66, 1,
		66, 1, 66, 3, 66, 635, 8, 66, 1, 66, 1, 66, 1, 66, 3, 66, 640, 8, 66, 1,
		66, 1, 66, 1, 67, 1, 67, 3, 67, 646, 8, 67, 1, 68, 1, 68, 1, 68, 1, 69,
		1, 69, 1, 69, 1, 69, 1, 69, 3, 69, 656, 8, 69, 3, 69, 658, 8, 69, 1, 70,
		1, 70, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 3, 71, 669, 8,
		71, 1, 72, 1, 72, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73,
		1, 73, 1, 73, 3, 73, 683, 8, 73, 1, 74, 1, 74, 1, 74, 1, 74, 1, 75, 1,
		75, 1, 75, 1, 75, 3, 75, 693, 8, 75, 1, 75, 1, 75, 1, 76, 1, 76, 1, 76,
		1, 76, 1, 77, 1, 77, 1, 77, 1, 77, 1, 78, 1, 78, 1, 78, 1, 78, 1, 79, 1,
		79, 1, 79, 1, 79, 3, 79, 713, 8, 79, 1, 79, 1, 79, 1, 80, 1, 80, 1, 80,
		1, 80, 1, 80, 3, 80, 722, 8, 80, 3, 80, 724, 8, 80, 1, 80, 1, 80, 1, 81,
		1, 81, 3, 81, 730, 8, 81, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 83, 1,
		83, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 3, 84, 745, 8, 84, 3, 84,
		747, 8, 84, 3, 84, 749, 8, 84, 1, 84, 1, 84, 1, 85, 1, 85, 3, 85, 755,
		8, 85, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 87, 1, 87, 1, 88, 1, 88, 1,
		89, 1, 89, 1, 90, 1, 90, 1, 91, 1, 91, 1, 92, 1, 92, 3, 92, 774, 8, 92,
		1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 5,
		94, 786, 8, 94, 10, 94, 12, 94, 789, 9, 94, 3, 94, 791, 8, 94, 1, 94, 1,
		94, 1, 94, 1, 94, 1, 95, 1, 95, 1, 95, 1, 95, 1, 96, 1, 96, 1, 97, 1, 97,
		1, 97, 5, 97, 806, 8, 97, 10, 97, 12, 97, 809, 9, 97, 1, 97, 1, 97, 1,
		97, 1, 97, 5, 97, 815, 8, 97, 10, 97, 12, 97, 818, 9, 97, 1, 97, 3, 97,
		821, 8, 97, 1, 97, 2, 807, 816, 11, 18, 26, 32, 38, 40, 44, 46, 48, 50,
		52, 54, 98, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30,
		32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66,
		68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102,
		104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132,
		134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162,
		164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192,
		194, 0, 11, 1, 0, 10, 11, 1, 0, 22, 23, 1, 0, 24, 27, 1, 0, 28, 29, 1,
		0, 30, 31, 1, 0, 38, 43, 1, 0, 44, 49, 1, 0, 50, 52, 1, 0, 54, 55, 3, 0,
		22, 22, 24, 24, 76, 76, 2, 0, 98, 98, 102, 102, 828, 0, 196, 1, 0, 0, 0,
		2, 199, 1, 0, 0, 0, 4, 207, 1, 0, 0, 0, 6, 212, 1, 0, 0, 0, 8, 214, 1,
		0, 0, 0, 10, 218, 1, 0, 0, 0, 12, 231, 1, 0, 0, 0, 14, 233, 1, 0, 0, 0,
		16, 237, 1, 0, 0, 0, 18, 240, 1, 0, 0, 0, 20, 251, 1, 0, 0, 0, 22, 256,
		1, 0, 0, 0, 24, 260, 1, 0, 0, 0, 26, 263, 1, 0, 0, 0, 28, 274, 1, 0, 0,
		0, 30, 279, 1, 0, 0, 0, 32, 284, 1, 0, 0, 0, 34, 295, 1, 0, 0, 0, 36, 300,
		1, 0, 0, 0, 38, 309, 1, 0, 0, 0, 40, 320, 1, 0, 0, 0, 42, 340, 1, 0, 0,
		0, 44, 342, 1, 0, 0, 0, 46, 353, 1, 0, 0, 0, 48, 364, 1, 0, 0, 0, 50, 375,
		1, 0, 0, 0, 52, 386, 1, 0, 0, 0, 54, 397, 1, 0, 0, 0, 56, 414, 1, 0, 0,
		0, 58, 422, 1, 0, 0, 0, 60, 430, 1, 0, 0, 0, 62, 438, 1, 0, 0, 0, 64, 445,
		1, 0, 0, 0, 66, 447, 1, 0, 0, 0, 68, 449, 1, 0, 0, 0, 70, 451, 1, 0, 0,
		0, 72, 453, 1, 0, 0, 0, 74, 455, 1, 0, 0, 0, 76, 470, 1, 0, 0, 0, 78, 472,
		1, 0, 0, 0, 80, 482, 1, 0, 0, 0, 82, 486, 1, 0, 0, 0, 84, 494, 1, 0, 0,
		0, 86, 512, 1, 0, 0, 0, 88, 515, 1, 0, 0, 0, 90, 523, 1, 0, 0, 0, 92, 535,
		1, 0, 0, 0, 94, 537, 1, 0, 0, 0, 96, 541, 1, 0, 0, 0, 98, 545, 1, 0, 0,
		0, 100, 556, 1, 0, 0, 0, 102, 558, 1, 0, 0, 0, 104, 566, 1, 0, 0, 0, 106,
		582, 1, 0, 0, 0, 108, 585, 1, 0, 0, 0, 110, 595, 1, 0, 0, 0, 112, 597,
		1, 0, 0, 0, 114, 600, 1, 0, 0, 0, 116, 604, 1, 0, 0, 0, 118, 606, 1, 0,
		0, 0, 120, 612, 1, 0, 0, 0, 122, 614, 1, 0, 0, 0, 124, 619, 1, 0, 0, 0,
		126, 621, 1, 0, 0, 0, 128, 625, 1, 0, 0, 0, 130, 627, 1, 0, 0, 0, 132,
		631, 1, 0, 0, 0, 134, 643, 1, 0, 0, 0, 136, 647, 1, 0, 0, 0, 138, 657,
		1, 0, 0, 0, 140, 659, 1, 0, 0, 0, 142, 668, 1, 0, 0, 0, 144, 670, 1, 0,
		0, 0, 146, 682, 1, 0, 0, 0, 148, 684, 1, 0, 0, 0, 150, 688, 1, 0, 0, 0,
		152, 696, 1, 0, 0, 0, 154, 700, 1, 0, 0, 0, 156, 704, 1, 0, 0, 0, 158,
		708, 1, 0, 0, 0, 160, 716, 1, 0, 0, 0, 162, 729, 1, 0, 0, 0, 164, 731,
		1, 0, 0, 0, 166, 736, 1, 0, 0, 0, 168, 738, 1, 0, 0, 0, 170, 754, 1, 0,
		0, 0, 172, 756, 1, 0, 0, 0, 174, 761, 1, 0, 0, 0, 176, 763, 1, 0, 0, 0,
		178, 765, 1, 0, 0, 0, 180, 767, 1, 0, 0, 0, 182, 769, 1, 0, 0, 0, 184,
		773, 1, 0, 0, 0, 186, 775, 1, 0, 0, 0, 188, 780, 1, 0, 0, 0, 190, 796,
		1, 0, 0, 0, 192, 800, 1, 0, 0, 0, 194, 820, 1, 0, 0, 0, 196, 197, 3, 10,
		5, 0, 197, 198, 5, 0, 0, 1, 198, 1, 1, 0, 0, 0, 199, 204, 3, 4, 2, 0, 200,
		201, 5, 1, 0, 0, 201, 203, 3, 4, 2, 0, 202, 200, 1, 0, 0, 0, 203, 206,
		1, 0, 0, 0, 204, 202, 1, 0, 0, 0, 204, 205, 1, 0, 0, 0, 205, 3, 1, 0, 0,
		0, 206, 204, 1, 0, 0, 0, 207, 208, 5, 2, 0, 0, 208, 210, 3, 192, 96, 0,
		209, 211, 3, 136, 68, 0, 210, 209, 1, 0, 0, 0, 210, 211, 1, 0, 0, 0, 211,
		5, 1, 0, 0, 0, 212, 213, 3, 8, 4, 0, 213, 7, 1, 0, 0, 0, 214, 215, 5, 3,
		0, 0, 215, 216, 3, 10, 5, 0, 216, 217, 5, 4, 0, 0, 217, 9, 1, 0, 0, 0,
		218, 223, 3, 12, 6, 0, 219, 220, 5, 1, 0, 0, 220, 222, 3, 12, 6, 0, 221,
		219, 1, 0, 0, 0, 222, 225, 1, 0, 0, 0, 223, 221, 1, 0, 0, 0, 223, 224,
		1, 0, 0, 0, 224, 11, 1, 0, 0, 0, 225, 223, 1, 0, 0, 0, 226, 232, 3, 14,
		7, 0, 227, 232, 3, 22, 11, 0, 228, 232, 3, 30, 15, 0, 229, 232, 3, 36,
		18, 0, 230, 232, 3, 38, 19, 0, 231, 226, 1, 0, 0, 0, 231, 227, 1, 0, 0,
		0, 231, 228, 1, 0, 0, 0, 231, 229, 1, 0, 0, 0, 231, 230, 1, 0, 0, 0, 232,
		13, 1, 0, 0, 0, 233, 234, 3, 16, 8, 0, 234, 235, 5, 5, 0, 0, 235, 236,
		3, 12, 6, 0, 236, 15, 1, 0, 0, 0, 237, 238, 5, 6, 0, 0, 238, 239, 3, 18,
		9, 0, 239, 17, 1, 0, 0, 0, 240, 241, 6, 9, -1, 0, 241, 242, 3, 20, 10,
		0, 242, 248, 1, 0, 0, 0, 243, 244, 10, 1, 0, 0, 244, 245, 5, 1, 0, 0, 245,
		247, 3, 20, 10, 0, 246, 243, 1, 0, 0, 0, 247, 250, 1, 0, 0, 0, 248, 246,
		1, 0, 0, 0, 248, 249, 1, 0, 0, 0, 249, 19, 1, 0, 0, 0, 250, 248, 1, 0,
		0, 0, 251, 252, 5, 2, 0, 0, 252, 253, 3, 114, 57, 0, 253, 254, 5, 7, 0,
		0, 254, 255, 3, 12, 6, 0, 255, 21, 1, 0, 0, 0, 256, 257, 3, 24, 12, 0,
		257, 258, 5, 5, 0, 0, 258, 259, 3, 12, 6, 0, 259, 23, 1, 0, 0, 0, 260,
		261, 5, 8, 0, 0, 261, 262, 3, 26, 13, 0, 262, 25, 1, 0, 0, 0, 263, 264,
		6, 13, -1, 0, 264, 265, 3, 24, 12, 0, 265, 271, 1, 0, 0, 0, 266, 267, 10,
		1, 0, 0, 267, 268, 5, 1, 0, 0, 268, 270, 3, 28, 14, 0, 269, 266, 1, 0,
		0, 0, 270, 273, 1, 0, 0, 0, 271, 269, 1, 0, 0, 0, 271, 272, 1, 0, 0, 0,
		272, 27, 1, 0, 0, 0, 273, 271, 1, 0, 0, 0, 274, 275, 5, 2, 0, 0, 275, 276,
		3, 114, 57, 0, 276, 277, 5, 9, 0, 0, 277, 278, 3, 12, 6, 0, 278, 29, 1,
		0, 0, 0, 279, 280, 7, 0, 0, 0, 280, 281, 3, 32, 16, 0, 281, 282, 5, 12,
		0, 0, 282, 283, 3, 12, 6, 0, 283, 31, 1, 0, 0, 0, 284, 285, 6, 16, -1,
		0, 285, 286, 3, 34, 17, 0, 286, 292, 1, 0, 0, 0, 287, 288, 10, 1, 0, 0,
		288, 289, 5, 1, 0, 0, 289, 291, 3, 34, 17, 0, 290, 287, 1, 0, 0, 0, 291,
		294, 1, 0, 0, 0, 292, 290, 1, 0, 0, 0, 292, 293, 1, 0, 0, 0, 293, 33, 1,
		0, 0, 0, 294, 292, 1, 0, 0, 0, 295, 296, 5, 2, 0, 0, 296, 297, 3, 114,
		57, 0, 297, 298, 5, 7, 0, 0, 298, 299, 3, 12, 6, 0, 299, 35, 1, 0, 0, 0,
		300, 301, 5, 13, 0, 0, 301, 302, 5, 14, 0, 0, 302, 303, 3, 10, 5, 0, 303,
		304, 5, 15, 0, 0, 304, 305, 5, 16, 0, 0, 305, 306, 3, 12, 6, 0, 306, 307,
		5, 17, 0, 0, 307, 308, 3, 12, 6, 0, 308, 37, 1, 0, 0, 0, 309, 310, 6, 19,
		-1, 0, 310, 311, 3, 40, 20, 0, 311, 317, 1, 0, 0, 0, 312, 313, 10, 1, 0,
		0, 313, 314, 5, 18, 0, 0, 314, 316, 3, 40, 20, 0, 315, 312, 1, 0, 0, 0,
		316, 319, 1, 0, 0, 0, 317, 315, 1, 0, 0, 0, 317, 318, 1, 0, 0, 0, 318,
		39, 1, 0, 0, 0, 319, 317, 1, 0, 0, 0, 320, 321, 6, 20, -1, 0, 321, 322,
		3, 42, 21, 0, 322, 328, 1, 0, 0, 0, 323, 324, 10, 1, 0, 0, 324, 325, 5,
		19, 0, 0, 325, 327, 3, 42, 21, 0, 326, 323, 1, 0, 0, 0, 327, 330, 1, 0,
		0, 0, 328, 326, 1, 0, 0, 0, 328, 329, 1, 0, 0, 0, 329, 41, 1, 0, 0, 0,
		330, 328, 1, 0, 0, 0, 331, 341, 3, 44, 22, 0, 332, 336, 3, 44, 22, 0, 333,
		337, 3, 70, 35, 0, 334, 337, 3, 68, 34, 0, 335, 337, 3, 72, 36, 0, 336,
		333, 1, 0, 0, 0, 336, 334, 1, 0, 0, 0, 336, 335, 1, 0, 0, 0, 337, 338,
		1, 0, 0, 0, 338, 339, 3, 44, 22, 0, 339, 341, 1, 0, 0, 0, 340, 331, 1,
		0, 0, 0, 340, 332, 1, 0, 0, 0, 341, 43, 1, 0, 0, 0, 342, 343, 6, 22, -1,
		0, 343, 344, 3, 46, 23, 0, 344, 350, 1, 0, 0, 0, 345, 346, 10, 1, 0, 0,
		346, 347, 5, 20, 0, 0, 347, 349, 3, 46, 23, 0, 348, 345, 1, 0, 0, 0, 349,
		352, 1, 0, 0, 0, 350, 348, 1, 0, 0, 0, 350, 351, 1, 0, 0, 0, 351, 45, 1,
		0, 0, 0, 352, 350, 1, 0, 0, 0, 353, 354, 6, 23, -1, 0, 354, 355, 3, 48,
		24, 0, 355, 361, 1, 0, 0, 0, 356, 357, 10, 1, 0, 0, 357, 358, 5, 21, 0,
		0, 358, 360, 3, 48, 24, 0, 359, 356, 1, 0, 0, 0, 360, 363, 1, 0, 0, 0,
		361, 359, 1, 0, 0, 0, 361, 362, 1, 0, 0, 0, 362, 47, 1, 0, 0, 0, 363, 361,
		1, 0, 0, 0, 364, 365, 6, 24, -1, 0, 365, 366, 3, 50, 25, 0, 366, 372, 1,
		0, 0, 0, 367, 368, 10, 1, 0, 0, 368, 369, 7, 1, 0, 0, 369, 371, 3, 50,
		25, 0, 370, 367, 1, 0, 0, 0, 371, 374, 1, 0, 0, 0, 372, 370, 1, 0, 0, 0,
		372, 373, 1, 0, 0, 0, 373, 49, 1, 0, 0, 0, 374, 372, 1, 0, 0, 0, 375, 376,
		6, 25, -1, 0, 376, 377, 3, 52, 26, 0, 377, 383, 1, 0, 0, 0, 378, 379, 10,
		1, 0, 0, 379, 380, 7, 2, 0, 0, 380, 382, 3, 52, 26, 0, 381, 378, 1, 0,
		0, 0, 382, 385, 1, 0, 0, 0, 383, 381, 1, 0, 0, 0, 383, 384, 1, 0, 0, 0,
		384, 51, 1, 0, 0, 0, 385, 383, 1, 0, 0, 0, 386, 387, 6, 26, -1, 0, 387,
		388, 3, 54, 27, 0, 388, 394, 1, 0, 0, 0, 389, 390, 10, 1, 0, 0, 390, 391,
		7, 3, 0, 0, 391, 393, 3, 54, 27, 0, 392, 389, 1, 0, 0, 0, 393, 396, 1,
		0, 0, 0, 394, 392, 1, 0, 0, 0, 394, 395, 1, 0, 0, 0, 395, 53, 1, 0, 0,
		0, 396, 394, 1, 0, 0, 0, 397, 398, 6, 27, -1, 0, 398, 399, 3, 56, 28, 0,
		399, 405, 1, 0, 0, 0, 400, 401, 10, 1, 0, 0, 401, 402, 7, 4, 0, 0, 402,
		404, 3, 56, 28, 0, 403, 400, 1, 0, 0, 0, 404, 407, 1, 0, 0, 0, 405, 403,
		1, 0, 0, 0, 405, 406, 1, 0, 0, 0, 406, 55, 1, 0, 0, 0, 407, 405, 1, 0,
		0, 0, 408, 415, 3, 58, 29, 0, 409, 410, 3, 58, 29, 0, 410, 411, 5, 32,
		0, 0, 411, 412, 5, 33, 0, 0, 412, 413, 3, 138, 69, 0, 413, 415, 1, 0, 0,
		0, 414, 408, 1, 0, 0, 0, 414, 409, 1, 0, 0, 0, 415, 57, 1, 0, 0, 0, 416,
		423, 3, 60, 30, 0, 417, 418, 3, 60, 30, 0, 418, 419, 5, 34, 0, 0, 419,
		420, 5, 35, 0, 0, 420, 421, 3, 138, 69, 0, 421, 423, 1, 0, 0, 0, 422, 416,
		1, 0, 0, 0, 422, 417, 1, 0, 0, 0, 423, 59, 1, 0, 0, 0, 424, 431, 3, 62,
		31, 0, 425, 426, 3, 62, 31, 0, 426, 427, 5, 36, 0, 0, 427, 428, 5, 35,
		0, 0, 428, 429, 3, 134, 67, 0, 429, 431, 1, 0, 0, 0, 430, 424, 1, 0, 0,
		0, 430, 425, 1, 0, 0, 0, 431, 61, 1, 0, 0, 0, 432, 439, 3, 64, 32, 0, 433,
		434, 3, 64, 32, 0, 434, 435, 5, 37, 0, 0, 435, 436, 5, 35, 0, 0, 436, 437,
		3, 134, 67, 0, 437, 439, 1, 0, 0, 0, 438, 432, 1, 0, 0, 0, 438, 433, 1,
		0, 0, 0, 439, 63, 1, 0, 0, 0, 440, 446, 3, 66, 33, 0, 441, 442, 5, 23,
		0, 0, 442, 446, 3, 64, 32, 0, 443, 444, 5, 22, 0, 0, 444, 446, 3, 64, 32,
		0, 445, 440, 1, 0, 0, 0, 445, 441, 1, 0, 0, 0, 445, 443, 1, 0, 0, 0, 446,
		65, 1, 0, 0, 0, 447, 448, 3, 74, 37, 0, 448, 67, 1, 0, 0, 0, 449, 450,
		7, 5, 0, 0, 450, 69, 1, 0, 0, 0, 451, 452, 7, 6, 0, 0, 452, 71, 1, 0, 0,
		0, 453, 454, 7, 7, 0, 0, 454, 73, 1, 0, 0, 0, 455, 460, 3, 76, 38, 0, 456,
		457, 5, 53, 0, 0, 457, 459, 3, 76, 38, 0, 458, 456, 1, 0, 0, 0, 459, 462,
		1, 0, 0, 0, 460, 458, 1, 0, 0, 0, 460, 461, 1, 0, 0, 0, 461, 75, 1, 0,
		0, 0, 462, 460, 1, 0, 0, 0, 463, 465, 5, 54, 0, 0, 464, 466, 3, 78, 39,
		0, 465, 464, 1, 0, 0, 0, 465, 466, 1, 0, 0, 0, 466, 471, 1, 0, 0, 0, 467,
		468, 5, 55, 0, 0, 468, 471, 3, 78, 39, 0, 469, 471, 3, 78, 39, 0, 470,
		463, 1, 0, 0, 0, 470, 467, 1, 0, 0, 0, 470, 469, 1, 0, 0, 0, 471, 77, 1,
		0, 0, 0, 472, 477, 3, 80, 40, 0, 473, 474, 7, 8, 0, 0, 474, 476, 3, 80,
		40, 0, 475, 473, 1, 0, 0, 0, 476, 479, 1, 0, 0, 0, 477, 475, 1, 0, 0, 0,
		477, 478, 1, 0, 0, 0, 478, 79, 1, 0, 0, 0, 479, 477, 1, 0, 0, 0, 480, 483,
		3, 102, 51, 0, 481, 483, 3, 82, 41, 0, 482, 480, 1, 0, 0, 0, 482, 481,
		1, 0, 0, 0, 483, 81, 1, 0, 0, 0, 484, 487, 3, 90, 45, 0, 485, 487, 3, 84,
		42, 0, 486, 484, 1, 0, 0, 0, 486, 485, 1, 0, 0, 0, 487, 488, 1, 0, 0, 0,
		488, 489, 3, 106, 53, 0, 489, 83, 1, 0, 0, 0, 490, 491, 3, 86, 43, 0, 491,
		492, 3, 96, 48, 0, 492, 495, 1, 0, 0, 0, 493, 495, 3, 88, 44, 0, 494, 490,
		1, 0, 0, 0, 494, 493, 1, 0, 0, 0, 495, 85, 1, 0, 0, 0, 496, 497, 5, 56,
		0, 0, 497, 513, 5, 57, 0, 0, 498, 499, 5, 58, 0, 0, 499, 513, 5, 57, 0,
		0, 500, 501, 5, 59, 0, 0, 501, 513, 5, 57, 0, 0, 502, 503, 5, 60, 0, 0,
		503, 513, 5, 57, 0, 0, 504, 505, 5, 61, 0, 0, 505, 513, 5, 57, 0, 0, 506,
		507, 5, 62, 0, 0, 507, 513, 5, 57, 0, 0, 508, 509, 5, 63, 0, 0, 509, 513,
		5, 57, 0, 0, 510, 511, 5, 64, 0, 0, 511, 513, 5, 57, 0, 0, 512, 496, 1,
		0, 0, 0, 512, 498, 1, 0, 0, 0, 512, 500, 1, 0, 0, 0, 512, 502, 1, 0, 0,
		0, 512, 504, 1, 0, 0, 0, 512, 506, 1, 0, 0, 0, 512, 508, 1, 0, 0, 0, 512,
		510, 1, 0, 0, 0, 513, 87, 1, 0, 0, 0, 514, 516, 5, 65, 0, 0, 515, 514,
		1, 0, 0, 0, 515, 516, 1, 0, 0, 0, 516, 517, 1, 0, 0, 0, 517, 518, 3, 96,
		48, 0, 518, 89, 1, 0, 0, 0, 519, 520, 3, 92, 46, 0, 520, 521, 3, 96, 48,
		0, 521, 524, 1, 0, 0, 0, 522, 524, 3, 94, 47, 0, 523, 519, 1, 0, 0, 0,
		523, 522, 1, 0, 0, 0, 524, 91, 1, 0, 0, 0, 525, 526, 5, 66, 0, 0, 526,
		536, 5, 57, 0, 0, 527, 528, 5, 67, 0, 0, 528, 536, 5, 57, 0, 0, 529, 530,
		5, 68, 0, 0, 530, 536, 5, 57, 0, 0, 531, 532, 5, 69, 0, 0, 532, 536, 5,
		57, 0, 0, 533, 534, 5, 70, 0, 0, 534, 536, 5, 57, 0, 0, 535, 525, 1, 0,
		0, 0, 535, 527, 1, 0, 0, 0, 535, 529, 1, 0, 0, 0, 535, 531, 1, 0, 0, 0,
		535, 533, 1, 0, 0, 0, 536, 93, 1, 0, 0, 0, 537, 538, 5, 71, 0, 0, 538,
		95, 1, 0, 0, 0, 539, 542, 3, 146, 73, 0, 540, 542, 3, 98, 49, 0, 541, 539,
		1, 0, 0, 0, 541, 540, 1, 0, 0, 0, 542, 97, 1, 0, 0, 0, 543, 546, 3, 192,
		96, 0, 544, 546, 3, 100, 50, 0, 545, 543, 1, 0, 0, 0, 545, 544, 1, 0, 0,
		0, 546, 99, 1, 0, 0, 0, 547, 557, 5, 24, 0, 0, 548, 549, 5, 107, 0, 0,
		549, 550, 5, 72, 0, 0, 550, 557, 5, 24, 0, 0, 551, 552, 5, 24, 0, 0, 552,
		553, 5, 72, 0, 0, 553, 557, 5, 107, 0, 0, 554, 555, 5, 100, 0, 0, 555,
		557, 5, 24, 0, 0, 556, 547, 1, 0, 0, 0, 556, 548, 1, 0, 0, 0, 556, 551,
		1, 0, 0, 0, 556, 554, 1, 0, 0, 0, 557, 101, 1, 0, 0, 0, 558, 563, 3, 110,
		55, 0, 559, 562, 3, 108, 54, 0, 560, 562, 3, 104, 52, 0, 561, 559, 1, 0,
		0, 0, 561, 560, 1, 0, 0, 0, 562, 565, 1, 0, 0, 0, 563, 561, 1, 0, 0, 0,
		563, 564, 1, 0, 0, 0, 564, 103, 1, 0, 0, 0, 565, 563, 1, 0, 0, 0, 566,
		575, 5, 14, 0, 0, 567, 572, 3, 124, 62, 0, 568, 569, 5, 1, 0, 0, 569, 571,
		3, 124, 62, 0, 570, 568, 1, 0, 0, 0, 571, 574, 1, 0, 0, 0, 572, 570, 1,
		0, 0, 0, 572, 573, 1, 0, 0, 0, 573, 576, 1, 0, 0, 0, 574, 572, 1, 0, 0,
		0, 575, 567, 1, 0, 0, 0, 575, 576, 1, 0, 0, 0, 576, 577, 1, 0, 0, 0, 577,
		578, 5, 15, 0, 0, 578, 105, 1, 0, 0, 0, 579, 581, 3, 108, 54, 0, 580, 579,
		1, 0, 0, 0, 581, 584, 1, 0, 0, 0, 582, 580, 1, 0, 0, 0, 582, 583, 1, 0,
		0, 0, 583, 107, 1, 0, 0, 0, 584, 582, 1, 0, 0, 0, 585, 586, 5, 73, 0, 0,
		586, 587, 3, 10, 5, 0, 587, 588, 5, 74, 0, 0, 588, 109, 1, 0, 0, 0, 589,
		596, 3, 116, 58, 0, 590, 596, 3, 112, 56, 0, 591, 596, 3, 118, 59, 0, 592,
		596, 3, 120, 60, 0, 593, 596, 3, 122, 61, 0, 594, 596, 3, 128, 64, 0, 595,
		589, 1, 0, 0, 0, 595, 590, 1, 0, 0, 0, 595, 591, 1, 0, 0, 0, 595, 592,
		1, 0, 0, 0, 595, 593, 1, 0, 0, 0, 595, 594, 1, 0, 0, 0, 596, 111, 1, 0,
		0, 0, 597, 598, 5, 2, 0, 0, 598, 599, 3, 114, 57, 0, 599, 113, 1, 0, 0,
		0, 600, 601, 3, 192, 96, 0, 601, 115, 1, 0, 0, 0, 602, 605, 5, 92, 0, 0,
		603, 605, 3, 194, 97, 0, 604, 602, 1, 0, 0, 0, 604, 603, 1, 0, 0, 0, 605,
		117, 1, 0, 0, 0, 606, 608, 5, 14, 0, 0, 607, 609, 3, 10, 5, 0, 608, 607,
		1, 0, 0, 0, 608, 609, 1, 0, 0, 0, 609, 610, 1, 0, 0, 0, 610, 611, 5, 15,
		0, 0, 611, 119, 1, 0, 0, 0, 612, 613, 5, 75, 0, 0, 613, 121, 1, 0, 0, 0,
		614, 615, 3, 192, 96, 0, 615, 616, 3, 104, 52, 0, 616, 123, 1, 0, 0, 0,
		617, 620, 3, 12, 6, 0, 618, 620, 3, 126, 63, 0, 619, 617, 1, 0, 0, 0, 619,
		618, 1, 0, 0, 0, 620, 125, 1, 0, 0, 0, 621, 622, 5, 76, 0, 0, 622, 127,
		1, 0, 0, 0, 623, 626, 3, 130, 65, 0, 624, 626, 3, 132, 66, 0, 625, 623,
		1, 0, 0, 0, 625, 624, 1, 0, 0, 0, 626, 129, 1, 0, 0, 0, 627, 628, 3, 192,
		96, 0, 628, 629, 5, 77, 0, 0, 629, 630, 5, 93, 0, 0, 630, 131, 1, 0, 0,
		0, 631, 632, 5, 78, 0, 0, 632, 634, 5, 14, 0, 0, 633, 635, 3, 2, 1, 0,
		634, 633, 1, 0, 0, 0, 634, 635, 1, 0, 0, 0, 635, 636, 1, 0, 0, 0, 636,
		639, 5, 15, 0, 0, 637, 638, 5, 35, 0, 0, 638, 640, 3, 138, 69, 0, 639,
		637, 1, 0, 0, 0, 639, 640, 1, 0, 0, 0, 640, 641, 1, 0, 0, 0, 641, 642,
		3, 6, 3, 0, 642, 133, 1, 0, 0, 0, 643, 645, 3, 180, 90, 0, 644, 646, 5,
		76, 0, 0, 645, 644, 1, 0, 0, 0, 645, 646, 1, 0, 0, 0, 646, 135, 1, 0, 0,
		0, 647, 648, 5, 35, 0, 0, 648, 649, 3, 138, 69, 0, 649, 137, 1, 0, 0, 0,
		650, 651, 5, 79, 0, 0, 651, 652, 5, 14, 0, 0, 652, 658, 5, 15, 0, 0, 653,
		655, 3, 142, 71, 0, 654, 656, 3, 140, 70, 0, 655, 654, 1, 0, 0, 0, 655,
		656, 1, 0, 0, 0, 656, 658, 1, 0, 0, 0, 657, 650, 1, 0, 0, 0, 657, 653,
		1, 0, 0, 0, 658, 139, 1, 0, 0, 0, 659, 660, 7, 9, 0, 0, 660, 141, 1, 0,
		0, 0, 661, 669, 3, 146, 73, 0, 662, 663, 5, 80, 0, 0, 663, 664, 5, 14,
		0, 0, 664, 669, 5, 15, 0, 0, 665, 669, 3, 184, 92, 0, 666, 669, 3, 144,
		72, 0, 667, 669, 3, 190, 95, 0, 668, 661, 1, 0, 0, 0, 668, 662, 1, 0, 0,
		0, 668, 665, 1, 0, 0, 0, 668, 666, 1, 0, 0, 0, 668, 667, 1, 0, 0, 0, 669,
		143, 1, 0, 0, 0, 670, 671, 3, 192, 96, 0, 671, 145, 1, 0, 0, 0, 672, 683,
		3, 150, 75, 0, 673, 683, 3, 168, 84, 0, 674, 683, 3, 160, 80, 0, 675, 683,
		3, 172, 86, 0, 676, 683, 3, 164, 82, 0, 677, 683, 3, 158, 79, 0, 678, 683,
		3, 154, 77, 0, 679, 683, 3, 152, 76, 0, 680, 683, 3, 156, 78, 0, 681, 683,
		3, 148, 74, 0, 682, 672, 1, 0, 0, 0, 682, 673, 1, 0, 0, 0, 682, 674, 1,
		0, 0, 0, 682, 675, 1, 0, 0, 0, 682, 676, 1, 0, 0, 0, 682, 677, 1, 0, 0,
		0, 682, 678, 1, 0, 0, 0, 682, 679, 1, 0, 0, 0, 682, 680, 1, 0, 0, 0, 682,
		681, 1, 0, 0, 0, 683, 147, 1, 0, 0, 0, 684, 685, 5, 81, 0, 0, 685, 686,
		5, 14, 0, 0, 686, 687, 5, 15, 0, 0, 687, 149, 1, 0, 0, 0, 688, 689, 5,
		82, 0, 0, 689, 692, 5, 14, 0, 0, 690, 693, 3, 168, 84, 0, 691, 693, 3,
		172, 86, 0, 692, 690, 1, 0, 0, 0, 692, 691, 1, 0, 0, 0, 692, 693, 1, 0,
		0, 0, 693, 694, 1, 0, 0, 0, 694, 695, 5, 15, 0, 0, 695, 151, 1, 0, 0, 0,
		696, 697, 5, 83, 0, 0, 697, 698, 5, 14, 0, 0, 698, 699, 5, 15, 0, 0, 699,
		153, 1, 0, 0, 0, 700, 701, 5, 84, 0, 0, 701, 702, 5, 14, 0, 0, 702, 703,
		5, 15, 0, 0, 703, 155, 1, 0, 0, 0, 704, 705, 5, 85, 0, 0, 705, 706, 5,
		14, 0, 0, 706, 707, 5, 15, 0, 0, 707, 157, 1, 0, 0, 0, 708, 709, 5, 86,
		0, 0, 709, 712, 5, 14, 0, 0, 710, 713, 5, 107, 0, 0, 711, 713, 3, 194,
		97, 0, 712, 710, 1, 0, 0, 0, 712, 711, 1, 0, 0, 0, 712, 713, 1, 0, 0, 0,
		713, 714, 1, 0, 0, 0, 714, 715, 5, 15, 0, 0, 715, 159, 1, 0, 0, 0, 716,
		717, 5, 59, 0, 0, 717, 723, 5, 14, 0, 0, 718, 721, 3, 162, 81, 0, 719,
		720, 5, 1, 0, 0, 720, 722, 3, 182, 91, 0, 721, 719, 1, 0, 0, 0, 721, 722,
		1, 0, 0, 0, 722, 724, 1, 0, 0, 0, 723, 718, 1, 0, 0, 0, 723, 724, 1, 0,
		0, 0, 724, 725, 1, 0, 0, 0, 725, 726, 5, 15, 0, 0, 726, 161, 1, 0, 0, 0,
		727, 730, 3, 176, 88, 0, 728, 730, 5, 24, 0, 0, 729, 727, 1, 0, 0, 0, 729,
		728, 1, 0, 0, 0, 730, 163, 1, 0, 0, 0, 731, 732, 5, 87, 0, 0, 732, 733,
		5, 14, 0, 0, 733, 734, 3, 166, 83, 0, 734, 735, 5, 15, 0, 0, 735, 165,
		1, 0, 0, 0, 736, 737, 3, 176, 88, 0, 737, 167, 1, 0, 0, 0, 738, 739, 5,
		88, 0, 0, 739, 748, 5, 14, 0, 0, 740, 746, 3, 170, 85, 0, 741, 742, 5,
		1, 0, 0, 742, 744, 3, 182, 91, 0, 743, 745, 5, 76, 0, 0, 744, 743, 1, 0,
		0, 0, 744, 745, 1, 0, 0, 0, 745, 747, 1, 0, 0, 0, 746, 741, 1, 0, 0, 0,
		746, 747, 1, 0, 0, 0, 747, 749, 1, 0, 0, 0, 748, 740, 1, 0, 0, 0, 748,
		749, 1, 0, 0, 0, 749, 750, 1, 0, 0, 0, 750, 751, 5, 15, 0, 0, 751, 169,
		1, 0, 0, 0, 752, 755, 3, 178, 89, 0, 753, 755, 5, 24, 0, 0, 754, 752, 1,
		0, 0, 0, 754, 753, 1, 0, 0, 0, 755, 171, 1, 0, 0, 0, 756, 757, 5, 89, 0,
		0, 757, 758, 5, 14, 0, 0, 758, 759, 3, 174, 87, 0, 759, 760, 5, 15, 0,
		0, 760, 173, 1, 0, 0, 0, 761, 762, 3, 178, 89, 0, 762, 175, 1, 0, 0, 0,
		763, 764, 3, 192, 96, 0, 764, 177, 1, 0, 0, 0, 765, 766, 3, 192, 96, 0,
		766, 179, 1, 0, 0, 0, 767, 768, 3, 182, 91, 0, 768, 181, 1, 0, 0, 0, 769,
		770, 5, 102, 0, 0, 770, 183, 1, 0, 0, 0, 771, 774, 3, 186, 93, 0, 772,
		774, 3, 188, 94, 0, 773, 771, 1, 0, 0, 0, 773, 772, 1, 0, 0, 0, 774, 185,
		1, 0, 0, 0, 775, 776, 5, 78, 0, 0, 776, 777, 5, 14, 0, 0, 777, 778, 5,
		24, 0, 0, 778, 779, 5, 15, 0, 0, 779, 187, 1, 0, 0, 0, 780, 781, 5, 78,
		0, 0, 781, 790, 5, 14, 0, 0, 782, 787, 3, 138, 69, 0, 783, 784, 5, 1, 0,
		0, 784, 786, 3, 138, 69, 0, 785, 783, 1, 0, 0, 0, 786, 789, 1, 0, 0, 0,
		787, 785, 1, 0, 0, 0, 787, 788, 1, 0, 0, 0, 788, 791, 1, 0, 0, 0, 789,
		787, 1, 0, 0, 0, 790, 782, 1, 0, 0, 0, 790, 791, 1, 0, 0, 0, 791, 792,
		1, 0, 0, 0, 792, 793, 5, 15, 0, 0, 793, 794, 5, 35, 0, 0, 794, 795, 3,
		138, 69, 0, 795, 189, 1, 0, 0, 0, 796, 797, 5, 14, 0, 0, 797, 798, 3, 142,
		71, 0, 798, 799, 5, 15, 0, 0, 799, 191, 1, 0, 0, 0, 800, 801, 7, 10, 0,
		0, 801, 193, 1, 0, 0, 0, 802, 807, 5, 90, 0, 0, 803, 806, 5, 96, 0, 0,
		804, 806, 9, 0, 0, 0, 805, 803, 1, 0, 0, 0, 805, 804, 1, 0, 0, 0, 806,
		809, 1, 0, 0, 0, 807, 808, 1, 0, 0, 0, 807, 805, 1, 0, 0, 0, 808, 810,
		1, 0, 0, 0, 809, 807, 1, 0, 0, 0, 810, 821, 5, 90, 0, 0, 811, 816, 5, 91,
		0, 0, 812, 815, 5, 97, 0, 0, 813, 815, 9, 0, 0, 0, 814, 812, 1, 0, 0, 0,
		814, 813, 1, 0, 0, 0, 815, 818, 1, 0, 0, 0, 816, 817, 1, 0, 0, 0, 816,
		814, 1, 0, 0, 0, 817, 819, 1, 0, 0, 0, 818, 816, 1, 0, 0, 0, 819, 821,
		5, 91, 0, 0, 820, 802, 1, 0, 0, 0, 820, 811, 1, 0, 0, 0, 821, 195, 1, 0,
		0, 0, 70, 204, 210, 223, 231, 248, 271, 292, 317, 328, 336, 340, 350, 361,
		372, 383, 394, 405, 414, 422, 430, 438, 445, 460, 465, 470, 477, 482, 486,
		494, 512, 515, 523, 535, 541, 545, 556, 561, 563, 572, 575, 582, 595, 604,
		608, 619, 625, 634, 639, 645, 655, 657, 668, 682, 692, 712, 721, 723, 729,
		744, 746, 748, 754, 773, 787, 790, 805, 807, 814, 816, 820,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// XPath3ParserInit initializes any static state used to implement XPath3Parser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewXPath3Parser(). You can call this function if you wish to initialize the static state ahead
// of time.
func XPath3ParserInit() {
	staticData := &XPath3ParserStaticData
	staticData.once.Do(xpath3ParserInit)
}

// NewXPath3Parser produces a new parser instance for the optional input antlr.TokenStream.
func NewXPath3Parser(input antlr.TokenStream) *XPath3Parser {
	XPath3ParserInit()
	this := new(XPath3Parser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &XPath3ParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "XPath3.g"

	return this
}

// XPath3Parser tokens.
const (
	XPath3ParserEOF              = antlr.TokenEOF
	XPath3ParserT__0             = 1
	XPath3ParserT__1             = 2
	XPath3ParserT__2             = 3
	XPath3ParserT__3             = 4
	XPath3ParserT__4             = 5
	XPath3ParserT__5             = 6
	XPath3ParserT__6             = 7
	XPath3ParserT__7             = 8
	XPath3ParserT__8             = 9
	XPath3ParserT__9             = 10
	XPath3ParserT__10            = 11
	XPath3ParserT__11            = 12
	XPath3ParserT__12            = 13
	XPath3ParserT__13            = 14
	XPath3ParserT__14            = 15
	XPath3ParserT__15            = 16
	XPath3ParserT__16            = 17
	XPath3ParserT__17            = 18
	XPath3ParserT__18            = 19
	XPath3ParserT__19            = 20
	XPath3ParserT__20            = 21
	XPath3ParserT__21            = 22
	XPath3ParserT__22            = 23
	XPath3ParserT__23            = 24
	XPath3ParserT__24            = 25
	XPath3ParserT__25            = 26
	XPath3ParserT__26            = 27
	XPath3ParserT__27            = 28
	XPath3ParserT__28            = 29
	XPath3ParserT__29            = 30
	XPath3ParserT__30            = 31
	XPath3ParserT__31            = 32
	XPath3ParserT__32            = 33
	XPath3ParserT__33            = 34
	XPath3ParserT__34            = 35
	XPath3ParserT__35            = 36
	XPath3ParserT__36            = 37
	XPath3ParserT__37            = 38
	XPath3ParserT__38            = 39
	XPath3ParserT__39            = 40
	XPath3ParserT__40            = 41
	XPath3ParserT__41            = 42
	XPath3ParserT__42            = 43
	XPath3ParserT__43            = 44
	XPath3ParserT__44            = 45
	XPath3ParserT__45            = 46
	XPath3ParserT__46            = 47
	XPath3ParserT__47            = 48
	XPath3ParserT__48            = 49
	XPath3ParserT__49            = 50
	XPath3ParserT__50            = 51
	XPath3ParserT__51            = 52
	XPath3ParserT__52            = 53
	XPath3ParserT__53            = 54
	XPath3ParserT__54            = 55
	XPath3ParserT__55            = 56
	XPath3ParserT__56            = 57
	XPath3ParserT__57            = 58
	XPath3ParserT__58            = 59
	XPath3ParserT__59            = 60
	XPath3ParserT__60            = 61
	XPath3ParserT__61            = 62
	XPath3ParserT__62            = 63
	XPath3ParserT__63            = 64
	XPath3ParserT__64            = 65
	XPath3ParserT__65            = 66
	XPath3ParserT__66            = 67
	XPath3ParserT__67            = 68
	XPath3ParserT__68            = 69
	XPath3ParserT__69            = 70
	XPath3ParserT__70            = 71
	XPath3ParserT__71            = 72
	XPath3ParserT__72            = 73
	XPath3ParserT__73            = 74
	XPath3ParserT__74            = 75
	XPath3ParserT__75            = 76
	XPath3ParserT__76            = 77
	XPath3ParserT__77            = 78
	XPath3ParserT__78            = 79
	XPath3ParserT__79            = 80
	XPath3ParserT__80            = 81
	XPath3ParserT__81            = 82
	XPath3ParserT__82            = 83
	XPath3ParserT__83            = 84
	XPath3ParserT__84            = 85
	XPath3ParserT__85            = 86
	XPath3ParserT__86            = 87
	XPath3ParserT__87            = 88
	XPath3ParserT__88            = 89
	XPath3ParserT__89            = 90
	XPath3ParserT__90            = 91
	XPath3ParserNumericLiteral   = 92
	XPath3ParserIntegerLiteral   = 93
	XPath3ParserDecimalLiteral   = 94
	XPath3ParserDoubleLiteral    = 95
	XPath3ParserESCAPE_QUOTE     = 96
	XPath3ParserESCAPE_APOS      = 97
	XPath3ParserURIQualifiedName = 98
	XPath3ParserComment          = 99
	XPath3ParserBracedURILiteral = 100
	XPath3ParserCommentContents  = 101
	XPath3ParserQNAME            = 102
	XPath3ParserPREFIXED_NAME    = 103
	XPath3ParserUNPREFIXED_NAME  = 104
	XPath3ParserPREFIX           = 105
	XPath3ParserLOCAL_PART       = 106
	XPath3ParserNC_NAME          = 107
	XPath3ParserCHAR             = 108
	XPath3ParserDIGITS           = 109
)

// XPath3Parser rules.
const (
	XPath3ParserRULE_xPath                   = 0
	XPath3ParserRULE_paramList               = 1
	XPath3ParserRULE_param                   = 2
	XPath3ParserRULE_functionBody            = 3
	XPath3ParserRULE_enclosedExpr            = 4
	XPath3ParserRULE_expr                    = 5
	XPath3ParserRULE_exprSingle              = 6
	XPath3ParserRULE_forExpr                 = 7
	XPath3ParserRULE_simpleForClause         = 8
	XPath3ParserRULE_forBindingList          = 9
	XPath3ParserRULE_simpleForBinding        = 10
	XPath3ParserRULE_letExpr                 = 11
	XPath3ParserRULE_simpleLetClause         = 12
	XPath3ParserRULE_letBindingList          = 13
	XPath3ParserRULE_simpleLetBinding        = 14
	XPath3ParserRULE_quantifiedExpr          = 15
	XPath3ParserRULE_quantifiedBindingList   = 16
	XPath3ParserRULE_simpleQuantifiedBinding = 17
	XPath3ParserRULE_ifExpr                  = 18
	XPath3ParserRULE_orExpr                  = 19
	XPath3ParserRULE_andExpr                 = 20
	XPath3ParserRULE_comparisonExpr          = 21
	XPath3ParserRULE_stringConcatExpr        = 22
	XPath3ParserRULE_rangeExpr               = 23
	XPath3ParserRULE_additiveExpr            = 24
	XPath3ParserRULE_multiplicativeExpr      = 25
	XPath3ParserRULE_unionExpr               = 26
	XPath3ParserRULE_intersectExceptExpr     = 27
	XPath3ParserRULE_instanceofExpr          = 28
	XPath3ParserRULE_treatExpr               = 29
	XPath3ParserRULE_castableExpr            = 30
	XPath3ParserRULE_castExpr                = 31
	XPath3ParserRULE_unaryExpr               = 32
	XPath3ParserRULE_valueExpr               = 33
	XPath3ParserRULE_generalComp             = 34
	XPath3ParserRULE_valueComp               = 35
	XPath3ParserRULE_nodeComp                = 36
	XPath3ParserRULE_simpleMapExpr           = 37
	XPath3ParserRULE_pathExpr                = 38
	XPath3ParserRULE_relativePathExpr        = 39
	XPath3ParserRULE_stepExpr                = 40
	XPath3ParserRULE_axisStep                = 41
	XPath3ParserRULE_forwardStep             = 42
	XPath3ParserRULE_forwardAxis             = 43
	XPath3ParserRULE_abbrevForwardStep       = 44
	XPath3ParserRULE_reverseStep             = 45
	XPath3ParserRULE_reverseAxis             = 46
	XPath3ParserRULE_abbrevReverseStep       = 47
	XPath3ParserRULE_nodeTest                = 48
	XPath3ParserRULE_nameTest                = 49
	XPath3ParserRULE_wildCard                = 50
	XPath3ParserRULE_postfixExpr             = 51
	XPath3ParserRULE_argumentList            = 52
	XPath3ParserRULE_predicateList           = 53
	XPath3ParserRULE_predicate               = 54
	XPath3ParserRULE_primaryExpr             = 55
	XPath3ParserRULE_varRef                  = 56
	XPath3ParserRULE_varName                 = 57
	XPath3ParserRULE_literal                 = 58
	XPath3ParserRULE_parenthesizedExpr       = 59
	XPath3ParserRULE_contextItemExpr         = 60
	XPath3ParserRULE_functionCall            = 61
	XPath3ParserRULE_argument                = 62
	XPath3ParserRULE_argumentPlaceholder     = 63
	XPath3ParserRULE_functionItemExpr        = 64
	XPath3ParserRULE_namedFunctionRef        = 65
	XPath3ParserRULE_inlineFunctionExpr      = 66
	XPath3ParserRULE_singleType              = 67
	XPath3ParserRULE_type_declaration        = 68
	XPath3ParserRULE_sequenceType            = 69
	XPath3ParserRULE_occurenceIndicator      = 70
	XPath3ParserRULE_itemType                = 71
	XPath3ParserRULE_atomicOrUnionType       = 72
	XPath3ParserRULE_kindTest                = 73
	XPath3ParserRULE_anyKindTest             = 74
	XPath3ParserRULE_documentTest            = 75
	XPath3ParserRULE_textTest                = 76
	XPath3ParserRULE_commentTest             = 77
	XPath3ParserRULE_namespaceNodeTest       = 78
	XPath3ParserRULE_piTest                  = 79
	XPath3ParserRULE_attributeTest           = 80
	XPath3ParserRULE_attribNameOrWildcard    = 81
	XPath3ParserRULE_schemaAttributeTest     = 82
	XPath3ParserRULE_attributeDeclaration    = 83
	XPath3ParserRULE_elementTest             = 84
	XPath3ParserRULE_elementNameOrWildcard   = 85
	XPath3ParserRULE_schemaElementTest       = 86
	XPath3ParserRULE_elementDeclaration      = 87
	XPath3ParserRULE_attributeName           = 88
	XPath3ParserRULE_elementName             = 89
	XPath3ParserRULE_simpleTypeName          = 90
	XPath3ParserRULE_typeName                = 91
	XPath3ParserRULE_functionTest            = 92
	XPath3ParserRULE_anyFunctionTest         = 93
	XPath3ParserRULE_typedFunctionTest       = 94
	XPath3ParserRULE_parenthesizedItemType   = 95
	XPath3ParserRULE_eqName                  = 96
	XPath3ParserRULE_stringLiteral           = 97
)

// IXPathContext is an interface to support dynamic dispatch.
type IXPathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	EOF() antlr.TerminalNode

	// IsXPathContext differentiates from other interfaces.
	IsXPathContext()
}

type XPathContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXPathContext() *XPathContext {
	var p = new(XPathContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_xPath
	return p
}

func InitEmptyXPathContext(p *XPathContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_xPath
}

func (*XPathContext) IsXPathContext() {}

func NewXPathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XPathContext {
	var p = new(XPathContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_xPath

	return p
}

func (s *XPathContext) GetParser() antlr.Parser { return s.parser }

func (s *XPathContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *XPathContext) EOF() antlr.TerminalNode {
	return s.GetToken(XPath3ParserEOF, 0)
}

func (s *XPathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XPathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *XPathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterXPath(s)
	}
}

func (s *XPathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitXPath(s)
	}
}

func (p *XPath3Parser) XPath() (localctx IXPathContext) {
	localctx = NewXPathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, XPath3ParserRULE_xPath)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(196)
		p.Expr()
	}
	{
		p.SetState(197)
		p.Match(XPath3ParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParamListContext is an interface to support dynamic dispatch.
type IParamListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllParam() []IParamContext
	Param(i int) IParamContext

	// IsParamListContext differentiates from other interfaces.
	IsParamListContext()
}

type ParamListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParamListContext() *ParamListContext {
	var p = new(ParamListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_paramList
	return p
}

func InitEmptyParamListContext(p *ParamListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_paramList
}

func (*ParamListContext) IsParamListContext() {}

func NewParamListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamListContext {
	var p = new(ParamListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_paramList

	return p
}

func (s *ParamListContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamListContext) AllParam() []IParamContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParamContext); ok {
			len++
		}
	}

	tst := make([]IParamContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParamContext); ok {
			tst[i] = t.(IParamContext)
			i++
		}
	}

	return tst
}

func (s *ParamListContext) Param(i int) IParamContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParamContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParamContext)
}

func (s *ParamListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParamListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterParamList(s)
	}
}

func (s *ParamListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitParamList(s)
	}
}

func (p *XPath3Parser) ParamList() (localctx IParamListContext) {
	localctx = NewParamListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, XPath3ParserRULE_paramList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(199)
		p.Param()
	}
	p.SetState(204)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == XPath3ParserT__0 {
		{
			p.SetState(200)
			p.Match(XPath3ParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(201)
			p.Param()
		}

		p.SetState(206)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParamContext is an interface to support dynamic dispatch.
type IParamContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EqName() IEqNameContext
	Type_declaration() IType_declarationContext

	// IsParamContext differentiates from other interfaces.
	IsParamContext()
}

type ParamContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParamContext() *ParamContext {
	var p = new(ParamContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_param
	return p
}

func InitEmptyParamContext(p *ParamContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_param
}

func (*ParamContext) IsParamContext() {}

func NewParamContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamContext {
	var p = new(ParamContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_param

	return p
}

func (s *ParamContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamContext) EqName() IEqNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqNameContext)
}

func (s *ParamContext) Type_declaration() IType_declarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_declarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_declarationContext)
}

func (s *ParamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterParam(s)
	}
}

func (s *ParamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitParam(s)
	}
}

func (p *XPath3Parser) Param() (localctx IParamContext) {
	localctx = NewParamContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, XPath3ParserRULE_param)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(207)
		p.Match(XPath3ParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(208)
		p.EqName()
	}
	p.SetState(210)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == XPath3ParserT__34 {
		{
			p.SetState(209)
			p.Type_declaration()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionBodyContext is an interface to support dynamic dispatch.
type IFunctionBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EnclosedExpr() IEnclosedExprContext

	// IsFunctionBodyContext differentiates from other interfaces.
	IsFunctionBodyContext()
}

type FunctionBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionBodyContext() *FunctionBodyContext {
	var p = new(FunctionBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_functionBody
	return p
}

func InitEmptyFunctionBodyContext(p *FunctionBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_functionBody
}

func (*FunctionBodyContext) IsFunctionBodyContext() {}

func NewFunctionBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionBodyContext {
	var p = new(FunctionBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_functionBody

	return p
}

func (s *FunctionBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionBodyContext) EnclosedExpr() IEnclosedExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnclosedExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnclosedExprContext)
}

func (s *FunctionBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterFunctionBody(s)
	}
}

func (s *FunctionBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitFunctionBody(s)
	}
}

func (p *XPath3Parser) FunctionBody() (localctx IFunctionBodyContext) {
	localctx = NewFunctionBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, XPath3ParserRULE_functionBody)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(212)
		p.EnclosedExpr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnclosedExprContext is an interface to support dynamic dispatch.
type IEnclosedExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext

	// IsEnclosedExprContext differentiates from other interfaces.
	IsEnclosedExprContext()
}

type EnclosedExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnclosedExprContext() *EnclosedExprContext {
	var p = new(EnclosedExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_enclosedExpr
	return p
}

func InitEmptyEnclosedExprContext(p *EnclosedExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_enclosedExpr
}

func (*EnclosedExprContext) IsEnclosedExprContext() {}

func NewEnclosedExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnclosedExprContext {
	var p = new(EnclosedExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_enclosedExpr

	return p
}

func (s *EnclosedExprContext) GetParser() antlr.Parser { return s.parser }

func (s *EnclosedExprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *EnclosedExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnclosedExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnclosedExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterEnclosedExpr(s)
	}
}

func (s *EnclosedExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitEnclosedExpr(s)
	}
}

func (p *XPath3Parser) EnclosedExpr() (localctx IEnclosedExprContext) {
	localctx = NewEnclosedExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, XPath3ParserRULE_enclosedExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(214)
		p.Match(XPath3ParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(215)
		p.Expr()
	}
	{
		p.SetState(216)
		p.Match(XPath3ParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExprSingle() []IExprSingleContext
	ExprSingle(i int) IExprSingleContext

	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_expr
	return p
}

func InitEmptyExprContext(p *ExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_expr
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) AllExprSingle() []IExprSingleContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprSingleContext); ok {
			len++
		}
	}

	tst := make([]IExprSingleContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprSingleContext); ok {
			tst[i] = t.(IExprSingleContext)
			i++
		}
	}

	return tst
}

func (s *ExprContext) ExprSingle(i int) IExprSingleContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprSingleContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprSingleContext)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterExpr(s)
	}
}

func (s *ExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitExpr(s)
	}
}

func (p *XPath3Parser) Expr() (localctx IExprContext) {
	localctx = NewExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, XPath3ParserRULE_expr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(218)
		p.ExprSingle()
	}
	p.SetState(223)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == XPath3ParserT__0 {
		{
			p.SetState(219)
			p.Match(XPath3ParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(220)
			p.ExprSingle()
		}

		p.SetState(225)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprSingleContext is an interface to support dynamic dispatch.
type IExprSingleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ForExpr() IForExprContext
	LetExpr() ILetExprContext
	QuantifiedExpr() IQuantifiedExprContext
	IfExpr() IIfExprContext
	OrExpr() IOrExprContext

	// IsExprSingleContext differentiates from other interfaces.
	IsExprSingleContext()
}

type ExprSingleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprSingleContext() *ExprSingleContext {
	var p = new(ExprSingleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_exprSingle
	return p
}

func InitEmptyExprSingleContext(p *ExprSingleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_exprSingle
}

func (*ExprSingleContext) IsExprSingleContext() {}

func NewExprSingleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprSingleContext {
	var p = new(ExprSingleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_exprSingle

	return p
}

func (s *ExprSingleContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprSingleContext) ForExpr() IForExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForExprContext)
}

func (s *ExprSingleContext) LetExpr() ILetExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetExprContext)
}

func (s *ExprSingleContext) QuantifiedExpr() IQuantifiedExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuantifiedExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuantifiedExprContext)
}

func (s *ExprSingleContext) IfExpr() IIfExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExprContext)
}

func (s *ExprSingleContext) OrExpr() IOrExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrExprContext)
}

func (s *ExprSingleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprSingleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprSingleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterExprSingle(s)
	}
}

func (s *ExprSingleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitExprSingle(s)
	}
}

func (p *XPath3Parser) ExprSingle() (localctx IExprSingleContext) {
	localctx = NewExprSingleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, XPath3ParserRULE_exprSingle)
	p.SetState(231)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserT__5:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(226)
			p.ForExpr()
		}

	case XPath3ParserT__7:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(227)
			p.LetExpr()
		}

	case XPath3ParserT__9, XPath3ParserT__10:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(228)
			p.QuantifiedExpr()
		}

	case XPath3ParserT__12:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(229)
			p.IfExpr()
		}

	case XPath3ParserT__1, XPath3ParserT__13, XPath3ParserT__21, XPath3ParserT__22, XPath3ParserT__23, XPath3ParserT__53, XPath3ParserT__54, XPath3ParserT__55, XPath3ParserT__57, XPath3ParserT__58, XPath3ParserT__59, XPath3ParserT__60, XPath3ParserT__61, XPath3ParserT__62, XPath3ParserT__63, XPath3ParserT__64, XPath3ParserT__65, XPath3ParserT__66, XPath3ParserT__67, XPath3ParserT__68, XPath3ParserT__69, XPath3ParserT__70, XPath3ParserT__74, XPath3ParserT__77, XPath3ParserT__80, XPath3ParserT__81, XPath3ParserT__82, XPath3ParserT__83, XPath3ParserT__84, XPath3ParserT__85, XPath3ParserT__86, XPath3ParserT__87, XPath3ParserT__88, XPath3ParserT__89, XPath3ParserT__90, XPath3ParserNumericLiteral, XPath3ParserURIQualifiedName, XPath3ParserBracedURILiteral, XPath3ParserQNAME, XPath3ParserNC_NAME:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(230)
			p.orExpr(0)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForExprContext is an interface to support dynamic dispatch.
type IForExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleForClause() ISimpleForClauseContext
	ExprSingle() IExprSingleContext

	// IsForExprContext differentiates from other interfaces.
	IsForExprContext()
}

type ForExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForExprContext() *ForExprContext {
	var p = new(ForExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_forExpr
	return p
}

func InitEmptyForExprContext(p *ForExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_forExpr
}

func (*ForExprContext) IsForExprContext() {}

func NewForExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForExprContext {
	var p = new(ForExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_forExpr

	return p
}

func (s *ForExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ForExprContext) SimpleForClause() ISimpleForClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleForClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleForClauseContext)
}

func (s *ForExprContext) ExprSingle() IExprSingleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprSingleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprSingleContext)
}

func (s *ForExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterForExpr(s)
	}
}

func (s *ForExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitForExpr(s)
	}
}

func (p *XPath3Parser) ForExpr() (localctx IForExprContext) {
	localctx = NewForExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, XPath3ParserRULE_forExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(233)
		p.SimpleForClause()
	}
	{
		p.SetState(234)
		p.Match(XPath3ParserT__4)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(235)
		p.ExprSingle()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleForClauseContext is an interface to support dynamic dispatch.
type ISimpleForClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ForBindingList() IForBindingListContext

	// IsSimpleForClauseContext differentiates from other interfaces.
	IsSimpleForClauseContext()
}

type SimpleForClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleForClauseContext() *SimpleForClauseContext {
	var p = new(SimpleForClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_simpleForClause
	return p
}

func InitEmptySimpleForClauseContext(p *SimpleForClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_simpleForClause
}

func (*SimpleForClauseContext) IsSimpleForClauseContext() {}

func NewSimpleForClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleForClauseContext {
	var p = new(SimpleForClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_simpleForClause

	return p
}

func (s *SimpleForClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleForClauseContext) ForBindingList() IForBindingListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForBindingListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForBindingListContext)
}

func (s *SimpleForClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleForClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleForClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterSimpleForClause(s)
	}
}

func (s *SimpleForClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitSimpleForClause(s)
	}
}

func (p *XPath3Parser) SimpleForClause() (localctx ISimpleForClauseContext) {
	localctx = NewSimpleForClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, XPath3ParserRULE_simpleForClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(237)
		p.Match(XPath3ParserT__5)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(238)
		p.forBindingList(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForBindingListContext is an interface to support dynamic dispatch.
type IForBindingListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleForBinding() ISimpleForBindingContext
	ForBindingList() IForBindingListContext

	// IsForBindingListContext differentiates from other interfaces.
	IsForBindingListContext()
}

type ForBindingListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForBindingListContext() *ForBindingListContext {
	var p = new(ForBindingListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_forBindingList
	return p
}

func InitEmptyForBindingListContext(p *ForBindingListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_forBindingList
}

func (*ForBindingListContext) IsForBindingListContext() {}

func NewForBindingListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForBindingListContext {
	var p = new(ForBindingListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_forBindingList

	return p
}

func (s *ForBindingListContext) GetParser() antlr.Parser { return s.parser }

func (s *ForBindingListContext) SimpleForBinding() ISimpleForBindingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleForBindingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleForBindingContext)
}

func (s *ForBindingListContext) ForBindingList() IForBindingListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForBindingListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForBindingListContext)
}

func (s *ForBindingListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForBindingListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForBindingListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterForBindingList(s)
	}
}

func (s *ForBindingListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitForBindingList(s)
	}
}

func (p *XPath3Parser) ForBindingList() (localctx IForBindingListContext) {
	return p.forBindingList(0)
}

func (p *XPath3Parser) forBindingList(_p int) (localctx IForBindingListContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewForBindingListContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IForBindingListContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 18
	p.EnterRecursionRule(localctx, 18, XPath3ParserRULE_forBindingList, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(241)
		p.SimpleForBinding()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(248)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 4, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewForBindingListContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, XPath3ParserRULE_forBindingList)
			p.SetState(243)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(244)
				p.Match(XPath3ParserT__0)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(245)
				p.SimpleForBinding()
			}

		}
		p.SetState(250)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 4, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleForBindingContext is an interface to support dynamic dispatch.
type ISimpleForBindingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VarName() IVarNameContext
	ExprSingle() IExprSingleContext

	// IsSimpleForBindingContext differentiates from other interfaces.
	IsSimpleForBindingContext()
}

type SimpleForBindingContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleForBindingContext() *SimpleForBindingContext {
	var p = new(SimpleForBindingContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_simpleForBinding
	return p
}

func InitEmptySimpleForBindingContext(p *SimpleForBindingContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_simpleForBinding
}

func (*SimpleForBindingContext) IsSimpleForBindingContext() {}

func NewSimpleForBindingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleForBindingContext {
	var p = new(SimpleForBindingContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_simpleForBinding

	return p
}

func (s *SimpleForBindingContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleForBindingContext) VarName() IVarNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarNameContext)
}

func (s *SimpleForBindingContext) ExprSingle() IExprSingleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprSingleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprSingleContext)
}

func (s *SimpleForBindingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleForBindingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleForBindingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterSimpleForBinding(s)
	}
}

func (s *SimpleForBindingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitSimpleForBinding(s)
	}
}

func (p *XPath3Parser) SimpleForBinding() (localctx ISimpleForBindingContext) {
	localctx = NewSimpleForBindingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, XPath3ParserRULE_simpleForBinding)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(251)
		p.Match(XPath3ParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(252)
		p.VarName()
	}
	{
		p.SetState(253)
		p.Match(XPath3ParserT__6)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(254)
		p.ExprSingle()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetExprContext is an interface to support dynamic dispatch.
type ILetExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleLetClause() ISimpleLetClauseContext
	ExprSingle() IExprSingleContext

	// IsLetExprContext differentiates from other interfaces.
	IsLetExprContext()
}

type LetExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetExprContext() *LetExprContext {
	var p = new(LetExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_letExpr
	return p
}

func InitEmptyLetExprContext(p *LetExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_letExpr
}

func (*LetExprContext) IsLetExprContext() {}

func NewLetExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetExprContext {
	var p = new(LetExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_letExpr

	return p
}

func (s *LetExprContext) GetParser() antlr.Parser { return s.parser }

func (s *LetExprContext) SimpleLetClause() ISimpleLetClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleLetClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleLetClauseContext)
}

func (s *LetExprContext) ExprSingle() IExprSingleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprSingleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprSingleContext)
}

func (s *LetExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterLetExpr(s)
	}
}

func (s *LetExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitLetExpr(s)
	}
}

func (p *XPath3Parser) LetExpr() (localctx ILetExprContext) {
	localctx = NewLetExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, XPath3ParserRULE_letExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(256)
		p.SimpleLetClause()
	}
	{
		p.SetState(257)
		p.Match(XPath3ParserT__4)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(258)
		p.ExprSingle()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleLetClauseContext is an interface to support dynamic dispatch.
type ISimpleLetClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LetBindingList() ILetBindingListContext

	// IsSimpleLetClauseContext differentiates from other interfaces.
	IsSimpleLetClauseContext()
}

type SimpleLetClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleLetClauseContext() *SimpleLetClauseContext {
	var p = new(SimpleLetClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_simpleLetClause
	return p
}

func InitEmptySimpleLetClauseContext(p *SimpleLetClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_simpleLetClause
}

func (*SimpleLetClauseContext) IsSimpleLetClauseContext() {}

func NewSimpleLetClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleLetClauseContext {
	var p = new(SimpleLetClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_simpleLetClause

	return p
}

func (s *SimpleLetClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleLetClauseContext) LetBindingList() ILetBindingListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetBindingListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetBindingListContext)
}

func (s *SimpleLetClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleLetClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleLetClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterSimpleLetClause(s)
	}
}

func (s *SimpleLetClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitSimpleLetClause(s)
	}
}

func (p *XPath3Parser) SimpleLetClause() (localctx ISimpleLetClauseContext) {
	localctx = NewSimpleLetClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, XPath3ParserRULE_simpleLetClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(260)
		p.Match(XPath3ParserT__7)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(261)
		p.letBindingList(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetBindingListContext is an interface to support dynamic dispatch.
type ILetBindingListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleLetClause() ISimpleLetClauseContext
	LetBindingList() ILetBindingListContext
	SimpleLetBinding() ISimpleLetBindingContext

	// IsLetBindingListContext differentiates from other interfaces.
	IsLetBindingListContext()
}

type LetBindingListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetBindingListContext() *LetBindingListContext {
	var p = new(LetBindingListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_letBindingList
	return p
}

func InitEmptyLetBindingListContext(p *LetBindingListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_letBindingList
}

func (*LetBindingListContext) IsLetBindingListContext() {}

func NewLetBindingListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetBindingListContext {
	var p = new(LetBindingListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_letBindingList

	return p
}

func (s *LetBindingListContext) GetParser() antlr.Parser { return s.parser }

func (s *LetBindingListContext) SimpleLetClause() ISimpleLetClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleLetClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleLetClauseContext)
}

func (s *LetBindingListContext) LetBindingList() ILetBindingListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetBindingListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetBindingListContext)
}

func (s *LetBindingListContext) SimpleLetBinding() ISimpleLetBindingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleLetBindingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleLetBindingContext)
}

func (s *LetBindingListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetBindingListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetBindingListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterLetBindingList(s)
	}
}

func (s *LetBindingListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitLetBindingList(s)
	}
}

func (p *XPath3Parser) LetBindingList() (localctx ILetBindingListContext) {
	return p.letBindingList(0)
}

func (p *XPath3Parser) letBindingList(_p int) (localctx ILetBindingListContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewLetBindingListContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ILetBindingListContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 26
	p.EnterRecursionRule(localctx, 26, XPath3ParserRULE_letBindingList, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(264)
		p.SimpleLetClause()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(271)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewLetBindingListContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, XPath3ParserRULE_letBindingList)
			p.SetState(266)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(267)
				p.Match(XPath3ParserT__0)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(268)
				p.SimpleLetBinding()
			}

		}
		p.SetState(273)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleLetBindingContext is an interface to support dynamic dispatch.
type ISimpleLetBindingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VarName() IVarNameContext
	ExprSingle() IExprSingleContext

	// IsSimpleLetBindingContext differentiates from other interfaces.
	IsSimpleLetBindingContext()
}

type SimpleLetBindingContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleLetBindingContext() *SimpleLetBindingContext {
	var p = new(SimpleLetBindingContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_simpleLetBinding
	return p
}

func InitEmptySimpleLetBindingContext(p *SimpleLetBindingContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_simpleLetBinding
}

func (*SimpleLetBindingContext) IsSimpleLetBindingContext() {}

func NewSimpleLetBindingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleLetBindingContext {
	var p = new(SimpleLetBindingContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_simpleLetBinding

	return p
}

func (s *SimpleLetBindingContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleLetBindingContext) VarName() IVarNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarNameContext)
}

func (s *SimpleLetBindingContext) ExprSingle() IExprSingleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprSingleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprSingleContext)
}

func (s *SimpleLetBindingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleLetBindingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleLetBindingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterSimpleLetBinding(s)
	}
}

func (s *SimpleLetBindingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitSimpleLetBinding(s)
	}
}

func (p *XPath3Parser) SimpleLetBinding() (localctx ISimpleLetBindingContext) {
	localctx = NewSimpleLetBindingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, XPath3ParserRULE_simpleLetBinding)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(274)
		p.Match(XPath3ParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(275)
		p.VarName()
	}
	{
		p.SetState(276)
		p.Match(XPath3ParserT__8)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(277)
		p.ExprSingle()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQuantifiedExprContext is an interface to support dynamic dispatch.
type IQuantifiedExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QuantifiedBindingList() IQuantifiedBindingListContext
	ExprSingle() IExprSingleContext

	// IsQuantifiedExprContext differentiates from other interfaces.
	IsQuantifiedExprContext()
}

type QuantifiedExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuantifiedExprContext() *QuantifiedExprContext {
	var p = new(QuantifiedExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_quantifiedExpr
	return p
}

func InitEmptyQuantifiedExprContext(p *QuantifiedExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_quantifiedExpr
}

func (*QuantifiedExprContext) IsQuantifiedExprContext() {}

func NewQuantifiedExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuantifiedExprContext {
	var p = new(QuantifiedExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_quantifiedExpr

	return p
}

func (s *QuantifiedExprContext) GetParser() antlr.Parser { return s.parser }

func (s *QuantifiedExprContext) QuantifiedBindingList() IQuantifiedBindingListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuantifiedBindingListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuantifiedBindingListContext)
}

func (s *QuantifiedExprContext) ExprSingle() IExprSingleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprSingleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprSingleContext)
}

func (s *QuantifiedExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuantifiedExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuantifiedExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterQuantifiedExpr(s)
	}
}

func (s *QuantifiedExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitQuantifiedExpr(s)
	}
}

func (p *XPath3Parser) QuantifiedExpr() (localctx IQuantifiedExprContext) {
	localctx = NewQuantifiedExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, XPath3ParserRULE_quantifiedExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(279)
		_la = p.GetTokenStream().LA(1)

		if !(_la == XPath3ParserT__9 || _la == XPath3ParserT__10) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(280)
		p.quantifiedBindingList(0)
	}
	{
		p.SetState(281)
		p.Match(XPath3ParserT__11)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(282)
		p.ExprSingle()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQuantifiedBindingListContext is an interface to support dynamic dispatch.
type IQuantifiedBindingListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleQuantifiedBinding() ISimpleQuantifiedBindingContext
	QuantifiedBindingList() IQuantifiedBindingListContext

	// IsQuantifiedBindingListContext differentiates from other interfaces.
	IsQuantifiedBindingListContext()
}

type QuantifiedBindingListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuantifiedBindingListContext() *QuantifiedBindingListContext {
	var p = new(QuantifiedBindingListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_quantifiedBindingList
	return p
}

func InitEmptyQuantifiedBindingListContext(p *QuantifiedBindingListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_quantifiedBindingList
}

func (*QuantifiedBindingListContext) IsQuantifiedBindingListContext() {}

func NewQuantifiedBindingListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuantifiedBindingListContext {
	var p = new(QuantifiedBindingListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_quantifiedBindingList

	return p
}

func (s *QuantifiedBindingListContext) GetParser() antlr.Parser { return s.parser }

func (s *QuantifiedBindingListContext) SimpleQuantifiedBinding() ISimpleQuantifiedBindingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleQuantifiedBindingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleQuantifiedBindingContext)
}

func (s *QuantifiedBindingListContext) QuantifiedBindingList() IQuantifiedBindingListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuantifiedBindingListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuantifiedBindingListContext)
}

func (s *QuantifiedBindingListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuantifiedBindingListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuantifiedBindingListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterQuantifiedBindingList(s)
	}
}

func (s *QuantifiedBindingListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitQuantifiedBindingList(s)
	}
}

func (p *XPath3Parser) QuantifiedBindingList() (localctx IQuantifiedBindingListContext) {
	return p.quantifiedBindingList(0)
}

func (p *XPath3Parser) quantifiedBindingList(_p int) (localctx IQuantifiedBindingListContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewQuantifiedBindingListContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IQuantifiedBindingListContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 32
	p.EnterRecursionRule(localctx, 32, XPath3ParserRULE_quantifiedBindingList, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(285)
		p.SimpleQuantifiedBinding()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(292)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 6, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewQuantifiedBindingListContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, XPath3ParserRULE_quantifiedBindingList)
			p.SetState(287)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(288)
				p.Match(XPath3ParserT__0)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(289)
				p.SimpleQuantifiedBinding()
			}

		}
		p.SetState(294)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 6, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleQuantifiedBindingContext is an interface to support dynamic dispatch.
type ISimpleQuantifiedBindingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VarName() IVarNameContext
	ExprSingle() IExprSingleContext

	// IsSimpleQuantifiedBindingContext differentiates from other interfaces.
	IsSimpleQuantifiedBindingContext()
}

type SimpleQuantifiedBindingContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleQuantifiedBindingContext() *SimpleQuantifiedBindingContext {
	var p = new(SimpleQuantifiedBindingContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_simpleQuantifiedBinding
	return p
}

func InitEmptySimpleQuantifiedBindingContext(p *SimpleQuantifiedBindingContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_simpleQuantifiedBinding
}

func (*SimpleQuantifiedBindingContext) IsSimpleQuantifiedBindingContext() {}

func NewSimpleQuantifiedBindingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleQuantifiedBindingContext {
	var p = new(SimpleQuantifiedBindingContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_simpleQuantifiedBinding

	return p
}

func (s *SimpleQuantifiedBindingContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleQuantifiedBindingContext) VarName() IVarNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarNameContext)
}

func (s *SimpleQuantifiedBindingContext) ExprSingle() IExprSingleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprSingleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprSingleContext)
}

func (s *SimpleQuantifiedBindingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleQuantifiedBindingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleQuantifiedBindingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterSimpleQuantifiedBinding(s)
	}
}

func (s *SimpleQuantifiedBindingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitSimpleQuantifiedBinding(s)
	}
}

func (p *XPath3Parser) SimpleQuantifiedBinding() (localctx ISimpleQuantifiedBindingContext) {
	localctx = NewSimpleQuantifiedBindingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, XPath3ParserRULE_simpleQuantifiedBinding)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(295)
		p.Match(XPath3ParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(296)
		p.VarName()
	}
	{
		p.SetState(297)
		p.Match(XPath3ParserT__6)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(298)
		p.ExprSingle()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfExprContext is an interface to support dynamic dispatch.
type IIfExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	AllExprSingle() []IExprSingleContext
	ExprSingle(i int) IExprSingleContext

	// IsIfExprContext differentiates from other interfaces.
	IsIfExprContext()
}

type IfExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfExprContext() *IfExprContext {
	var p = new(IfExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_ifExpr
	return p
}

func InitEmptyIfExprContext(p *IfExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_ifExpr
}

func (*IfExprContext) IsIfExprContext() {}

func NewIfExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfExprContext {
	var p = new(IfExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_ifExpr

	return p
}

func (s *IfExprContext) GetParser() antlr.Parser { return s.parser }

func (s *IfExprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *IfExprContext) AllExprSingle() []IExprSingleContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprSingleContext); ok {
			len++
		}
	}

	tst := make([]IExprSingleContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprSingleContext); ok {
			tst[i] = t.(IExprSingleContext)
			i++
		}
	}

	return tst
}

func (s *IfExprContext) ExprSingle(i int) IExprSingleContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprSingleContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprSingleContext)
}

func (s *IfExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterIfExpr(s)
	}
}

func (s *IfExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitIfExpr(s)
	}
}

func (p *XPath3Parser) IfExpr() (localctx IIfExprContext) {
	localctx = NewIfExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, XPath3ParserRULE_ifExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(300)
		p.Match(XPath3ParserT__12)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(301)
		p.Match(XPath3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(302)
		p.Expr()
	}
	{
		p.SetState(303)
		p.Match(XPath3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(304)
		p.Match(XPath3ParserT__15)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(305)
		p.ExprSingle()
	}
	{
		p.SetState(306)
		p.Match(XPath3ParserT__16)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(307)
		p.ExprSingle()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrExprContext is an interface to support dynamic dispatch.
type IOrExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AndExpr() IAndExprContext
	OrExpr() IOrExprContext

	// IsOrExprContext differentiates from other interfaces.
	IsOrExprContext()
}

type OrExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrExprContext() *OrExprContext {
	var p = new(OrExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_orExpr
	return p
}

func InitEmptyOrExprContext(p *OrExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_orExpr
}

func (*OrExprContext) IsOrExprContext() {}

func NewOrExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrExprContext {
	var p = new(OrExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_orExpr

	return p
}

func (s *OrExprContext) GetParser() antlr.Parser { return s.parser }

func (s *OrExprContext) AndExpr() IAndExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAndExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAndExprContext)
}

func (s *OrExprContext) OrExpr() IOrExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrExprContext)
}

func (s *OrExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterOrExpr(s)
	}
}

func (s *OrExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitOrExpr(s)
	}
}

func (p *XPath3Parser) OrExpr() (localctx IOrExprContext) {
	return p.orExpr(0)
}

func (p *XPath3Parser) orExpr(_p int) (localctx IOrExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewOrExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IOrExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 38
	p.EnterRecursionRule(localctx, 38, XPath3ParserRULE_orExpr, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(310)
		p.andExpr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(317)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 7, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewOrExprContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, XPath3ParserRULE_orExpr)
			p.SetState(312)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(313)
				p.Match(XPath3ParserT__17)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(314)
				p.andExpr(0)
			}

		}
		p.SetState(319)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 7, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAndExprContext is an interface to support dynamic dispatch.
type IAndExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ComparisonExpr() IComparisonExprContext
	AndExpr() IAndExprContext

	// IsAndExprContext differentiates from other interfaces.
	IsAndExprContext()
}

type AndExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAndExprContext() *AndExprContext {
	var p = new(AndExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_andExpr
	return p
}

func InitEmptyAndExprContext(p *AndExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_andExpr
}

func (*AndExprContext) IsAndExprContext() {}

func NewAndExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AndExprContext {
	var p = new(AndExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_andExpr

	return p
}

func (s *AndExprContext) GetParser() antlr.Parser { return s.parser }

func (s *AndExprContext) ComparisonExpr() IComparisonExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonExprContext)
}

func (s *AndExprContext) AndExpr() IAndExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAndExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAndExprContext)
}

func (s *AndExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AndExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AndExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterAndExpr(s)
	}
}

func (s *AndExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitAndExpr(s)
	}
}

func (p *XPath3Parser) AndExpr() (localctx IAndExprContext) {
	return p.andExpr(0)
}

func (p *XPath3Parser) andExpr(_p int) (localctx IAndExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewAndExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IAndExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 40
	p.EnterRecursionRule(localctx, 40, XPath3ParserRULE_andExpr, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(321)
		p.ComparisonExpr()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(328)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 8, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewAndExprContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, XPath3ParserRULE_andExpr)
			p.SetState(323)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(324)
				p.Match(XPath3ParserT__18)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(325)
				p.ComparisonExpr()
			}

		}
		p.SetState(330)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 8, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparisonExprContext is an interface to support dynamic dispatch.
type IComparisonExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllStringConcatExpr() []IStringConcatExprContext
	StringConcatExpr(i int) IStringConcatExprContext
	ValueComp() IValueCompContext
	GeneralComp() IGeneralCompContext
	NodeComp() INodeCompContext

	// IsComparisonExprContext differentiates from other interfaces.
	IsComparisonExprContext()
}

type ComparisonExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonExprContext() *ComparisonExprContext {
	var p = new(ComparisonExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_comparisonExpr
	return p
}

func InitEmptyComparisonExprContext(p *ComparisonExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_comparisonExpr
}

func (*ComparisonExprContext) IsComparisonExprContext() {}

func NewComparisonExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonExprContext {
	var p = new(ComparisonExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_comparisonExpr

	return p
}

func (s *ComparisonExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonExprContext) AllStringConcatExpr() []IStringConcatExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringConcatExprContext); ok {
			len++
		}
	}

	tst := make([]IStringConcatExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringConcatExprContext); ok {
			tst[i] = t.(IStringConcatExprContext)
			i++
		}
	}

	return tst
}

func (s *ComparisonExprContext) StringConcatExpr(i int) IStringConcatExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringConcatExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringConcatExprContext)
}

func (s *ComparisonExprContext) ValueComp() IValueCompContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueCompContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueCompContext)
}

func (s *ComparisonExprContext) GeneralComp() IGeneralCompContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGeneralCompContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGeneralCompContext)
}

func (s *ComparisonExprContext) NodeComp() INodeCompContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeCompContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeCompContext)
}

func (s *ComparisonExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterComparisonExpr(s)
	}
}

func (s *ComparisonExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitComparisonExpr(s)
	}
}

func (p *XPath3Parser) ComparisonExpr() (localctx IComparisonExprContext) {
	localctx = NewComparisonExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, XPath3ParserRULE_comparisonExpr)
	p.SetState(340)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(331)
			p.stringConcatExpr(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(332)
			p.stringConcatExpr(0)
		}
		p.SetState(336)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case XPath3ParserT__43, XPath3ParserT__44, XPath3ParserT__45, XPath3ParserT__46, XPath3ParserT__47, XPath3ParserT__48:
			{
				p.SetState(333)
				p.ValueComp()
			}

		case XPath3ParserT__37, XPath3ParserT__38, XPath3ParserT__39, XPath3ParserT__40, XPath3ParserT__41, XPath3ParserT__42:
			{
				p.SetState(334)
				p.GeneralComp()
			}

		case XPath3ParserT__49, XPath3ParserT__50, XPath3ParserT__51:
			{
				p.SetState(335)
				p.NodeComp()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(338)
			p.stringConcatExpr(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringConcatExprContext is an interface to support dynamic dispatch.
type IStringConcatExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RangeExpr() IRangeExprContext
	StringConcatExpr() IStringConcatExprContext

	// IsStringConcatExprContext differentiates from other interfaces.
	IsStringConcatExprContext()
}

type StringConcatExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringConcatExprContext() *StringConcatExprContext {
	var p = new(StringConcatExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_stringConcatExpr
	return p
}

func InitEmptyStringConcatExprContext(p *StringConcatExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_stringConcatExpr
}

func (*StringConcatExprContext) IsStringConcatExprContext() {}

func NewStringConcatExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringConcatExprContext {
	var p = new(StringConcatExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_stringConcatExpr

	return p
}

func (s *StringConcatExprContext) GetParser() antlr.Parser { return s.parser }

func (s *StringConcatExprContext) RangeExpr() IRangeExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRangeExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRangeExprContext)
}

func (s *StringConcatExprContext) StringConcatExpr() IStringConcatExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringConcatExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringConcatExprContext)
}

func (s *StringConcatExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringConcatExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringConcatExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterStringConcatExpr(s)
	}
}

func (s *StringConcatExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitStringConcatExpr(s)
	}
}

func (p *XPath3Parser) StringConcatExpr() (localctx IStringConcatExprContext) {
	return p.stringConcatExpr(0)
}

func (p *XPath3Parser) stringConcatExpr(_p int) (localctx IStringConcatExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewStringConcatExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IStringConcatExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 44
	p.EnterRecursionRule(localctx, 44, XPath3ParserRULE_stringConcatExpr, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(343)
		p.rangeExpr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(350)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 11, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewStringConcatExprContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, XPath3ParserRULE_stringConcatExpr)
			p.SetState(345)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(346)
				p.Match(XPath3ParserT__19)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(347)
				p.rangeExpr(0)
			}

		}
		p.SetState(352)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 11, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRangeExprContext is an interface to support dynamic dispatch.
type IRangeExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AdditiveExpr() IAdditiveExprContext
	RangeExpr() IRangeExprContext

	// IsRangeExprContext differentiates from other interfaces.
	IsRangeExprContext()
}

type RangeExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRangeExprContext() *RangeExprContext {
	var p = new(RangeExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_rangeExpr
	return p
}

func InitEmptyRangeExprContext(p *RangeExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_rangeExpr
}

func (*RangeExprContext) IsRangeExprContext() {}

func NewRangeExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RangeExprContext {
	var p = new(RangeExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_rangeExpr

	return p
}

func (s *RangeExprContext) GetParser() antlr.Parser { return s.parser }

func (s *RangeExprContext) AdditiveExpr() IAdditiveExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdditiveExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdditiveExprContext)
}

func (s *RangeExprContext) RangeExpr() IRangeExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRangeExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRangeExprContext)
}

func (s *RangeExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RangeExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RangeExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterRangeExpr(s)
	}
}

func (s *RangeExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitRangeExpr(s)
	}
}

func (p *XPath3Parser) RangeExpr() (localctx IRangeExprContext) {
	return p.rangeExpr(0)
}

func (p *XPath3Parser) rangeExpr(_p int) (localctx IRangeExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewRangeExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRangeExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 46
	p.EnterRecursionRule(localctx, 46, XPath3ParserRULE_rangeExpr, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(354)
		p.additiveExpr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(361)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewRangeExprContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, XPath3ParserRULE_rangeExpr)
			p.SetState(356)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(357)
				p.Match(XPath3ParserT__20)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(358)
				p.additiveExpr(0)
			}

		}
		p.SetState(363)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdditiveExprContext is an interface to support dynamic dispatch.
type IAdditiveExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MultiplicativeExpr() IMultiplicativeExprContext
	AdditiveExpr() IAdditiveExprContext

	// IsAdditiveExprContext differentiates from other interfaces.
	IsAdditiveExprContext()
}

type AdditiveExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdditiveExprContext() *AdditiveExprContext {
	var p = new(AdditiveExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_additiveExpr
	return p
}

func InitEmptyAdditiveExprContext(p *AdditiveExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_additiveExpr
}

func (*AdditiveExprContext) IsAdditiveExprContext() {}

func NewAdditiveExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdditiveExprContext {
	var p = new(AdditiveExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_additiveExpr

	return p
}

func (s *AdditiveExprContext) GetParser() antlr.Parser { return s.parser }

func (s *AdditiveExprContext) MultiplicativeExpr() IMultiplicativeExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiplicativeExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiplicativeExprContext)
}

func (s *AdditiveExprContext) AdditiveExpr() IAdditiveExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdditiveExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdditiveExprContext)
}

func (s *AdditiveExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditiveExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdditiveExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterAdditiveExpr(s)
	}
}

func (s *AdditiveExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitAdditiveExpr(s)
	}
}

func (p *XPath3Parser) AdditiveExpr() (localctx IAdditiveExprContext) {
	return p.additiveExpr(0)
}

func (p *XPath3Parser) additiveExpr(_p int) (localctx IAdditiveExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewAdditiveExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IAdditiveExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 48
	p.EnterRecursionRule(localctx, 48, XPath3ParserRULE_additiveExpr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(365)
		p.multiplicativeExpr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(372)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewAdditiveExprContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, XPath3ParserRULE_additiveExpr)
			p.SetState(367)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(368)
				_la = p.GetTokenStream().LA(1)

				if !(_la == XPath3ParserT__21 || _la == XPath3ParserT__22) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(369)
				p.multiplicativeExpr(0)
			}

		}
		p.SetState(374)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiplicativeExprContext is an interface to support dynamic dispatch.
type IMultiplicativeExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnionExpr() IUnionExprContext
	MultiplicativeExpr() IMultiplicativeExprContext

	// IsMultiplicativeExprContext differentiates from other interfaces.
	IsMultiplicativeExprContext()
}

type MultiplicativeExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplicativeExprContext() *MultiplicativeExprContext {
	var p = new(MultiplicativeExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_multiplicativeExpr
	return p
}

func InitEmptyMultiplicativeExprContext(p *MultiplicativeExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_multiplicativeExpr
}

func (*MultiplicativeExprContext) IsMultiplicativeExprContext() {}

func NewMultiplicativeExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplicativeExprContext {
	var p = new(MultiplicativeExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_multiplicativeExpr

	return p
}

func (s *MultiplicativeExprContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplicativeExprContext) UnionExpr() IUnionExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnionExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnionExprContext)
}

func (s *MultiplicativeExprContext) MultiplicativeExpr() IMultiplicativeExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiplicativeExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiplicativeExprContext)
}

func (s *MultiplicativeExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplicativeExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplicativeExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterMultiplicativeExpr(s)
	}
}

func (s *MultiplicativeExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitMultiplicativeExpr(s)
	}
}

func (p *XPath3Parser) MultiplicativeExpr() (localctx IMultiplicativeExprContext) {
	return p.multiplicativeExpr(0)
}

func (p *XPath3Parser) multiplicativeExpr(_p int) (localctx IMultiplicativeExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewMultiplicativeExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IMultiplicativeExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 50
	p.EnterRecursionRule(localctx, 50, XPath3ParserRULE_multiplicativeExpr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(376)
		p.unionExpr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(383)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 14, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewMultiplicativeExprContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, XPath3ParserRULE_multiplicativeExpr)
			p.SetState(378)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(379)
				_la = p.GetTokenStream().LA(1)

				if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&251658240) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(380)
				p.unionExpr(0)
			}

		}
		p.SetState(385)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 14, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnionExprContext is an interface to support dynamic dispatch.
type IUnionExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IntersectExceptExpr() IIntersectExceptExprContext
	UnionExpr() IUnionExprContext

	// IsUnionExprContext differentiates from other interfaces.
	IsUnionExprContext()
}

type UnionExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnionExprContext() *UnionExprContext {
	var p = new(UnionExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_unionExpr
	return p
}

func InitEmptyUnionExprContext(p *UnionExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_unionExpr
}

func (*UnionExprContext) IsUnionExprContext() {}

func NewUnionExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionExprContext {
	var p = new(UnionExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_unionExpr

	return p
}

func (s *UnionExprContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionExprContext) IntersectExceptExpr() IIntersectExceptExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntersectExceptExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntersectExceptExprContext)
}

func (s *UnionExprContext) UnionExpr() IUnionExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnionExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnionExprContext)
}

func (s *UnionExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnionExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterUnionExpr(s)
	}
}

func (s *UnionExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitUnionExpr(s)
	}
}

func (p *XPath3Parser) UnionExpr() (localctx IUnionExprContext) {
	return p.unionExpr(0)
}

func (p *XPath3Parser) unionExpr(_p int) (localctx IUnionExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewUnionExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IUnionExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 52
	p.EnterRecursionRule(localctx, 52, XPath3ParserRULE_unionExpr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(387)
		p.intersectExceptExpr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(394)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 15, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewUnionExprContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, XPath3ParserRULE_unionExpr)
			p.SetState(389)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(390)
				_la = p.GetTokenStream().LA(1)

				if !(_la == XPath3ParserT__27 || _la == XPath3ParserT__28) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(391)
				p.intersectExceptExpr(0)
			}

		}
		p.SetState(396)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 15, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntersectExceptExprContext is an interface to support dynamic dispatch.
type IIntersectExceptExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	InstanceofExpr() IInstanceofExprContext
	IntersectExceptExpr() IIntersectExceptExprContext

	// IsIntersectExceptExprContext differentiates from other interfaces.
	IsIntersectExceptExprContext()
}

type IntersectExceptExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntersectExceptExprContext() *IntersectExceptExprContext {
	var p = new(IntersectExceptExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_intersectExceptExpr
	return p
}

func InitEmptyIntersectExceptExprContext(p *IntersectExceptExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_intersectExceptExpr
}

func (*IntersectExceptExprContext) IsIntersectExceptExprContext() {}

func NewIntersectExceptExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntersectExceptExprContext {
	var p = new(IntersectExceptExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_intersectExceptExpr

	return p
}

func (s *IntersectExceptExprContext) GetParser() antlr.Parser { return s.parser }

func (s *IntersectExceptExprContext) InstanceofExpr() IInstanceofExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInstanceofExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInstanceofExprContext)
}

func (s *IntersectExceptExprContext) IntersectExceptExpr() IIntersectExceptExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntersectExceptExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntersectExceptExprContext)
}

func (s *IntersectExceptExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntersectExceptExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntersectExceptExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterIntersectExceptExpr(s)
	}
}

func (s *IntersectExceptExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitIntersectExceptExpr(s)
	}
}

func (p *XPath3Parser) IntersectExceptExpr() (localctx IIntersectExceptExprContext) {
	return p.intersectExceptExpr(0)
}

func (p *XPath3Parser) intersectExceptExpr(_p int) (localctx IIntersectExceptExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewIntersectExceptExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IIntersectExceptExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 54
	p.EnterRecursionRule(localctx, 54, XPath3ParserRULE_intersectExceptExpr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(398)
		p.InstanceofExpr()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(405)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 16, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewIntersectExceptExprContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, XPath3ParserRULE_intersectExceptExpr)
			p.SetState(400)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(401)
				_la = p.GetTokenStream().LA(1)

				if !(_la == XPath3ParserT__29 || _la == XPath3ParserT__30) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(402)
				p.InstanceofExpr()
			}

		}
		p.SetState(407)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 16, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInstanceofExprContext is an interface to support dynamic dispatch.
type IInstanceofExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TreatExpr() ITreatExprContext
	SequenceType() ISequenceTypeContext

	// IsInstanceofExprContext differentiates from other interfaces.
	IsInstanceofExprContext()
}

type InstanceofExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInstanceofExprContext() *InstanceofExprContext {
	var p = new(InstanceofExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_instanceofExpr
	return p
}

func InitEmptyInstanceofExprContext(p *InstanceofExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_instanceofExpr
}

func (*InstanceofExprContext) IsInstanceofExprContext() {}

func NewInstanceofExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InstanceofExprContext {
	var p = new(InstanceofExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_instanceofExpr

	return p
}

func (s *InstanceofExprContext) GetParser() antlr.Parser { return s.parser }

func (s *InstanceofExprContext) TreatExpr() ITreatExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITreatExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITreatExprContext)
}

func (s *InstanceofExprContext) SequenceType() ISequenceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISequenceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISequenceTypeContext)
}

func (s *InstanceofExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstanceofExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InstanceofExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterInstanceofExpr(s)
	}
}

func (s *InstanceofExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitInstanceofExpr(s)
	}
}

func (p *XPath3Parser) InstanceofExpr() (localctx IInstanceofExprContext) {
	localctx = NewInstanceofExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, XPath3ParserRULE_instanceofExpr)
	p.SetState(414)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(408)
			p.TreatExpr()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(409)
			p.TreatExpr()
		}
		{
			p.SetState(410)
			p.Match(XPath3ParserT__31)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(411)
			p.Match(XPath3ParserT__32)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(412)
			p.SequenceType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITreatExprContext is an interface to support dynamic dispatch.
type ITreatExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CastableExpr() ICastableExprContext
	SequenceType() ISequenceTypeContext

	// IsTreatExprContext differentiates from other interfaces.
	IsTreatExprContext()
}

type TreatExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTreatExprContext() *TreatExprContext {
	var p = new(TreatExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_treatExpr
	return p
}

func InitEmptyTreatExprContext(p *TreatExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_treatExpr
}

func (*TreatExprContext) IsTreatExprContext() {}

func NewTreatExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TreatExprContext {
	var p = new(TreatExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_treatExpr

	return p
}

func (s *TreatExprContext) GetParser() antlr.Parser { return s.parser }

func (s *TreatExprContext) CastableExpr() ICastableExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastableExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastableExprContext)
}

func (s *TreatExprContext) SequenceType() ISequenceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISequenceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISequenceTypeContext)
}

func (s *TreatExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TreatExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TreatExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterTreatExpr(s)
	}
}

func (s *TreatExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitTreatExpr(s)
	}
}

func (p *XPath3Parser) TreatExpr() (localctx ITreatExprContext) {
	localctx = NewTreatExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, XPath3ParserRULE_treatExpr)
	p.SetState(422)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 18, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(416)
			p.CastableExpr()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(417)
			p.CastableExpr()
		}
		{
			p.SetState(418)
			p.Match(XPath3ParserT__33)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(419)
			p.Match(XPath3ParserT__34)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(420)
			p.SequenceType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICastableExprContext is an interface to support dynamic dispatch.
type ICastableExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CastExpr() ICastExprContext
	SingleType() ISingleTypeContext

	// IsCastableExprContext differentiates from other interfaces.
	IsCastableExprContext()
}

type CastableExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCastableExprContext() *CastableExprContext {
	var p = new(CastableExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_castableExpr
	return p
}

func InitEmptyCastableExprContext(p *CastableExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_castableExpr
}

func (*CastableExprContext) IsCastableExprContext() {}

func NewCastableExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CastableExprContext {
	var p = new(CastableExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_castableExpr

	return p
}

func (s *CastableExprContext) GetParser() antlr.Parser { return s.parser }

func (s *CastableExprContext) CastExpr() ICastExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastExprContext)
}

func (s *CastableExprContext) SingleType() ISingleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleTypeContext)
}

func (s *CastableExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastableExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CastableExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterCastableExpr(s)
	}
}

func (s *CastableExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitCastableExpr(s)
	}
}

func (p *XPath3Parser) CastableExpr() (localctx ICastableExprContext) {
	localctx = NewCastableExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, XPath3ParserRULE_castableExpr)
	p.SetState(430)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 19, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(424)
			p.CastExpr()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(425)
			p.CastExpr()
		}
		{
			p.SetState(426)
			p.Match(XPath3ParserT__35)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(427)
			p.Match(XPath3ParserT__34)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(428)
			p.SingleType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICastExprContext is an interface to support dynamic dispatch.
type ICastExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnaryExpr() IUnaryExprContext
	SingleType() ISingleTypeContext

	// IsCastExprContext differentiates from other interfaces.
	IsCastExprContext()
}

type CastExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCastExprContext() *CastExprContext {
	var p = new(CastExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_castExpr
	return p
}

func InitEmptyCastExprContext(p *CastExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_castExpr
}

func (*CastExprContext) IsCastExprContext() {}

func NewCastExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CastExprContext {
	var p = new(CastExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_castExpr

	return p
}

func (s *CastExprContext) GetParser() antlr.Parser { return s.parser }

func (s *CastExprContext) UnaryExpr() IUnaryExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryExprContext)
}

func (s *CastExprContext) SingleType() ISingleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleTypeContext)
}

func (s *CastExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CastExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterCastExpr(s)
	}
}

func (s *CastExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitCastExpr(s)
	}
}

func (p *XPath3Parser) CastExpr() (localctx ICastExprContext) {
	localctx = NewCastExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, XPath3ParserRULE_castExpr)
	p.SetState(438)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 20, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(432)
			p.UnaryExpr()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(433)
			p.UnaryExpr()
		}
		{
			p.SetState(434)
			p.Match(XPath3ParserT__36)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(435)
			p.Match(XPath3ParserT__34)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(436)
			p.SingleType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnaryExprContext is an interface to support dynamic dispatch.
type IUnaryExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ValueExpr() IValueExprContext
	UnaryExpr() IUnaryExprContext

	// IsUnaryExprContext differentiates from other interfaces.
	IsUnaryExprContext()
}

type UnaryExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnaryExprContext() *UnaryExprContext {
	var p = new(UnaryExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_unaryExpr
	return p
}

func InitEmptyUnaryExprContext(p *UnaryExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_unaryExpr
}

func (*UnaryExprContext) IsUnaryExprContext() {}

func NewUnaryExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryExprContext {
	var p = new(UnaryExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_unaryExpr

	return p
}

func (s *UnaryExprContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryExprContext) ValueExpr() IValueExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExprContext)
}

func (s *UnaryExprContext) UnaryExpr() IUnaryExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryExprContext)
}

func (s *UnaryExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnaryExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterUnaryExpr(s)
	}
}

func (s *UnaryExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitUnaryExpr(s)
	}
}

func (p *XPath3Parser) UnaryExpr() (localctx IUnaryExprContext) {
	localctx = NewUnaryExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, XPath3ParserRULE_unaryExpr)
	p.SetState(445)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserT__1, XPath3ParserT__13, XPath3ParserT__23, XPath3ParserT__53, XPath3ParserT__54, XPath3ParserT__55, XPath3ParserT__57, XPath3ParserT__58, XPath3ParserT__59, XPath3ParserT__60, XPath3ParserT__61, XPath3ParserT__62, XPath3ParserT__63, XPath3ParserT__64, XPath3ParserT__65, XPath3ParserT__66, XPath3ParserT__67, XPath3ParserT__68, XPath3ParserT__69, XPath3ParserT__70, XPath3ParserT__74, XPath3ParserT__77, XPath3ParserT__80, XPath3ParserT__81, XPath3ParserT__82, XPath3ParserT__83, XPath3ParserT__84, XPath3ParserT__85, XPath3ParserT__86, XPath3ParserT__87, XPath3ParserT__88, XPath3ParserT__89, XPath3ParserT__90, XPath3ParserNumericLiteral, XPath3ParserURIQualifiedName, XPath3ParserBracedURILiteral, XPath3ParserQNAME, XPath3ParserNC_NAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(440)
			p.ValueExpr()
		}

	case XPath3ParserT__22:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(441)
			p.Match(XPath3ParserT__22)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(442)
			p.UnaryExpr()
		}

	case XPath3ParserT__21:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(443)
			p.Match(XPath3ParserT__21)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(444)
			p.UnaryExpr()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValueExprContext is an interface to support dynamic dispatch.
type IValueExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleMapExpr() ISimpleMapExprContext

	// IsValueExprContext differentiates from other interfaces.
	IsValueExprContext()
}

type ValueExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueExprContext() *ValueExprContext {
	var p = new(ValueExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_valueExpr
	return p
}

func InitEmptyValueExprContext(p *ValueExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_valueExpr
}

func (*ValueExprContext) IsValueExprContext() {}

func NewValueExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueExprContext {
	var p = new(ValueExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_valueExpr

	return p
}

func (s *ValueExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueExprContext) SimpleMapExpr() ISimpleMapExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleMapExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleMapExprContext)
}

func (s *ValueExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterValueExpr(s)
	}
}

func (s *ValueExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitValueExpr(s)
	}
}

func (p *XPath3Parser) ValueExpr() (localctx IValueExprContext) {
	localctx = NewValueExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, XPath3ParserRULE_valueExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(447)
		p.SimpleMapExpr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGeneralCompContext is an interface to support dynamic dispatch.
type IGeneralCompContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsGeneralCompContext differentiates from other interfaces.
	IsGeneralCompContext()
}

type GeneralCompContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneralCompContext() *GeneralCompContext {
	var p = new(GeneralCompContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_generalComp
	return p
}

func InitEmptyGeneralCompContext(p *GeneralCompContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_generalComp
}

func (*GeneralCompContext) IsGeneralCompContext() {}

func NewGeneralCompContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GeneralCompContext {
	var p = new(GeneralCompContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_generalComp

	return p
}

func (s *GeneralCompContext) GetParser() antlr.Parser { return s.parser }
func (s *GeneralCompContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneralCompContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GeneralCompContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterGeneralComp(s)
	}
}

func (s *GeneralCompContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitGeneralComp(s)
	}
}

func (p *XPath3Parser) GeneralComp() (localctx IGeneralCompContext) {
	localctx = NewGeneralCompContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, XPath3ParserRULE_generalComp)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(449)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&17317308137472) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValueCompContext is an interface to support dynamic dispatch.
type IValueCompContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsValueCompContext differentiates from other interfaces.
	IsValueCompContext()
}

type ValueCompContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueCompContext() *ValueCompContext {
	var p = new(ValueCompContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_valueComp
	return p
}

func InitEmptyValueCompContext(p *ValueCompContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_valueComp
}

func (*ValueCompContext) IsValueCompContext() {}

func NewValueCompContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueCompContext {
	var p = new(ValueCompContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_valueComp

	return p
}

func (s *ValueCompContext) GetParser() antlr.Parser { return s.parser }
func (s *ValueCompContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueCompContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueCompContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterValueComp(s)
	}
}

func (s *ValueCompContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitValueComp(s)
	}
}

func (p *XPath3Parser) ValueComp() (localctx IValueCompContext) {
	localctx = NewValueCompContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, XPath3ParserRULE_valueComp)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(451)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1108307720798208) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INodeCompContext is an interface to support dynamic dispatch.
type INodeCompContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsNodeCompContext differentiates from other interfaces.
	IsNodeCompContext()
}

type NodeCompContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNodeCompContext() *NodeCompContext {
	var p = new(NodeCompContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_nodeComp
	return p
}

func InitEmptyNodeCompContext(p *NodeCompContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_nodeComp
}

func (*NodeCompContext) IsNodeCompContext() {}

func NewNodeCompContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NodeCompContext {
	var p = new(NodeCompContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_nodeComp

	return p
}

func (s *NodeCompContext) GetParser() antlr.Parser { return s.parser }
func (s *NodeCompContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NodeCompContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NodeCompContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterNodeComp(s)
	}
}

func (s *NodeCompContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitNodeComp(s)
	}
}

func (p *XPath3Parser) NodeComp() (localctx INodeCompContext) {
	localctx = NewNodeCompContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, XPath3ParserRULE_nodeComp)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(453)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&7881299347898368) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleMapExprContext is an interface to support dynamic dispatch.
type ISimpleMapExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPathExpr() []IPathExprContext
	PathExpr(i int) IPathExprContext

	// IsSimpleMapExprContext differentiates from other interfaces.
	IsSimpleMapExprContext()
}

type SimpleMapExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleMapExprContext() *SimpleMapExprContext {
	var p = new(SimpleMapExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_simpleMapExpr
	return p
}

func InitEmptySimpleMapExprContext(p *SimpleMapExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_simpleMapExpr
}

func (*SimpleMapExprContext) IsSimpleMapExprContext() {}

func NewSimpleMapExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleMapExprContext {
	var p = new(SimpleMapExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_simpleMapExpr

	return p
}

func (s *SimpleMapExprContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleMapExprContext) AllPathExpr() []IPathExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPathExprContext); ok {
			len++
		}
	}

	tst := make([]IPathExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPathExprContext); ok {
			tst[i] = t.(IPathExprContext)
			i++
		}
	}

	return tst
}

func (s *SimpleMapExprContext) PathExpr(i int) IPathExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathExprContext)
}

func (s *SimpleMapExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleMapExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleMapExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterSimpleMapExpr(s)
	}
}

func (s *SimpleMapExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitSimpleMapExpr(s)
	}
}

func (p *XPath3Parser) SimpleMapExpr() (localctx ISimpleMapExprContext) {
	localctx = NewSimpleMapExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, XPath3ParserRULE_simpleMapExpr)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(455)
		p.PathExpr()
	}
	p.SetState(460)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 22, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(456)
				p.Match(XPath3ParserT__52)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(457)
				p.PathExpr()
			}

		}
		p.SetState(462)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 22, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPathExprContext is an interface to support dynamic dispatch.
type IPathExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RelativePathExpr() IRelativePathExprContext

	// IsPathExprContext differentiates from other interfaces.
	IsPathExprContext()
}

type PathExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPathExprContext() *PathExprContext {
	var p = new(PathExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_pathExpr
	return p
}

func InitEmptyPathExprContext(p *PathExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_pathExpr
}

func (*PathExprContext) IsPathExprContext() {}

func NewPathExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PathExprContext {
	var p = new(PathExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_pathExpr

	return p
}

func (s *PathExprContext) GetParser() antlr.Parser { return s.parser }

func (s *PathExprContext) RelativePathExpr() IRelativePathExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelativePathExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelativePathExprContext)
}

func (s *PathExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PathExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PathExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterPathExpr(s)
	}
}

func (s *PathExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitPathExpr(s)
	}
}

func (p *XPath3Parser) PathExpr() (localctx IPathExprContext) {
	localctx = NewPathExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, XPath3ParserRULE_pathExpr)
	p.SetState(470)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserT__53:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(463)
			p.Match(XPath3ParserT__53)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(465)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 23, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(464)
				p.RelativePathExpr()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case XPath3ParserT__54:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(467)
			p.Match(XPath3ParserT__54)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(468)
			p.RelativePathExpr()
		}

	case XPath3ParserT__1, XPath3ParserT__13, XPath3ParserT__23, XPath3ParserT__55, XPath3ParserT__57, XPath3ParserT__58, XPath3ParserT__59, XPath3ParserT__60, XPath3ParserT__61, XPath3ParserT__62, XPath3ParserT__63, XPath3ParserT__64, XPath3ParserT__65, XPath3ParserT__66, XPath3ParserT__67, XPath3ParserT__68, XPath3ParserT__69, XPath3ParserT__70, XPath3ParserT__74, XPath3ParserT__77, XPath3ParserT__80, XPath3ParserT__81, XPath3ParserT__82, XPath3ParserT__83, XPath3ParserT__84, XPath3ParserT__85, XPath3ParserT__86, XPath3ParserT__87, XPath3ParserT__88, XPath3ParserT__89, XPath3ParserT__90, XPath3ParserNumericLiteral, XPath3ParserURIQualifiedName, XPath3ParserBracedURILiteral, XPath3ParserQNAME, XPath3ParserNC_NAME:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(469)
			p.RelativePathExpr()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelativePathExprContext is an interface to support dynamic dispatch.
type IRelativePathExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllStepExpr() []IStepExprContext
	StepExpr(i int) IStepExprContext

	// IsRelativePathExprContext differentiates from other interfaces.
	IsRelativePathExprContext()
}

type RelativePathExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelativePathExprContext() *RelativePathExprContext {
	var p = new(RelativePathExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_relativePathExpr
	return p
}

func InitEmptyRelativePathExprContext(p *RelativePathExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_relativePathExpr
}

func (*RelativePathExprContext) IsRelativePathExprContext() {}

func NewRelativePathExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelativePathExprContext {
	var p = new(RelativePathExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_relativePathExpr

	return p
}

func (s *RelativePathExprContext) GetParser() antlr.Parser { return s.parser }

func (s *RelativePathExprContext) AllStepExpr() []IStepExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStepExprContext); ok {
			len++
		}
	}

	tst := make([]IStepExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStepExprContext); ok {
			tst[i] = t.(IStepExprContext)
			i++
		}
	}

	return tst
}

func (s *RelativePathExprContext) StepExpr(i int) IStepExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStepExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStepExprContext)
}

func (s *RelativePathExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelativePathExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelativePathExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterRelativePathExpr(s)
	}
}

func (s *RelativePathExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitRelativePathExpr(s)
	}
}

func (p *XPath3Parser) RelativePathExpr() (localctx IRelativePathExprContext) {
	localctx = NewRelativePathExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, XPath3ParserRULE_relativePathExpr)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(472)
		p.StepExpr()
	}
	p.SetState(477)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(473)
				_la = p.GetTokenStream().LA(1)

				if !(_la == XPath3ParserT__53 || _la == XPath3ParserT__54) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(474)
				p.StepExpr()
			}

		}
		p.SetState(479)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStepExprContext is an interface to support dynamic dispatch.
type IStepExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PostfixExpr() IPostfixExprContext
	AxisStep() IAxisStepContext

	// IsStepExprContext differentiates from other interfaces.
	IsStepExprContext()
}

type StepExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStepExprContext() *StepExprContext {
	var p = new(StepExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_stepExpr
	return p
}

func InitEmptyStepExprContext(p *StepExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_stepExpr
}

func (*StepExprContext) IsStepExprContext() {}

func NewStepExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StepExprContext {
	var p = new(StepExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_stepExpr

	return p
}

func (s *StepExprContext) GetParser() antlr.Parser { return s.parser }

func (s *StepExprContext) PostfixExpr() IPostfixExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixExprContext)
}

func (s *StepExprContext) AxisStep() IAxisStepContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAxisStepContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAxisStepContext)
}

func (s *StepExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StepExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StepExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterStepExpr(s)
	}
}

func (s *StepExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitStepExpr(s)
	}
}

func (p *XPath3Parser) StepExpr() (localctx IStepExprContext) {
	localctx = NewStepExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, XPath3ParserRULE_stepExpr)
	p.SetState(482)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 26, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(480)
			p.PostfixExpr()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(481)
			p.AxisStep()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAxisStepContext is an interface to support dynamic dispatch.
type IAxisStepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PredicateList() IPredicateListContext
	ReverseStep() IReverseStepContext
	ForwardStep() IForwardStepContext

	// IsAxisStepContext differentiates from other interfaces.
	IsAxisStepContext()
}

type AxisStepContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAxisStepContext() *AxisStepContext {
	var p = new(AxisStepContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_axisStep
	return p
}

func InitEmptyAxisStepContext(p *AxisStepContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_axisStep
}

func (*AxisStepContext) IsAxisStepContext() {}

func NewAxisStepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AxisStepContext {
	var p = new(AxisStepContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_axisStep

	return p
}

func (s *AxisStepContext) GetParser() antlr.Parser { return s.parser }

func (s *AxisStepContext) PredicateList() IPredicateListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateListContext)
}

func (s *AxisStepContext) ReverseStep() IReverseStepContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReverseStepContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReverseStepContext)
}

func (s *AxisStepContext) ForwardStep() IForwardStepContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForwardStepContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForwardStepContext)
}

func (s *AxisStepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AxisStepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AxisStepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterAxisStep(s)
	}
}

func (s *AxisStepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitAxisStep(s)
	}
}

func (p *XPath3Parser) AxisStep() (localctx IAxisStepContext) {
	localctx = NewAxisStepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, XPath3ParserRULE_axisStep)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(486)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserT__65, XPath3ParserT__66, XPath3ParserT__67, XPath3ParserT__68, XPath3ParserT__69, XPath3ParserT__70:
		{
			p.SetState(484)
			p.ReverseStep()
		}

	case XPath3ParserT__23, XPath3ParserT__55, XPath3ParserT__57, XPath3ParserT__58, XPath3ParserT__59, XPath3ParserT__60, XPath3ParserT__61, XPath3ParserT__62, XPath3ParserT__63, XPath3ParserT__64, XPath3ParserT__80, XPath3ParserT__81, XPath3ParserT__82, XPath3ParserT__83, XPath3ParserT__84, XPath3ParserT__85, XPath3ParserT__86, XPath3ParserT__87, XPath3ParserT__88, XPath3ParserURIQualifiedName, XPath3ParserBracedURILiteral, XPath3ParserQNAME, XPath3ParserNC_NAME:
		{
			p.SetState(485)
			p.ForwardStep()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(488)
		p.PredicateList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForwardStepContext is an interface to support dynamic dispatch.
type IForwardStepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ForwardAxis() IForwardAxisContext
	NodeTest() INodeTestContext
	AbbrevForwardStep() IAbbrevForwardStepContext

	// IsForwardStepContext differentiates from other interfaces.
	IsForwardStepContext()
}

type ForwardStepContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForwardStepContext() *ForwardStepContext {
	var p = new(ForwardStepContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_forwardStep
	return p
}

func InitEmptyForwardStepContext(p *ForwardStepContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_forwardStep
}

func (*ForwardStepContext) IsForwardStepContext() {}

func NewForwardStepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForwardStepContext {
	var p = new(ForwardStepContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_forwardStep

	return p
}

func (s *ForwardStepContext) GetParser() antlr.Parser { return s.parser }

func (s *ForwardStepContext) ForwardAxis() IForwardAxisContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForwardAxisContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForwardAxisContext)
}

func (s *ForwardStepContext) NodeTest() INodeTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeTestContext)
}

func (s *ForwardStepContext) AbbrevForwardStep() IAbbrevForwardStepContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAbbrevForwardStepContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAbbrevForwardStepContext)
}

func (s *ForwardStepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForwardStepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForwardStepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterForwardStep(s)
	}
}

func (s *ForwardStepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitForwardStep(s)
	}
}

func (p *XPath3Parser) ForwardStep() (localctx IForwardStepContext) {
	localctx = NewForwardStepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, XPath3ParserRULE_forwardStep)
	p.SetState(494)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 28, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(490)
			p.ForwardAxis()
		}
		{
			p.SetState(491)
			p.NodeTest()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(493)
			p.AbbrevForwardStep()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForwardAxisContext is an interface to support dynamic dispatch.
type IForwardAxisContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsForwardAxisContext differentiates from other interfaces.
	IsForwardAxisContext()
}

type ForwardAxisContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForwardAxisContext() *ForwardAxisContext {
	var p = new(ForwardAxisContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_forwardAxis
	return p
}

func InitEmptyForwardAxisContext(p *ForwardAxisContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_forwardAxis
}

func (*ForwardAxisContext) IsForwardAxisContext() {}

func NewForwardAxisContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForwardAxisContext {
	var p = new(ForwardAxisContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_forwardAxis

	return p
}

func (s *ForwardAxisContext) GetParser() antlr.Parser { return s.parser }
func (s *ForwardAxisContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForwardAxisContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForwardAxisContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterForwardAxis(s)
	}
}

func (s *ForwardAxisContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitForwardAxis(s)
	}
}

func (p *XPath3Parser) ForwardAxis() (localctx IForwardAxisContext) {
	localctx = NewForwardAxisContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, XPath3ParserRULE_forwardAxis)
	p.SetState(512)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserT__55:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(496)
			p.Match(XPath3ParserT__55)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(497)
			p.Match(XPath3ParserT__56)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case XPath3ParserT__57:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(498)
			p.Match(XPath3ParserT__57)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(499)
			p.Match(XPath3ParserT__56)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case XPath3ParserT__58:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(500)
			p.Match(XPath3ParserT__58)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(501)
			p.Match(XPath3ParserT__56)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case XPath3ParserT__59:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(502)
			p.Match(XPath3ParserT__59)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(503)
			p.Match(XPath3ParserT__56)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case XPath3ParserT__60:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(504)
			p.Match(XPath3ParserT__60)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(505)
			p.Match(XPath3ParserT__56)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case XPath3ParserT__61:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(506)
			p.Match(XPath3ParserT__61)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(507)
			p.Match(XPath3ParserT__56)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case XPath3ParserT__62:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(508)
			p.Match(XPath3ParserT__62)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(509)
			p.Match(XPath3ParserT__56)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case XPath3ParserT__63:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(510)
			p.Match(XPath3ParserT__63)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(511)
			p.Match(XPath3ParserT__56)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAbbrevForwardStepContext is an interface to support dynamic dispatch.
type IAbbrevForwardStepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NodeTest() INodeTestContext

	// IsAbbrevForwardStepContext differentiates from other interfaces.
	IsAbbrevForwardStepContext()
}

type AbbrevForwardStepContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAbbrevForwardStepContext() *AbbrevForwardStepContext {
	var p = new(AbbrevForwardStepContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_abbrevForwardStep
	return p
}

func InitEmptyAbbrevForwardStepContext(p *AbbrevForwardStepContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_abbrevForwardStep
}

func (*AbbrevForwardStepContext) IsAbbrevForwardStepContext() {}

func NewAbbrevForwardStepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AbbrevForwardStepContext {
	var p = new(AbbrevForwardStepContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_abbrevForwardStep

	return p
}

func (s *AbbrevForwardStepContext) GetParser() antlr.Parser { return s.parser }

func (s *AbbrevForwardStepContext) NodeTest() INodeTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeTestContext)
}

func (s *AbbrevForwardStepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AbbrevForwardStepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AbbrevForwardStepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterAbbrevForwardStep(s)
	}
}

func (s *AbbrevForwardStepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitAbbrevForwardStep(s)
	}
}

func (p *XPath3Parser) AbbrevForwardStep() (localctx IAbbrevForwardStepContext) {
	localctx = NewAbbrevForwardStepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, XPath3ParserRULE_abbrevForwardStep)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(515)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == XPath3ParserT__64 {
		{
			p.SetState(514)
			p.Match(XPath3ParserT__64)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(517)
		p.NodeTest()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReverseStepContext is an interface to support dynamic dispatch.
type IReverseStepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ReverseAxis() IReverseAxisContext
	NodeTest() INodeTestContext
	AbbrevReverseStep() IAbbrevReverseStepContext

	// IsReverseStepContext differentiates from other interfaces.
	IsReverseStepContext()
}

type ReverseStepContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReverseStepContext() *ReverseStepContext {
	var p = new(ReverseStepContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_reverseStep
	return p
}

func InitEmptyReverseStepContext(p *ReverseStepContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_reverseStep
}

func (*ReverseStepContext) IsReverseStepContext() {}

func NewReverseStepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReverseStepContext {
	var p = new(ReverseStepContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_reverseStep

	return p
}

func (s *ReverseStepContext) GetParser() antlr.Parser { return s.parser }

func (s *ReverseStepContext) ReverseAxis() IReverseAxisContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReverseAxisContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReverseAxisContext)
}

func (s *ReverseStepContext) NodeTest() INodeTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeTestContext)
}

func (s *ReverseStepContext) AbbrevReverseStep() IAbbrevReverseStepContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAbbrevReverseStepContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAbbrevReverseStepContext)
}

func (s *ReverseStepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReverseStepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReverseStepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterReverseStep(s)
	}
}

func (s *ReverseStepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitReverseStep(s)
	}
}

func (p *XPath3Parser) ReverseStep() (localctx IReverseStepContext) {
	localctx = NewReverseStepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, XPath3ParserRULE_reverseStep)
	p.SetState(523)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserT__65, XPath3ParserT__66, XPath3ParserT__67, XPath3ParserT__68, XPath3ParserT__69:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(519)
			p.ReverseAxis()
		}
		{
			p.SetState(520)
			p.NodeTest()
		}

	case XPath3ParserT__70:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(522)
			p.AbbrevReverseStep()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReverseAxisContext is an interface to support dynamic dispatch.
type IReverseAxisContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsReverseAxisContext differentiates from other interfaces.
	IsReverseAxisContext()
}

type ReverseAxisContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReverseAxisContext() *ReverseAxisContext {
	var p = new(ReverseAxisContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_reverseAxis
	return p
}

func InitEmptyReverseAxisContext(p *ReverseAxisContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_reverseAxis
}

func (*ReverseAxisContext) IsReverseAxisContext() {}

func NewReverseAxisContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReverseAxisContext {
	var p = new(ReverseAxisContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_reverseAxis

	return p
}

func (s *ReverseAxisContext) GetParser() antlr.Parser { return s.parser }
func (s *ReverseAxisContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReverseAxisContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReverseAxisContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterReverseAxis(s)
	}
}

func (s *ReverseAxisContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitReverseAxis(s)
	}
}

func (p *XPath3Parser) ReverseAxis() (localctx IReverseAxisContext) {
	localctx = NewReverseAxisContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, XPath3ParserRULE_reverseAxis)
	p.SetState(535)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserT__65:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(525)
			p.Match(XPath3ParserT__65)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(526)
			p.Match(XPath3ParserT__56)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case XPath3ParserT__66:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(527)
			p.Match(XPath3ParserT__66)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(528)
			p.Match(XPath3ParserT__56)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case XPath3ParserT__67:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(529)
			p.Match(XPath3ParserT__67)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(530)
			p.Match(XPath3ParserT__56)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case XPath3ParserT__68:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(531)
			p.Match(XPath3ParserT__68)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(532)
			p.Match(XPath3ParserT__56)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case XPath3ParserT__69:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(533)
			p.Match(XPath3ParserT__69)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(534)
			p.Match(XPath3ParserT__56)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAbbrevReverseStepContext is an interface to support dynamic dispatch.
type IAbbrevReverseStepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAbbrevReverseStepContext differentiates from other interfaces.
	IsAbbrevReverseStepContext()
}

type AbbrevReverseStepContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAbbrevReverseStepContext() *AbbrevReverseStepContext {
	var p = new(AbbrevReverseStepContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_abbrevReverseStep
	return p
}

func InitEmptyAbbrevReverseStepContext(p *AbbrevReverseStepContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_abbrevReverseStep
}

func (*AbbrevReverseStepContext) IsAbbrevReverseStepContext() {}

func NewAbbrevReverseStepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AbbrevReverseStepContext {
	var p = new(AbbrevReverseStepContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_abbrevReverseStep

	return p
}

func (s *AbbrevReverseStepContext) GetParser() antlr.Parser { return s.parser }
func (s *AbbrevReverseStepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AbbrevReverseStepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AbbrevReverseStepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterAbbrevReverseStep(s)
	}
}

func (s *AbbrevReverseStepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitAbbrevReverseStep(s)
	}
}

func (p *XPath3Parser) AbbrevReverseStep() (localctx IAbbrevReverseStepContext) {
	localctx = NewAbbrevReverseStepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, XPath3ParserRULE_abbrevReverseStep)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(537)
		p.Match(XPath3ParserT__70)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INodeTestContext is an interface to support dynamic dispatch.
type INodeTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KindTest() IKindTestContext
	NameTest() INameTestContext

	// IsNodeTestContext differentiates from other interfaces.
	IsNodeTestContext()
}

type NodeTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNodeTestContext() *NodeTestContext {
	var p = new(NodeTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_nodeTest
	return p
}

func InitEmptyNodeTestContext(p *NodeTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_nodeTest
}

func (*NodeTestContext) IsNodeTestContext() {}

func NewNodeTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NodeTestContext {
	var p = new(NodeTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_nodeTest

	return p
}

func (s *NodeTestContext) GetParser() antlr.Parser { return s.parser }

func (s *NodeTestContext) KindTest() IKindTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKindTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKindTestContext)
}

func (s *NodeTestContext) NameTest() INameTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameTestContext)
}

func (s *NodeTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NodeTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NodeTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterNodeTest(s)
	}
}

func (s *NodeTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitNodeTest(s)
	}
}

func (p *XPath3Parser) NodeTest() (localctx INodeTestContext) {
	localctx = NewNodeTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, XPath3ParserRULE_nodeTest)
	p.SetState(541)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserT__58, XPath3ParserT__80, XPath3ParserT__81, XPath3ParserT__82, XPath3ParserT__83, XPath3ParserT__84, XPath3ParserT__85, XPath3ParserT__86, XPath3ParserT__87, XPath3ParserT__88:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(539)
			p.KindTest()
		}

	case XPath3ParserT__23, XPath3ParserURIQualifiedName, XPath3ParserBracedURILiteral, XPath3ParserQNAME, XPath3ParserNC_NAME:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(540)
			p.NameTest()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INameTestContext is an interface to support dynamic dispatch.
type INameTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EqName() IEqNameContext
	WildCard() IWildCardContext

	// IsNameTestContext differentiates from other interfaces.
	IsNameTestContext()
}

type NameTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNameTestContext() *NameTestContext {
	var p = new(NameTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_nameTest
	return p
}

func InitEmptyNameTestContext(p *NameTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_nameTest
}

func (*NameTestContext) IsNameTestContext() {}

func NewNameTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NameTestContext {
	var p = new(NameTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_nameTest

	return p
}

func (s *NameTestContext) GetParser() antlr.Parser { return s.parser }

func (s *NameTestContext) EqName() IEqNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqNameContext)
}

func (s *NameTestContext) WildCard() IWildCardContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildCardContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildCardContext)
}

func (s *NameTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NameTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NameTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterNameTest(s)
	}
}

func (s *NameTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitNameTest(s)
	}
}

func (p *XPath3Parser) NameTest() (localctx INameTestContext) {
	localctx = NewNameTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, XPath3ParserRULE_nameTest)
	p.SetState(545)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserURIQualifiedName, XPath3ParserQNAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(543)
			p.EqName()
		}

	case XPath3ParserT__23, XPath3ParserBracedURILiteral, XPath3ParserNC_NAME:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(544)
			p.WildCard()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWildCardContext is an interface to support dynamic dispatch.
type IWildCardContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NC_NAME() antlr.TerminalNode
	BracedURILiteral() antlr.TerminalNode

	// IsWildCardContext differentiates from other interfaces.
	IsWildCardContext()
}

type WildCardContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWildCardContext() *WildCardContext {
	var p = new(WildCardContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_wildCard
	return p
}

func InitEmptyWildCardContext(p *WildCardContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_wildCard
}

func (*WildCardContext) IsWildCardContext() {}

func NewWildCardContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WildCardContext {
	var p = new(WildCardContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_wildCard

	return p
}

func (s *WildCardContext) GetParser() antlr.Parser { return s.parser }

func (s *WildCardContext) NC_NAME() antlr.TerminalNode {
	return s.GetToken(XPath3ParserNC_NAME, 0)
}

func (s *WildCardContext) BracedURILiteral() antlr.TerminalNode {
	return s.GetToken(XPath3ParserBracedURILiteral, 0)
}

func (s *WildCardContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WildCardContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WildCardContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterWildCard(s)
	}
}

func (s *WildCardContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitWildCard(s)
	}
}

func (p *XPath3Parser) WildCard() (localctx IWildCardContext) {
	localctx = NewWildCardContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, XPath3ParserRULE_wildCard)
	p.SetState(556)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 35, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(547)
			p.Match(XPath3ParserT__23)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(548)
			p.Match(XPath3ParserNC_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(549)
			p.Match(XPath3ParserT__71)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(550)
			p.Match(XPath3ParserT__23)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(551)
			p.Match(XPath3ParserT__23)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(552)
			p.Match(XPath3ParserT__71)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(553)
			p.Match(XPath3ParserNC_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(554)
			p.Match(XPath3ParserBracedURILiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(555)
			p.Match(XPath3ParserT__23)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPostfixExprContext is an interface to support dynamic dispatch.
type IPostfixExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrimaryExpr() IPrimaryExprContext
	AllPredicate() []IPredicateContext
	Predicate(i int) IPredicateContext
	AllArgumentList() []IArgumentListContext
	ArgumentList(i int) IArgumentListContext

	// IsPostfixExprContext differentiates from other interfaces.
	IsPostfixExprContext()
}

type PostfixExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostfixExprContext() *PostfixExprContext {
	var p = new(PostfixExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_postfixExpr
	return p
}

func InitEmptyPostfixExprContext(p *PostfixExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_postfixExpr
}

func (*PostfixExprContext) IsPostfixExprContext() {}

func NewPostfixExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixExprContext {
	var p = new(PostfixExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_postfixExpr

	return p
}

func (s *PostfixExprContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixExprContext) PrimaryExpr() IPrimaryExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExprContext)
}

func (s *PostfixExprContext) AllPredicate() []IPredicateContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPredicateContext); ok {
			len++
		}
	}

	tst := make([]IPredicateContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPredicateContext); ok {
			tst[i] = t.(IPredicateContext)
			i++
		}
	}

	return tst
}

func (s *PostfixExprContext) Predicate(i int) IPredicateContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *PostfixExprContext) AllArgumentList() []IArgumentListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArgumentListContext); ok {
			len++
		}
	}

	tst := make([]IArgumentListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArgumentListContext); ok {
			tst[i] = t.(IArgumentListContext)
			i++
		}
	}

	return tst
}

func (s *PostfixExprContext) ArgumentList(i int) IArgumentListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *PostfixExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostfixExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterPostfixExpr(s)
	}
}

func (s *PostfixExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitPostfixExpr(s)
	}
}

func (p *XPath3Parser) PostfixExpr() (localctx IPostfixExprContext) {
	localctx = NewPostfixExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, XPath3ParserRULE_postfixExpr)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(558)
		p.PrimaryExpr()
	}
	p.SetState(563)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 37, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(561)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case XPath3ParserT__72:
				{
					p.SetState(559)
					p.Predicate()
				}

			case XPath3ParserT__13:
				{
					p.SetState(560)
					p.ArgumentList()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(565)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 37, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgumentListContext is an interface to support dynamic dispatch.
type IArgumentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllArgument() []IArgumentContext
	Argument(i int) IArgumentContext

	// IsArgumentListContext differentiates from other interfaces.
	IsArgumentListContext()
}

type ArgumentListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentListContext() *ArgumentListContext {
	var p = new(ArgumentListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_argumentList
	return p
}

func InitEmptyArgumentListContext(p *ArgumentListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_argumentList
}

func (*ArgumentListContext) IsArgumentListContext() {}

func NewArgumentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentListContext {
	var p = new(ArgumentListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_argumentList

	return p
}

func (s *ArgumentListContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentListContext) AllArgument() []IArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArgumentContext); ok {
			len++
		}
	}

	tst := make([]IArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArgumentContext); ok {
			tst[i] = t.(IArgumentContext)
			i++
		}
	}

	return tst
}

func (s *ArgumentListContext) Argument(i int) IArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentContext)
}

func (s *ArgumentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterArgumentList(s)
	}
}

func (s *ArgumentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitArgumentList(s)
	}
}

func (p *XPath3Parser) ArgumentList() (localctx IArgumentListContext) {
	localctx = NewArgumentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, XPath3ParserRULE_argumentList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(566)
		p.Match(XPath3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(575)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-162129586555949756) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&9157407037695) != 0) {
		{
			p.SetState(567)
			p.Argument()
		}
		p.SetState(572)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == XPath3ParserT__0 {
			{
				p.SetState(568)
				p.Match(XPath3ParserT__0)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(569)
				p.Argument()
			}

			p.SetState(574)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(577)
		p.Match(XPath3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPredicateListContext is an interface to support dynamic dispatch.
type IPredicateListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPredicate() []IPredicateContext
	Predicate(i int) IPredicateContext

	// IsPredicateListContext differentiates from other interfaces.
	IsPredicateListContext()
}

type PredicateListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPredicateListContext() *PredicateListContext {
	var p = new(PredicateListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_predicateList
	return p
}

func InitEmptyPredicateListContext(p *PredicateListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_predicateList
}

func (*PredicateListContext) IsPredicateListContext() {}

func NewPredicateListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredicateListContext {
	var p = new(PredicateListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_predicateList

	return p
}

func (s *PredicateListContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateListContext) AllPredicate() []IPredicateContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPredicateContext); ok {
			len++
		}
	}

	tst := make([]IPredicateContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPredicateContext); ok {
			tst[i] = t.(IPredicateContext)
			i++
		}
	}

	return tst
}

func (s *PredicateListContext) Predicate(i int) IPredicateContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *PredicateListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PredicateListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterPredicateList(s)
	}
}

func (s *PredicateListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitPredicateList(s)
	}
}

func (p *XPath3Parser) PredicateList() (localctx IPredicateListContext) {
	localctx = NewPredicateListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, XPath3ParserRULE_predicateList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(582)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 40, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(579)
				p.Predicate()
			}

		}
		p.SetState(584)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 40, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPredicateContext is an interface to support dynamic dispatch.
type IPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext

	// IsPredicateContext differentiates from other interfaces.
	IsPredicateContext()
}

type PredicateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPredicateContext() *PredicateContext {
	var p = new(PredicateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_predicate
	return p
}

func InitEmptyPredicateContext(p *PredicateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_predicate
}

func (*PredicateContext) IsPredicateContext() {}

func NewPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredicateContext {
	var p = new(PredicateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_predicate

	return p
}

func (s *PredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *PredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterPredicate(s)
	}
}

func (s *PredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitPredicate(s)
	}
}

func (p *XPath3Parser) Predicate() (localctx IPredicateContext) {
	localctx = NewPredicateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, XPath3ParserRULE_predicate)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(585)
		p.Match(XPath3ParserT__72)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(586)
		p.Expr()
	}
	{
		p.SetState(587)
		p.Match(XPath3ParserT__73)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimaryExprContext is an interface to support dynamic dispatch.
type IPrimaryExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Literal() ILiteralContext
	VarRef() IVarRefContext
	ParenthesizedExpr() IParenthesizedExprContext
	ContextItemExpr() IContextItemExprContext
	FunctionCall() IFunctionCallContext
	FunctionItemExpr() IFunctionItemExprContext

	// IsPrimaryExprContext differentiates from other interfaces.
	IsPrimaryExprContext()
}

type PrimaryExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryExprContext() *PrimaryExprContext {
	var p = new(PrimaryExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_primaryExpr
	return p
}

func InitEmptyPrimaryExprContext(p *PrimaryExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_primaryExpr
}

func (*PrimaryExprContext) IsPrimaryExprContext() {}

func NewPrimaryExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExprContext {
	var p = new(PrimaryExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_primaryExpr

	return p
}

func (s *PrimaryExprContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExprContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *PrimaryExprContext) VarRef() IVarRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarRefContext)
}

func (s *PrimaryExprContext) ParenthesizedExpr() IParenthesizedExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesizedExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesizedExprContext)
}

func (s *PrimaryExprContext) ContextItemExpr() IContextItemExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContextItemExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContextItemExprContext)
}

func (s *PrimaryExprContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *PrimaryExprContext) FunctionItemExpr() IFunctionItemExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionItemExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionItemExprContext)
}

func (s *PrimaryExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterPrimaryExpr(s)
	}
}

func (s *PrimaryExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitPrimaryExpr(s)
	}
}

func (p *XPath3Parser) PrimaryExpr() (localctx IPrimaryExprContext) {
	localctx = NewPrimaryExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, XPath3ParserRULE_primaryExpr)
	p.SetState(595)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 41, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(589)
			p.Literal()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(590)
			p.VarRef()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(591)
			p.ParenthesizedExpr()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(592)
			p.ContextItemExpr()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(593)
			p.FunctionCall()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(594)
			p.FunctionItemExpr()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVarRefContext is an interface to support dynamic dispatch.
type IVarRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VarName() IVarNameContext

	// IsVarRefContext differentiates from other interfaces.
	IsVarRefContext()
}

type VarRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarRefContext() *VarRefContext {
	var p = new(VarRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_varRef
	return p
}

func InitEmptyVarRefContext(p *VarRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_varRef
}

func (*VarRefContext) IsVarRefContext() {}

func NewVarRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarRefContext {
	var p = new(VarRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_varRef

	return p
}

func (s *VarRefContext) GetParser() antlr.Parser { return s.parser }

func (s *VarRefContext) VarName() IVarNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarNameContext)
}

func (s *VarRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterVarRef(s)
	}
}

func (s *VarRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitVarRef(s)
	}
}

func (p *XPath3Parser) VarRef() (localctx IVarRefContext) {
	localctx = NewVarRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, XPath3ParserRULE_varRef)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(597)
		p.Match(XPath3ParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(598)
		p.VarName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVarNameContext is an interface to support dynamic dispatch.
type IVarNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EqName() IEqNameContext

	// IsVarNameContext differentiates from other interfaces.
	IsVarNameContext()
}

type VarNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarNameContext() *VarNameContext {
	var p = new(VarNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_varName
	return p
}

func InitEmptyVarNameContext(p *VarNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_varName
}

func (*VarNameContext) IsVarNameContext() {}

func NewVarNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarNameContext {
	var p = new(VarNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_varName

	return p
}

func (s *VarNameContext) GetParser() antlr.Parser { return s.parser }

func (s *VarNameContext) EqName() IEqNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqNameContext)
}

func (s *VarNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterVarName(s)
	}
}

func (s *VarNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitVarName(s)
	}
}

func (p *XPath3Parser) VarName() (localctx IVarNameContext) {
	localctx = NewVarNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, XPath3ParserRULE_varName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(600)
		p.EqName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NumericLiteral() antlr.TerminalNode
	StringLiteral() IStringLiteralContext

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_literal
	return p
}

func InitEmptyLiteralContext(p *LiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_literal
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) NumericLiteral() antlr.TerminalNode {
	return s.GetToken(XPath3ParserNumericLiteral, 0)
}

func (s *LiteralContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (p *XPath3Parser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, XPath3ParserRULE_literal)
	p.SetState(604)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserNumericLiteral:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(602)
			p.Match(XPath3ParserNumericLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case XPath3ParserT__89, XPath3ParserT__90:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(603)
			p.StringLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParenthesizedExprContext is an interface to support dynamic dispatch.
type IParenthesizedExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext

	// IsParenthesizedExprContext differentiates from other interfaces.
	IsParenthesizedExprContext()
}

type ParenthesizedExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParenthesizedExprContext() *ParenthesizedExprContext {
	var p = new(ParenthesizedExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_parenthesizedExpr
	return p
}

func InitEmptyParenthesizedExprContext(p *ParenthesizedExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_parenthesizedExpr
}

func (*ParenthesizedExprContext) IsParenthesizedExprContext() {}

func NewParenthesizedExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParenthesizedExprContext {
	var p = new(ParenthesizedExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_parenthesizedExpr

	return p
}

func (s *ParenthesizedExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ParenthesizedExprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ParenthesizedExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParenthesizedExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterParenthesizedExpr(s)
	}
}

func (s *ParenthesizedExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitParenthesizedExpr(s)
	}
}

func (p *XPath3Parser) ParenthesizedExpr() (localctx IParenthesizedExprContext) {
	localctx = NewParenthesizedExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, XPath3ParserRULE_parenthesizedExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(606)
		p.Match(XPath3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(608)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-162129586555949756) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&9157407033599) != 0) {
		{
			p.SetState(607)
			p.Expr()
		}

	}
	{
		p.SetState(610)
		p.Match(XPath3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IContextItemExprContext is an interface to support dynamic dispatch.
type IContextItemExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsContextItemExprContext differentiates from other interfaces.
	IsContextItemExprContext()
}

type ContextItemExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContextItemExprContext() *ContextItemExprContext {
	var p = new(ContextItemExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_contextItemExpr
	return p
}

func InitEmptyContextItemExprContext(p *ContextItemExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_contextItemExpr
}

func (*ContextItemExprContext) IsContextItemExprContext() {}

func NewContextItemExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContextItemExprContext {
	var p = new(ContextItemExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_contextItemExpr

	return p
}

func (s *ContextItemExprContext) GetParser() antlr.Parser { return s.parser }
func (s *ContextItemExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContextItemExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContextItemExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterContextItemExpr(s)
	}
}

func (s *ContextItemExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitContextItemExpr(s)
	}
}

func (p *XPath3Parser) ContextItemExpr() (localctx IContextItemExprContext) {
	localctx = NewContextItemExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, XPath3ParserRULE_contextItemExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(612)
		p.Match(XPath3ParserT__74)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionCallContext is an interface to support dynamic dispatch.
type IFunctionCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EqName() IEqNameContext
	ArgumentList() IArgumentListContext

	// IsFunctionCallContext differentiates from other interfaces.
	IsFunctionCallContext()
}

type FunctionCallContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionCallContext() *FunctionCallContext {
	var p = new(FunctionCallContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_functionCall
	return p
}

func InitEmptyFunctionCallContext(p *FunctionCallContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_functionCall
}

func (*FunctionCallContext) IsFunctionCallContext() {}

func NewFunctionCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallContext {
	var p = new(FunctionCallContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_functionCall

	return p
}

func (s *FunctionCallContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallContext) EqName() IEqNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqNameContext)
}

func (s *FunctionCallContext) ArgumentList() IArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterFunctionCall(s)
	}
}

func (s *FunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitFunctionCall(s)
	}
}

func (p *XPath3Parser) FunctionCall() (localctx IFunctionCallContext) {
	localctx = NewFunctionCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, XPath3ParserRULE_functionCall)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(614)
		p.EqName()
	}
	{
		p.SetState(615)
		p.ArgumentList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgumentContext is an interface to support dynamic dispatch.
type IArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExprSingle() IExprSingleContext
	ArgumentPlaceholder() IArgumentPlaceholderContext

	// IsArgumentContext differentiates from other interfaces.
	IsArgumentContext()
}

type ArgumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentContext() *ArgumentContext {
	var p = new(ArgumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_argument
	return p
}

func InitEmptyArgumentContext(p *ArgumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_argument
}

func (*ArgumentContext) IsArgumentContext() {}

func NewArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentContext {
	var p = new(ArgumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_argument

	return p
}

func (s *ArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentContext) ExprSingle() IExprSingleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprSingleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprSingleContext)
}

func (s *ArgumentContext) ArgumentPlaceholder() IArgumentPlaceholderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentPlaceholderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentPlaceholderContext)
}

func (s *ArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterArgument(s)
	}
}

func (s *ArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitArgument(s)
	}
}

func (p *XPath3Parser) Argument() (localctx IArgumentContext) {
	localctx = NewArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, XPath3ParserRULE_argument)
	p.SetState(619)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserT__1, XPath3ParserT__5, XPath3ParserT__7, XPath3ParserT__9, XPath3ParserT__10, XPath3ParserT__12, XPath3ParserT__13, XPath3ParserT__21, XPath3ParserT__22, XPath3ParserT__23, XPath3ParserT__53, XPath3ParserT__54, XPath3ParserT__55, XPath3ParserT__57, XPath3ParserT__58, XPath3ParserT__59, XPath3ParserT__60, XPath3ParserT__61, XPath3ParserT__62, XPath3ParserT__63, XPath3ParserT__64, XPath3ParserT__65, XPath3ParserT__66, XPath3ParserT__67, XPath3ParserT__68, XPath3ParserT__69, XPath3ParserT__70, XPath3ParserT__74, XPath3ParserT__77, XPath3ParserT__80, XPath3ParserT__81, XPath3ParserT__82, XPath3ParserT__83, XPath3ParserT__84, XPath3ParserT__85, XPath3ParserT__86, XPath3ParserT__87, XPath3ParserT__88, XPath3ParserT__89, XPath3ParserT__90, XPath3ParserNumericLiteral, XPath3ParserURIQualifiedName, XPath3ParserBracedURILiteral, XPath3ParserQNAME, XPath3ParserNC_NAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(617)
			p.ExprSingle()
		}

	case XPath3ParserT__75:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(618)
			p.ArgumentPlaceholder()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgumentPlaceholderContext is an interface to support dynamic dispatch.
type IArgumentPlaceholderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsArgumentPlaceholderContext differentiates from other interfaces.
	IsArgumentPlaceholderContext()
}

type ArgumentPlaceholderContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentPlaceholderContext() *ArgumentPlaceholderContext {
	var p = new(ArgumentPlaceholderContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_argumentPlaceholder
	return p
}

func InitEmptyArgumentPlaceholderContext(p *ArgumentPlaceholderContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_argumentPlaceholder
}

func (*ArgumentPlaceholderContext) IsArgumentPlaceholderContext() {}

func NewArgumentPlaceholderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentPlaceholderContext {
	var p = new(ArgumentPlaceholderContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_argumentPlaceholder

	return p
}

func (s *ArgumentPlaceholderContext) GetParser() antlr.Parser { return s.parser }
func (s *ArgumentPlaceholderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentPlaceholderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentPlaceholderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterArgumentPlaceholder(s)
	}
}

func (s *ArgumentPlaceholderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitArgumentPlaceholder(s)
	}
}

func (p *XPath3Parser) ArgumentPlaceholder() (localctx IArgumentPlaceholderContext) {
	localctx = NewArgumentPlaceholderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, XPath3ParserRULE_argumentPlaceholder)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(621)
		p.Match(XPath3ParserT__75)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionItemExprContext is an interface to support dynamic dispatch.
type IFunctionItemExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NamedFunctionRef() INamedFunctionRefContext
	InlineFunctionExpr() IInlineFunctionExprContext

	// IsFunctionItemExprContext differentiates from other interfaces.
	IsFunctionItemExprContext()
}

type FunctionItemExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionItemExprContext() *FunctionItemExprContext {
	var p = new(FunctionItemExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_functionItemExpr
	return p
}

func InitEmptyFunctionItemExprContext(p *FunctionItemExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_functionItemExpr
}

func (*FunctionItemExprContext) IsFunctionItemExprContext() {}

func NewFunctionItemExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionItemExprContext {
	var p = new(FunctionItemExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_functionItemExpr

	return p
}

func (s *FunctionItemExprContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionItemExprContext) NamedFunctionRef() INamedFunctionRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedFunctionRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedFunctionRefContext)
}

func (s *FunctionItemExprContext) InlineFunctionExpr() IInlineFunctionExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInlineFunctionExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInlineFunctionExprContext)
}

func (s *FunctionItemExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionItemExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionItemExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterFunctionItemExpr(s)
	}
}

func (s *FunctionItemExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitFunctionItemExpr(s)
	}
}

func (p *XPath3Parser) FunctionItemExpr() (localctx IFunctionItemExprContext) {
	localctx = NewFunctionItemExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, XPath3ParserRULE_functionItemExpr)
	p.SetState(625)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserURIQualifiedName, XPath3ParserQNAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(623)
			p.NamedFunctionRef()
		}

	case XPath3ParserT__77:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(624)
			p.InlineFunctionExpr()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedFunctionRefContext is an interface to support dynamic dispatch.
type INamedFunctionRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EqName() IEqNameContext
	IntegerLiteral() antlr.TerminalNode

	// IsNamedFunctionRefContext differentiates from other interfaces.
	IsNamedFunctionRefContext()
}

type NamedFunctionRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedFunctionRefContext() *NamedFunctionRefContext {
	var p = new(NamedFunctionRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_namedFunctionRef
	return p
}

func InitEmptyNamedFunctionRefContext(p *NamedFunctionRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_namedFunctionRef
}

func (*NamedFunctionRefContext) IsNamedFunctionRefContext() {}

func NewNamedFunctionRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedFunctionRefContext {
	var p = new(NamedFunctionRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_namedFunctionRef

	return p
}

func (s *NamedFunctionRefContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedFunctionRefContext) EqName() IEqNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqNameContext)
}

func (s *NamedFunctionRefContext) IntegerLiteral() antlr.TerminalNode {
	return s.GetToken(XPath3ParserIntegerLiteral, 0)
}

func (s *NamedFunctionRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedFunctionRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedFunctionRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterNamedFunctionRef(s)
	}
}

func (s *NamedFunctionRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitNamedFunctionRef(s)
	}
}

func (p *XPath3Parser) NamedFunctionRef() (localctx INamedFunctionRefContext) {
	localctx = NewNamedFunctionRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, XPath3ParserRULE_namedFunctionRef)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(627)
		p.EqName()
	}
	{
		p.SetState(628)
		p.Match(XPath3ParserT__76)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(629)
		p.Match(XPath3ParserIntegerLiteral)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInlineFunctionExprContext is an interface to support dynamic dispatch.
type IInlineFunctionExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionBody() IFunctionBodyContext
	ParamList() IParamListContext
	SequenceType() ISequenceTypeContext

	// IsInlineFunctionExprContext differentiates from other interfaces.
	IsInlineFunctionExprContext()
}

type InlineFunctionExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInlineFunctionExprContext() *InlineFunctionExprContext {
	var p = new(InlineFunctionExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_inlineFunctionExpr
	return p
}

func InitEmptyInlineFunctionExprContext(p *InlineFunctionExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_inlineFunctionExpr
}

func (*InlineFunctionExprContext) IsInlineFunctionExprContext() {}

func NewInlineFunctionExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InlineFunctionExprContext {
	var p = new(InlineFunctionExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_inlineFunctionExpr

	return p
}

func (s *InlineFunctionExprContext) GetParser() antlr.Parser { return s.parser }

func (s *InlineFunctionExprContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *InlineFunctionExprContext) ParamList() IParamListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParamListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParamListContext)
}

func (s *InlineFunctionExprContext) SequenceType() ISequenceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISequenceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISequenceTypeContext)
}

func (s *InlineFunctionExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlineFunctionExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InlineFunctionExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterInlineFunctionExpr(s)
	}
}

func (s *InlineFunctionExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitInlineFunctionExpr(s)
	}
}

func (p *XPath3Parser) InlineFunctionExpr() (localctx IInlineFunctionExprContext) {
	localctx = NewInlineFunctionExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, XPath3ParserRULE_inlineFunctionExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(631)
		p.Match(XPath3ParserT__77)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(632)
		p.Match(XPath3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(634)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == XPath3ParserT__1 {
		{
			p.SetState(633)
			p.ParamList()
		}

	}
	{
		p.SetState(636)
		p.Match(XPath3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(639)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == XPath3ParserT__34 {
		{
			p.SetState(637)
			p.Match(XPath3ParserT__34)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(638)
			p.SequenceType()
		}

	}
	{
		p.SetState(641)
		p.FunctionBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleTypeContext is an interface to support dynamic dispatch.
type ISingleTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleTypeName() ISimpleTypeNameContext

	// IsSingleTypeContext differentiates from other interfaces.
	IsSingleTypeContext()
}

type SingleTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleTypeContext() *SingleTypeContext {
	var p = new(SingleTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_singleType
	return p
}

func InitEmptySingleTypeContext(p *SingleTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_singleType
}

func (*SingleTypeContext) IsSingleTypeContext() {}

func NewSingleTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleTypeContext {
	var p = new(SingleTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_singleType

	return p
}

func (s *SingleTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleTypeContext) SimpleTypeName() ISimpleTypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleTypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleTypeNameContext)
}

func (s *SingleTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterSingleType(s)
	}
}

func (s *SingleTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitSingleType(s)
	}
}

func (p *XPath3Parser) SingleType() (localctx ISingleTypeContext) {
	localctx = NewSingleTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, XPath3ParserRULE_singleType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(643)
		p.SimpleTypeName()
	}
	p.SetState(645)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 48, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(644)
			p.Match(XPath3ParserT__75)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IType_declarationContext is an interface to support dynamic dispatch.
type IType_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SequenceType() ISequenceTypeContext

	// IsType_declarationContext differentiates from other interfaces.
	IsType_declarationContext()
}

type Type_declarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_declarationContext() *Type_declarationContext {
	var p = new(Type_declarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_type_declaration
	return p
}

func InitEmptyType_declarationContext(p *Type_declarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_type_declaration
}

func (*Type_declarationContext) IsType_declarationContext() {}

func NewType_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_declarationContext {
	var p = new(Type_declarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_type_declaration

	return p
}

func (s *Type_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_declarationContext) SequenceType() ISequenceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISequenceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISequenceTypeContext)
}

func (s *Type_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterType_declaration(s)
	}
}

func (s *Type_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitType_declaration(s)
	}
}

func (p *XPath3Parser) Type_declaration() (localctx IType_declarationContext) {
	localctx = NewType_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, XPath3ParserRULE_type_declaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(647)
		p.Match(XPath3ParserT__34)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(648)
		p.SequenceType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISequenceTypeContext is an interface to support dynamic dispatch.
type ISequenceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ItemType() IItemTypeContext
	OccurenceIndicator() IOccurenceIndicatorContext

	// IsSequenceTypeContext differentiates from other interfaces.
	IsSequenceTypeContext()
}

type SequenceTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequenceTypeContext() *SequenceTypeContext {
	var p = new(SequenceTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_sequenceType
	return p
}

func InitEmptySequenceTypeContext(p *SequenceTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_sequenceType
}

func (*SequenceTypeContext) IsSequenceTypeContext() {}

func NewSequenceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SequenceTypeContext {
	var p = new(SequenceTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_sequenceType

	return p
}

func (s *SequenceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SequenceTypeContext) ItemType() IItemTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IItemTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IItemTypeContext)
}

func (s *SequenceTypeContext) OccurenceIndicator() IOccurenceIndicatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOccurenceIndicatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOccurenceIndicatorContext)
}

func (s *SequenceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SequenceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SequenceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterSequenceType(s)
	}
}

func (s *SequenceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitSequenceType(s)
	}
}

func (p *XPath3Parser) SequenceType() (localctx ISequenceTypeContext) {
	localctx = NewSequenceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, XPath3ParserRULE_sequenceType)
	p.SetState(657)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserT__78:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(650)
			p.Match(XPath3ParserT__78)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(651)
			p.Match(XPath3ParserT__13)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(652)
			p.Match(XPath3ParserT__14)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case XPath3ParserT__13, XPath3ParserT__58, XPath3ParserT__77, XPath3ParserT__79, XPath3ParserT__80, XPath3ParserT__81, XPath3ParserT__82, XPath3ParserT__83, XPath3ParserT__84, XPath3ParserT__85, XPath3ParserT__86, XPath3ParserT__87, XPath3ParserT__88, XPath3ParserURIQualifiedName, XPath3ParserQNAME:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(653)
			p.ItemType()
		}
		p.SetState(655)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 49, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(654)
				p.OccurenceIndicator()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOccurenceIndicatorContext is an interface to support dynamic dispatch.
type IOccurenceIndicatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsOccurenceIndicatorContext differentiates from other interfaces.
	IsOccurenceIndicatorContext()
}

type OccurenceIndicatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOccurenceIndicatorContext() *OccurenceIndicatorContext {
	var p = new(OccurenceIndicatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_occurenceIndicator
	return p
}

func InitEmptyOccurenceIndicatorContext(p *OccurenceIndicatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_occurenceIndicator
}

func (*OccurenceIndicatorContext) IsOccurenceIndicatorContext() {}

func NewOccurenceIndicatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OccurenceIndicatorContext {
	var p = new(OccurenceIndicatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_occurenceIndicator

	return p
}

func (s *OccurenceIndicatorContext) GetParser() antlr.Parser { return s.parser }
func (s *OccurenceIndicatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OccurenceIndicatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OccurenceIndicatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterOccurenceIndicator(s)
	}
}

func (s *OccurenceIndicatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitOccurenceIndicator(s)
	}
}

func (p *XPath3Parser) OccurenceIndicator() (localctx IOccurenceIndicatorContext) {
	localctx = NewOccurenceIndicatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, XPath3ParserRULE_occurenceIndicator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(659)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-22)) & ^0x3f) == 0 && ((int64(1)<<(_la-22))&18014398509481989) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IItemTypeContext is an interface to support dynamic dispatch.
type IItemTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KindTest() IKindTestContext
	FunctionTest() IFunctionTestContext
	AtomicOrUnionType() IAtomicOrUnionTypeContext
	ParenthesizedItemType() IParenthesizedItemTypeContext

	// IsItemTypeContext differentiates from other interfaces.
	IsItemTypeContext()
}

type ItemTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyItemTypeContext() *ItemTypeContext {
	var p = new(ItemTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_itemType
	return p
}

func InitEmptyItemTypeContext(p *ItemTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_itemType
}

func (*ItemTypeContext) IsItemTypeContext() {}

func NewItemTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ItemTypeContext {
	var p = new(ItemTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_itemType

	return p
}

func (s *ItemTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ItemTypeContext) KindTest() IKindTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKindTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKindTestContext)
}

func (s *ItemTypeContext) FunctionTest() IFunctionTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionTestContext)
}

func (s *ItemTypeContext) AtomicOrUnionType() IAtomicOrUnionTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAtomicOrUnionTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAtomicOrUnionTypeContext)
}

func (s *ItemTypeContext) ParenthesizedItemType() IParenthesizedItemTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesizedItemTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesizedItemTypeContext)
}

func (s *ItemTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ItemTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ItemTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterItemType(s)
	}
}

func (s *ItemTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitItemType(s)
	}
}

func (p *XPath3Parser) ItemType() (localctx IItemTypeContext) {
	localctx = NewItemTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, XPath3ParserRULE_itemType)
	p.SetState(668)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserT__58, XPath3ParserT__80, XPath3ParserT__81, XPath3ParserT__82, XPath3ParserT__83, XPath3ParserT__84, XPath3ParserT__85, XPath3ParserT__86, XPath3ParserT__87, XPath3ParserT__88:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(661)
			p.KindTest()
		}

	case XPath3ParserT__79:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(662)
			p.Match(XPath3ParserT__79)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(663)
			p.Match(XPath3ParserT__13)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(664)
			p.Match(XPath3ParserT__14)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case XPath3ParserT__77:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(665)
			p.FunctionTest()
		}

	case XPath3ParserURIQualifiedName, XPath3ParserQNAME:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(666)
			p.AtomicOrUnionType()
		}

	case XPath3ParserT__13:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(667)
			p.ParenthesizedItemType()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAtomicOrUnionTypeContext is an interface to support dynamic dispatch.
type IAtomicOrUnionTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EqName() IEqNameContext

	// IsAtomicOrUnionTypeContext differentiates from other interfaces.
	IsAtomicOrUnionTypeContext()
}

type AtomicOrUnionTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomicOrUnionTypeContext() *AtomicOrUnionTypeContext {
	var p = new(AtomicOrUnionTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_atomicOrUnionType
	return p
}

func InitEmptyAtomicOrUnionTypeContext(p *AtomicOrUnionTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_atomicOrUnionType
}

func (*AtomicOrUnionTypeContext) IsAtomicOrUnionTypeContext() {}

func NewAtomicOrUnionTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomicOrUnionTypeContext {
	var p = new(AtomicOrUnionTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_atomicOrUnionType

	return p
}

func (s *AtomicOrUnionTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomicOrUnionTypeContext) EqName() IEqNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqNameContext)
}

func (s *AtomicOrUnionTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomicOrUnionTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomicOrUnionTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterAtomicOrUnionType(s)
	}
}

func (s *AtomicOrUnionTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitAtomicOrUnionType(s)
	}
}

func (p *XPath3Parser) AtomicOrUnionType() (localctx IAtomicOrUnionTypeContext) {
	localctx = NewAtomicOrUnionTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, XPath3ParserRULE_atomicOrUnionType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(670)
		p.EqName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKindTestContext is an interface to support dynamic dispatch.
type IKindTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DocumentTest() IDocumentTestContext
	ElementTest() IElementTestContext
	AttributeTest() IAttributeTestContext
	SchemaElementTest() ISchemaElementTestContext
	SchemaAttributeTest() ISchemaAttributeTestContext
	PiTest() IPiTestContext
	CommentTest() ICommentTestContext
	TextTest() ITextTestContext
	NamespaceNodeTest() INamespaceNodeTestContext
	AnyKindTest() IAnyKindTestContext

	// IsKindTestContext differentiates from other interfaces.
	IsKindTestContext()
}

type KindTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKindTestContext() *KindTestContext {
	var p = new(KindTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_kindTest
	return p
}

func InitEmptyKindTestContext(p *KindTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_kindTest
}

func (*KindTestContext) IsKindTestContext() {}

func NewKindTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KindTestContext {
	var p = new(KindTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_kindTest

	return p
}

func (s *KindTestContext) GetParser() antlr.Parser { return s.parser }

func (s *KindTestContext) DocumentTest() IDocumentTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDocumentTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDocumentTestContext)
}

func (s *KindTestContext) ElementTest() IElementTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementTestContext)
}

func (s *KindTestContext) AttributeTest() IAttributeTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeTestContext)
}

func (s *KindTestContext) SchemaElementTest() ISchemaElementTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISchemaElementTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISchemaElementTestContext)
}

func (s *KindTestContext) SchemaAttributeTest() ISchemaAttributeTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISchemaAttributeTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISchemaAttributeTestContext)
}

func (s *KindTestContext) PiTest() IPiTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPiTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPiTestContext)
}

func (s *KindTestContext) CommentTest() ICommentTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentTestContext)
}

func (s *KindTestContext) TextTest() ITextTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextTestContext)
}

func (s *KindTestContext) NamespaceNodeTest() INamespaceNodeTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceNodeTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceNodeTestContext)
}

func (s *KindTestContext) AnyKindTest() IAnyKindTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnyKindTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnyKindTestContext)
}

func (s *KindTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KindTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KindTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterKindTest(s)
	}
}

func (s *KindTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitKindTest(s)
	}
}

func (p *XPath3Parser) KindTest() (localctx IKindTestContext) {
	localctx = NewKindTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, XPath3ParserRULE_kindTest)
	p.SetState(682)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserT__81:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(672)
			p.DocumentTest()
		}

	case XPath3ParserT__87:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(673)
			p.ElementTest()
		}

	case XPath3ParserT__58:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(674)
			p.AttributeTest()
		}

	case XPath3ParserT__88:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(675)
			p.SchemaElementTest()
		}

	case XPath3ParserT__86:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(676)
			p.SchemaAttributeTest()
		}

	case XPath3ParserT__85:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(677)
			p.PiTest()
		}

	case XPath3ParserT__83:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(678)
			p.CommentTest()
		}

	case XPath3ParserT__82:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(679)
			p.TextTest()
		}

	case XPath3ParserT__84:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(680)
			p.NamespaceNodeTest()
		}

	case XPath3ParserT__80:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(681)
			p.AnyKindTest()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnyKindTestContext is an interface to support dynamic dispatch.
type IAnyKindTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAnyKindTestContext differentiates from other interfaces.
	IsAnyKindTestContext()
}

type AnyKindTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnyKindTestContext() *AnyKindTestContext {
	var p = new(AnyKindTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_anyKindTest
	return p
}

func InitEmptyAnyKindTestContext(p *AnyKindTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_anyKindTest
}

func (*AnyKindTestContext) IsAnyKindTestContext() {}

func NewAnyKindTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnyKindTestContext {
	var p = new(AnyKindTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_anyKindTest

	return p
}

func (s *AnyKindTestContext) GetParser() antlr.Parser { return s.parser }
func (s *AnyKindTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnyKindTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnyKindTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterAnyKindTest(s)
	}
}

func (s *AnyKindTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitAnyKindTest(s)
	}
}

func (p *XPath3Parser) AnyKindTest() (localctx IAnyKindTestContext) {
	localctx = NewAnyKindTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, XPath3ParserRULE_anyKindTest)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(684)
		p.Match(XPath3ParserT__80)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(685)
		p.Match(XPath3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(686)
		p.Match(XPath3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDocumentTestContext is an interface to support dynamic dispatch.
type IDocumentTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ElementTest() IElementTestContext
	SchemaElementTest() ISchemaElementTestContext

	// IsDocumentTestContext differentiates from other interfaces.
	IsDocumentTestContext()
}

type DocumentTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDocumentTestContext() *DocumentTestContext {
	var p = new(DocumentTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_documentTest
	return p
}

func InitEmptyDocumentTestContext(p *DocumentTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_documentTest
}

func (*DocumentTestContext) IsDocumentTestContext() {}

func NewDocumentTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DocumentTestContext {
	var p = new(DocumentTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_documentTest

	return p
}

func (s *DocumentTestContext) GetParser() antlr.Parser { return s.parser }

func (s *DocumentTestContext) ElementTest() IElementTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementTestContext)
}

func (s *DocumentTestContext) SchemaElementTest() ISchemaElementTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISchemaElementTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISchemaElementTestContext)
}

func (s *DocumentTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DocumentTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DocumentTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterDocumentTest(s)
	}
}

func (s *DocumentTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitDocumentTest(s)
	}
}

func (p *XPath3Parser) DocumentTest() (localctx IDocumentTestContext) {
	localctx = NewDocumentTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, XPath3ParserRULE_documentTest)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(688)
		p.Match(XPath3ParserT__81)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(689)
		p.Match(XPath3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(692)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case XPath3ParserT__87:
		{
			p.SetState(690)
			p.ElementTest()
		}

	case XPath3ParserT__88:
		{
			p.SetState(691)
			p.SchemaElementTest()
		}

	case XPath3ParserT__14:

	default:
	}
	{
		p.SetState(694)
		p.Match(XPath3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITextTestContext is an interface to support dynamic dispatch.
type ITextTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTextTestContext differentiates from other interfaces.
	IsTextTestContext()
}

type TextTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTextTestContext() *TextTestContext {
	var p = new(TextTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_textTest
	return p
}

func InitEmptyTextTestContext(p *TextTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_textTest
}

func (*TextTestContext) IsTextTestContext() {}

func NewTextTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TextTestContext {
	var p = new(TextTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_textTest

	return p
}

func (s *TextTestContext) GetParser() antlr.Parser { return s.parser }
func (s *TextTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TextTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TextTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterTextTest(s)
	}
}

func (s *TextTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitTextTest(s)
	}
}

func (p *XPath3Parser) TextTest() (localctx ITextTestContext) {
	localctx = NewTextTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, XPath3ParserRULE_textTest)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(696)
		p.Match(XPath3ParserT__82)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(697)
		p.Match(XPath3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(698)
		p.Match(XPath3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommentTestContext is an interface to support dynamic dispatch.
type ICommentTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsCommentTestContext differentiates from other interfaces.
	IsCommentTestContext()
}

type CommentTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommentTestContext() *CommentTestContext {
	var p = new(CommentTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_commentTest
	return p
}

func InitEmptyCommentTestContext(p *CommentTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_commentTest
}

func (*CommentTestContext) IsCommentTestContext() {}

func NewCommentTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommentTestContext {
	var p = new(CommentTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_commentTest

	return p
}

func (s *CommentTestContext) GetParser() antlr.Parser { return s.parser }
func (s *CommentTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommentTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterCommentTest(s)
	}
}

func (s *CommentTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitCommentTest(s)
	}
}

func (p *XPath3Parser) CommentTest() (localctx ICommentTestContext) {
	localctx = NewCommentTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, XPath3ParserRULE_commentTest)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(700)
		p.Match(XPath3ParserT__83)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(701)
		p.Match(XPath3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(702)
		p.Match(XPath3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamespaceNodeTestContext is an interface to support dynamic dispatch.
type INamespaceNodeTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsNamespaceNodeTestContext differentiates from other interfaces.
	IsNamespaceNodeTestContext()
}

type NamespaceNodeTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamespaceNodeTestContext() *NamespaceNodeTestContext {
	var p = new(NamespaceNodeTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_namespaceNodeTest
	return p
}

func InitEmptyNamespaceNodeTestContext(p *NamespaceNodeTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_namespaceNodeTest
}

func (*NamespaceNodeTestContext) IsNamespaceNodeTestContext() {}

func NewNamespaceNodeTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamespaceNodeTestContext {
	var p = new(NamespaceNodeTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_namespaceNodeTest

	return p
}

func (s *NamespaceNodeTestContext) GetParser() antlr.Parser { return s.parser }
func (s *NamespaceNodeTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamespaceNodeTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamespaceNodeTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterNamespaceNodeTest(s)
	}
}

func (s *NamespaceNodeTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitNamespaceNodeTest(s)
	}
}

func (p *XPath3Parser) NamespaceNodeTest() (localctx INamespaceNodeTestContext) {
	localctx = NewNamespaceNodeTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, XPath3ParserRULE_namespaceNodeTest)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(704)
		p.Match(XPath3ParserT__84)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(705)
		p.Match(XPath3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(706)
		p.Match(XPath3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPiTestContext is an interface to support dynamic dispatch.
type IPiTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NC_NAME() antlr.TerminalNode
	StringLiteral() IStringLiteralContext

	// IsPiTestContext differentiates from other interfaces.
	IsPiTestContext()
}

type PiTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPiTestContext() *PiTestContext {
	var p = new(PiTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_piTest
	return p
}

func InitEmptyPiTestContext(p *PiTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_piTest
}

func (*PiTestContext) IsPiTestContext() {}

func NewPiTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PiTestContext {
	var p = new(PiTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_piTest

	return p
}

func (s *PiTestContext) GetParser() antlr.Parser { return s.parser }

func (s *PiTestContext) NC_NAME() antlr.TerminalNode {
	return s.GetToken(XPath3ParserNC_NAME, 0)
}

func (s *PiTestContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *PiTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PiTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PiTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterPiTest(s)
	}
}

func (s *PiTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitPiTest(s)
	}
}

func (p *XPath3Parser) PiTest() (localctx IPiTestContext) {
	localctx = NewPiTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, XPath3ParserRULE_piTest)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(708)
		p.Match(XPath3ParserT__85)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(709)
		p.Match(XPath3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(712)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case XPath3ParserNC_NAME:
		{
			p.SetState(710)
			p.Match(XPath3ParserNC_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case XPath3ParserT__89, XPath3ParserT__90:
		{
			p.SetState(711)
			p.StringLiteral()
		}

	case XPath3ParserT__14:

	default:
	}
	{
		p.SetState(714)
		p.Match(XPath3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeTestContext is an interface to support dynamic dispatch.
type IAttributeTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AttribNameOrWildcard() IAttribNameOrWildcardContext
	TypeName() ITypeNameContext

	// IsAttributeTestContext differentiates from other interfaces.
	IsAttributeTestContext()
}

type AttributeTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeTestContext() *AttributeTestContext {
	var p = new(AttributeTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_attributeTest
	return p
}

func InitEmptyAttributeTestContext(p *AttributeTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_attributeTest
}

func (*AttributeTestContext) IsAttributeTestContext() {}

func NewAttributeTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeTestContext {
	var p = new(AttributeTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_attributeTest

	return p
}

func (s *AttributeTestContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeTestContext) AttribNameOrWildcard() IAttribNameOrWildcardContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttribNameOrWildcardContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttribNameOrWildcardContext)
}

func (s *AttributeTestContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *AttributeTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterAttributeTest(s)
	}
}

func (s *AttributeTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitAttributeTest(s)
	}
}

func (p *XPath3Parser) AttributeTest() (localctx IAttributeTestContext) {
	localctx = NewAttributeTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, XPath3ParserRULE_attributeTest)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(716)
		p.Match(XPath3ParserT__58)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(717)
		p.Match(XPath3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(723)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == XPath3ParserT__23 || _la == XPath3ParserURIQualifiedName || _la == XPath3ParserQNAME {
		{
			p.SetState(718)
			p.AttribNameOrWildcard()
		}
		p.SetState(721)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == XPath3ParserT__0 {
			{
				p.SetState(719)
				p.Match(XPath3ParserT__0)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(720)
				p.TypeName()
			}

		}

	}
	{
		p.SetState(725)
		p.Match(XPath3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttribNameOrWildcardContext is an interface to support dynamic dispatch.
type IAttribNameOrWildcardContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AttributeName() IAttributeNameContext

	// IsAttribNameOrWildcardContext differentiates from other interfaces.
	IsAttribNameOrWildcardContext()
}

type AttribNameOrWildcardContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttribNameOrWildcardContext() *AttribNameOrWildcardContext {
	var p = new(AttribNameOrWildcardContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_attribNameOrWildcard
	return p
}

func InitEmptyAttribNameOrWildcardContext(p *AttribNameOrWildcardContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_attribNameOrWildcard
}

func (*AttribNameOrWildcardContext) IsAttribNameOrWildcardContext() {}

func NewAttribNameOrWildcardContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttribNameOrWildcardContext {
	var p = new(AttribNameOrWildcardContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_attribNameOrWildcard

	return p
}

func (s *AttribNameOrWildcardContext) GetParser() antlr.Parser { return s.parser }

func (s *AttribNameOrWildcardContext) AttributeName() IAttributeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeNameContext)
}

func (s *AttribNameOrWildcardContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttribNameOrWildcardContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttribNameOrWildcardContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterAttribNameOrWildcard(s)
	}
}

func (s *AttribNameOrWildcardContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitAttribNameOrWildcard(s)
	}
}

func (p *XPath3Parser) AttribNameOrWildcard() (localctx IAttribNameOrWildcardContext) {
	localctx = NewAttribNameOrWildcardContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, XPath3ParserRULE_attribNameOrWildcard)
	p.SetState(729)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserURIQualifiedName, XPath3ParserQNAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(727)
			p.AttributeName()
		}

	case XPath3ParserT__23:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(728)
			p.Match(XPath3ParserT__23)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISchemaAttributeTestContext is an interface to support dynamic dispatch.
type ISchemaAttributeTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AttributeDeclaration() IAttributeDeclarationContext

	// IsSchemaAttributeTestContext differentiates from other interfaces.
	IsSchemaAttributeTestContext()
}

type SchemaAttributeTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySchemaAttributeTestContext() *SchemaAttributeTestContext {
	var p = new(SchemaAttributeTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_schemaAttributeTest
	return p
}

func InitEmptySchemaAttributeTestContext(p *SchemaAttributeTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_schemaAttributeTest
}

func (*SchemaAttributeTestContext) IsSchemaAttributeTestContext() {}

func NewSchemaAttributeTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SchemaAttributeTestContext {
	var p = new(SchemaAttributeTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_schemaAttributeTest

	return p
}

func (s *SchemaAttributeTestContext) GetParser() antlr.Parser { return s.parser }

func (s *SchemaAttributeTestContext) AttributeDeclaration() IAttributeDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeDeclarationContext)
}

func (s *SchemaAttributeTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SchemaAttributeTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SchemaAttributeTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterSchemaAttributeTest(s)
	}
}

func (s *SchemaAttributeTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitSchemaAttributeTest(s)
	}
}

func (p *XPath3Parser) SchemaAttributeTest() (localctx ISchemaAttributeTestContext) {
	localctx = NewSchemaAttributeTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, XPath3ParserRULE_schemaAttributeTest)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(731)
		p.Match(XPath3ParserT__86)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(732)
		p.Match(XPath3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(733)
		p.AttributeDeclaration()
	}
	{
		p.SetState(734)
		p.Match(XPath3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeDeclarationContext is an interface to support dynamic dispatch.
type IAttributeDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AttributeName() IAttributeNameContext

	// IsAttributeDeclarationContext differentiates from other interfaces.
	IsAttributeDeclarationContext()
}

type AttributeDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeDeclarationContext() *AttributeDeclarationContext {
	var p = new(AttributeDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_attributeDeclaration
	return p
}

func InitEmptyAttributeDeclarationContext(p *AttributeDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_attributeDeclaration
}

func (*AttributeDeclarationContext) IsAttributeDeclarationContext() {}

func NewAttributeDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeDeclarationContext {
	var p = new(AttributeDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_attributeDeclaration

	return p
}

func (s *AttributeDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeDeclarationContext) AttributeName() IAttributeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeNameContext)
}

func (s *AttributeDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterAttributeDeclaration(s)
	}
}

func (s *AttributeDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitAttributeDeclaration(s)
	}
}

func (p *XPath3Parser) AttributeDeclaration() (localctx IAttributeDeclarationContext) {
	localctx = NewAttributeDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, XPath3ParserRULE_attributeDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(736)
		p.AttributeName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementTestContext is an interface to support dynamic dispatch.
type IElementTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ElementNameOrWildcard() IElementNameOrWildcardContext
	TypeName() ITypeNameContext

	// IsElementTestContext differentiates from other interfaces.
	IsElementTestContext()
}

type ElementTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementTestContext() *ElementTestContext {
	var p = new(ElementTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_elementTest
	return p
}

func InitEmptyElementTestContext(p *ElementTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_elementTest
}

func (*ElementTestContext) IsElementTestContext() {}

func NewElementTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementTestContext {
	var p = new(ElementTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_elementTest

	return p
}

func (s *ElementTestContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementTestContext) ElementNameOrWildcard() IElementNameOrWildcardContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementNameOrWildcardContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementNameOrWildcardContext)
}

func (s *ElementTestContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *ElementTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterElementTest(s)
	}
}

func (s *ElementTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitElementTest(s)
	}
}

func (p *XPath3Parser) ElementTest() (localctx IElementTestContext) {
	localctx = NewElementTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, XPath3ParserRULE_elementTest)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(738)
		p.Match(XPath3ParserT__87)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(739)
		p.Match(XPath3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(748)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == XPath3ParserT__23 || _la == XPath3ParserURIQualifiedName || _la == XPath3ParserQNAME {
		{
			p.SetState(740)
			p.ElementNameOrWildcard()
		}
		p.SetState(746)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == XPath3ParserT__0 {
			{
				p.SetState(741)
				p.Match(XPath3ParserT__0)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(742)
				p.TypeName()
			}
			p.SetState(744)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == XPath3ParserT__75 {
				{
					p.SetState(743)
					p.Match(XPath3ParserT__75)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		}

	}
	{
		p.SetState(750)
		p.Match(XPath3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementNameOrWildcardContext is an interface to support dynamic dispatch.
type IElementNameOrWildcardContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ElementName() IElementNameContext

	// IsElementNameOrWildcardContext differentiates from other interfaces.
	IsElementNameOrWildcardContext()
}

type ElementNameOrWildcardContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementNameOrWildcardContext() *ElementNameOrWildcardContext {
	var p = new(ElementNameOrWildcardContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_elementNameOrWildcard
	return p
}

func InitEmptyElementNameOrWildcardContext(p *ElementNameOrWildcardContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_elementNameOrWildcard
}

func (*ElementNameOrWildcardContext) IsElementNameOrWildcardContext() {}

func NewElementNameOrWildcardContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementNameOrWildcardContext {
	var p = new(ElementNameOrWildcardContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_elementNameOrWildcard

	return p
}

func (s *ElementNameOrWildcardContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementNameOrWildcardContext) ElementName() IElementNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementNameContext)
}

func (s *ElementNameOrWildcardContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementNameOrWildcardContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementNameOrWildcardContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterElementNameOrWildcard(s)
	}
}

func (s *ElementNameOrWildcardContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitElementNameOrWildcard(s)
	}
}

func (p *XPath3Parser) ElementNameOrWildcard() (localctx IElementNameOrWildcardContext) {
	localctx = NewElementNameOrWildcardContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, XPath3ParserRULE_elementNameOrWildcard)
	p.SetState(754)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserURIQualifiedName, XPath3ParserQNAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(752)
			p.ElementName()
		}

	case XPath3ParserT__23:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(753)
			p.Match(XPath3ParserT__23)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISchemaElementTestContext is an interface to support dynamic dispatch.
type ISchemaElementTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ElementDeclaration() IElementDeclarationContext

	// IsSchemaElementTestContext differentiates from other interfaces.
	IsSchemaElementTestContext()
}

type SchemaElementTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySchemaElementTestContext() *SchemaElementTestContext {
	var p = new(SchemaElementTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_schemaElementTest
	return p
}

func InitEmptySchemaElementTestContext(p *SchemaElementTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_schemaElementTest
}

func (*SchemaElementTestContext) IsSchemaElementTestContext() {}

func NewSchemaElementTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SchemaElementTestContext {
	var p = new(SchemaElementTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_schemaElementTest

	return p
}

func (s *SchemaElementTestContext) GetParser() antlr.Parser { return s.parser }

func (s *SchemaElementTestContext) ElementDeclaration() IElementDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementDeclarationContext)
}

func (s *SchemaElementTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SchemaElementTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SchemaElementTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterSchemaElementTest(s)
	}
}

func (s *SchemaElementTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitSchemaElementTest(s)
	}
}

func (p *XPath3Parser) SchemaElementTest() (localctx ISchemaElementTestContext) {
	localctx = NewSchemaElementTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, XPath3ParserRULE_schemaElementTest)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(756)
		p.Match(XPath3ParserT__88)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(757)
		p.Match(XPath3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(758)
		p.ElementDeclaration()
	}
	{
		p.SetState(759)
		p.Match(XPath3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementDeclarationContext is an interface to support dynamic dispatch.
type IElementDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ElementName() IElementNameContext

	// IsElementDeclarationContext differentiates from other interfaces.
	IsElementDeclarationContext()
}

type ElementDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementDeclarationContext() *ElementDeclarationContext {
	var p = new(ElementDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_elementDeclaration
	return p
}

func InitEmptyElementDeclarationContext(p *ElementDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_elementDeclaration
}

func (*ElementDeclarationContext) IsElementDeclarationContext() {}

func NewElementDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementDeclarationContext {
	var p = new(ElementDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_elementDeclaration

	return p
}

func (s *ElementDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementDeclarationContext) ElementName() IElementNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementNameContext)
}

func (s *ElementDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterElementDeclaration(s)
	}
}

func (s *ElementDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitElementDeclaration(s)
	}
}

func (p *XPath3Parser) ElementDeclaration() (localctx IElementDeclarationContext) {
	localctx = NewElementDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, XPath3ParserRULE_elementDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(761)
		p.ElementName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeNameContext is an interface to support dynamic dispatch.
type IAttributeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EqName() IEqNameContext

	// IsAttributeNameContext differentiates from other interfaces.
	IsAttributeNameContext()
}

type AttributeNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeNameContext() *AttributeNameContext {
	var p = new(AttributeNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_attributeName
	return p
}

func InitEmptyAttributeNameContext(p *AttributeNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_attributeName
}

func (*AttributeNameContext) IsAttributeNameContext() {}

func NewAttributeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeNameContext {
	var p = new(AttributeNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_attributeName

	return p
}

func (s *AttributeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeNameContext) EqName() IEqNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqNameContext)
}

func (s *AttributeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterAttributeName(s)
	}
}

func (s *AttributeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitAttributeName(s)
	}
}

func (p *XPath3Parser) AttributeName() (localctx IAttributeNameContext) {
	localctx = NewAttributeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, XPath3ParserRULE_attributeName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(763)
		p.EqName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementNameContext is an interface to support dynamic dispatch.
type IElementNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EqName() IEqNameContext

	// IsElementNameContext differentiates from other interfaces.
	IsElementNameContext()
}

type ElementNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementNameContext() *ElementNameContext {
	var p = new(ElementNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_elementName
	return p
}

func InitEmptyElementNameContext(p *ElementNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_elementName
}

func (*ElementNameContext) IsElementNameContext() {}

func NewElementNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementNameContext {
	var p = new(ElementNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_elementName

	return p
}

func (s *ElementNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementNameContext) EqName() IEqNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqNameContext)
}

func (s *ElementNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterElementName(s)
	}
}

func (s *ElementNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitElementName(s)
	}
}

func (p *XPath3Parser) ElementName() (localctx IElementNameContext) {
	localctx = NewElementNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, XPath3ParserRULE_elementName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(765)
		p.EqName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleTypeNameContext is an interface to support dynamic dispatch.
type ISimpleTypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeName() ITypeNameContext

	// IsSimpleTypeNameContext differentiates from other interfaces.
	IsSimpleTypeNameContext()
}

type SimpleTypeNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleTypeNameContext() *SimpleTypeNameContext {
	var p = new(SimpleTypeNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_simpleTypeName
	return p
}

func InitEmptySimpleTypeNameContext(p *SimpleTypeNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_simpleTypeName
}

func (*SimpleTypeNameContext) IsSimpleTypeNameContext() {}

func NewSimpleTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleTypeNameContext {
	var p = new(SimpleTypeNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_simpleTypeName

	return p
}

func (s *SimpleTypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleTypeNameContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *SimpleTypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleTypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleTypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterSimpleTypeName(s)
	}
}

func (s *SimpleTypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitSimpleTypeName(s)
	}
}

func (p *XPath3Parser) SimpleTypeName() (localctx ISimpleTypeNameContext) {
	localctx = NewSimpleTypeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, XPath3ParserRULE_simpleTypeName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(767)
		p.TypeName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeNameContext is an interface to support dynamic dispatch.
type ITypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QNAME() antlr.TerminalNode

	// IsTypeNameContext differentiates from other interfaces.
	IsTypeNameContext()
}

type TypeNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeNameContext() *TypeNameContext {
	var p = new(TypeNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_typeName
	return p
}

func InitEmptyTypeNameContext(p *TypeNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_typeName
}

func (*TypeNameContext) IsTypeNameContext() {}

func NewTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeNameContext {
	var p = new(TypeNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_typeName

	return p
}

func (s *TypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeNameContext) QNAME() antlr.TerminalNode {
	return s.GetToken(XPath3ParserQNAME, 0)
}

func (s *TypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterTypeName(s)
	}
}

func (s *TypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitTypeName(s)
	}
}

func (p *XPath3Parser) TypeName() (localctx ITypeNameContext) {
	localctx = NewTypeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, XPath3ParserRULE_typeName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(769)
		p.Match(XPath3ParserQNAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionTestContext is an interface to support dynamic dispatch.
type IFunctionTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AnyFunctionTest() IAnyFunctionTestContext
	TypedFunctionTest() ITypedFunctionTestContext

	// IsFunctionTestContext differentiates from other interfaces.
	IsFunctionTestContext()
}

type FunctionTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionTestContext() *FunctionTestContext {
	var p = new(FunctionTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_functionTest
	return p
}

func InitEmptyFunctionTestContext(p *FunctionTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_functionTest
}

func (*FunctionTestContext) IsFunctionTestContext() {}

func NewFunctionTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionTestContext {
	var p = new(FunctionTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_functionTest

	return p
}

func (s *FunctionTestContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionTestContext) AnyFunctionTest() IAnyFunctionTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnyFunctionTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnyFunctionTestContext)
}

func (s *FunctionTestContext) TypedFunctionTest() ITypedFunctionTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedFunctionTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedFunctionTestContext)
}

func (s *FunctionTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterFunctionTest(s)
	}
}

func (s *FunctionTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitFunctionTest(s)
	}
}

func (p *XPath3Parser) FunctionTest() (localctx IFunctionTestContext) {
	localctx = NewFunctionTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, XPath3ParserRULE_functionTest)
	p.SetState(773)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 62, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(771)
			p.AnyFunctionTest()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(772)
			p.TypedFunctionTest()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnyFunctionTestContext is an interface to support dynamic dispatch.
type IAnyFunctionTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAnyFunctionTestContext differentiates from other interfaces.
	IsAnyFunctionTestContext()
}

type AnyFunctionTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnyFunctionTestContext() *AnyFunctionTestContext {
	var p = new(AnyFunctionTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_anyFunctionTest
	return p
}

func InitEmptyAnyFunctionTestContext(p *AnyFunctionTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_anyFunctionTest
}

func (*AnyFunctionTestContext) IsAnyFunctionTestContext() {}

func NewAnyFunctionTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnyFunctionTestContext {
	var p = new(AnyFunctionTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_anyFunctionTest

	return p
}

func (s *AnyFunctionTestContext) GetParser() antlr.Parser { return s.parser }
func (s *AnyFunctionTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnyFunctionTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnyFunctionTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterAnyFunctionTest(s)
	}
}

func (s *AnyFunctionTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitAnyFunctionTest(s)
	}
}

func (p *XPath3Parser) AnyFunctionTest() (localctx IAnyFunctionTestContext) {
	localctx = NewAnyFunctionTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, XPath3ParserRULE_anyFunctionTest)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(775)
		p.Match(XPath3ParserT__77)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(776)
		p.Match(XPath3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(777)
		p.Match(XPath3ParserT__23)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(778)
		p.Match(XPath3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypedFunctionTestContext is an interface to support dynamic dispatch.
type ITypedFunctionTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSequenceType() []ISequenceTypeContext
	SequenceType(i int) ISequenceTypeContext

	// IsTypedFunctionTestContext differentiates from other interfaces.
	IsTypedFunctionTestContext()
}

type TypedFunctionTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypedFunctionTestContext() *TypedFunctionTestContext {
	var p = new(TypedFunctionTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_typedFunctionTest
	return p
}

func InitEmptyTypedFunctionTestContext(p *TypedFunctionTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_typedFunctionTest
}

func (*TypedFunctionTestContext) IsTypedFunctionTestContext() {}

func NewTypedFunctionTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypedFunctionTestContext {
	var p = new(TypedFunctionTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_typedFunctionTest

	return p
}

func (s *TypedFunctionTestContext) GetParser() antlr.Parser { return s.parser }

func (s *TypedFunctionTestContext) AllSequenceType() []ISequenceTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISequenceTypeContext); ok {
			len++
		}
	}

	tst := make([]ISequenceTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISequenceTypeContext); ok {
			tst[i] = t.(ISequenceTypeContext)
			i++
		}
	}

	return tst
}

func (s *TypedFunctionTestContext) SequenceType(i int) ISequenceTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISequenceTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISequenceTypeContext)
}

func (s *TypedFunctionTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypedFunctionTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypedFunctionTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterTypedFunctionTest(s)
	}
}

func (s *TypedFunctionTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitTypedFunctionTest(s)
	}
}

func (p *XPath3Parser) TypedFunctionTest() (localctx ITypedFunctionTestContext) {
	localctx = NewTypedFunctionTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, XPath3ParserRULE_typedFunctionTest)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(780)
		p.Match(XPath3ParserT__77)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(781)
		p.Match(XPath3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(790)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == XPath3ParserT__13 || _la == XPath3ParserT__58 || ((int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&17829887) != 0) {
		{
			p.SetState(782)
			p.SequenceType()
		}
		p.SetState(787)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == XPath3ParserT__0 {
			{
				p.SetState(783)
				p.Match(XPath3ParserT__0)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(784)
				p.SequenceType()
			}

			p.SetState(789)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(792)
		p.Match(XPath3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(793)
		p.Match(XPath3ParserT__34)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(794)
		p.SequenceType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParenthesizedItemTypeContext is an interface to support dynamic dispatch.
type IParenthesizedItemTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ItemType() IItemTypeContext

	// IsParenthesizedItemTypeContext differentiates from other interfaces.
	IsParenthesizedItemTypeContext()
}

type ParenthesizedItemTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParenthesizedItemTypeContext() *ParenthesizedItemTypeContext {
	var p = new(ParenthesizedItemTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_parenthesizedItemType
	return p
}

func InitEmptyParenthesizedItemTypeContext(p *ParenthesizedItemTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_parenthesizedItemType
}

func (*ParenthesizedItemTypeContext) IsParenthesizedItemTypeContext() {}

func NewParenthesizedItemTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParenthesizedItemTypeContext {
	var p = new(ParenthesizedItemTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_parenthesizedItemType

	return p
}

func (s *ParenthesizedItemTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ParenthesizedItemTypeContext) ItemType() IItemTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IItemTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IItemTypeContext)
}

func (s *ParenthesizedItemTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedItemTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParenthesizedItemTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterParenthesizedItemType(s)
	}
}

func (s *ParenthesizedItemTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitParenthesizedItemType(s)
	}
}

func (p *XPath3Parser) ParenthesizedItemType() (localctx IParenthesizedItemTypeContext) {
	localctx = NewParenthesizedItemTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, XPath3ParserRULE_parenthesizedItemType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(796)
		p.Match(XPath3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(797)
		p.ItemType()
	}
	{
		p.SetState(798)
		p.Match(XPath3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEqNameContext is an interface to support dynamic dispatch.
type IEqNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QNAME() antlr.TerminalNode
	URIQualifiedName() antlr.TerminalNode

	// IsEqNameContext differentiates from other interfaces.
	IsEqNameContext()
}

type EqNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEqNameContext() *EqNameContext {
	var p = new(EqNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_eqName
	return p
}

func InitEmptyEqNameContext(p *EqNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_eqName
}

func (*EqNameContext) IsEqNameContext() {}

func NewEqNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EqNameContext {
	var p = new(EqNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_eqName

	return p
}

func (s *EqNameContext) GetParser() antlr.Parser { return s.parser }

func (s *EqNameContext) QNAME() antlr.TerminalNode {
	return s.GetToken(XPath3ParserQNAME, 0)
}

func (s *EqNameContext) URIQualifiedName() antlr.TerminalNode {
	return s.GetToken(XPath3ParserURIQualifiedName, 0)
}

func (s *EqNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EqNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterEqName(s)
	}
}

func (s *EqNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitEqName(s)
	}
}

func (p *XPath3Parser) EqName() (localctx IEqNameContext) {
	localctx = NewEqNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, XPath3ParserRULE_eqName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(800)
		_la = p.GetTokenStream().LA(1)

		if !(_la == XPath3ParserURIQualifiedName || _la == XPath3ParserQNAME) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringLiteralContext is an interface to support dynamic dispatch.
type IStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllESCAPE_QUOTE() []antlr.TerminalNode
	ESCAPE_QUOTE(i int) antlr.TerminalNode
	AllESCAPE_APOS() []antlr.TerminalNode
	ESCAPE_APOS(i int) antlr.TerminalNode

	// IsStringLiteralContext differentiates from other interfaces.
	IsStringLiteralContext()
}

type StringLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringLiteralContext() *StringLiteralContext {
	var p = new(StringLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_stringLiteral
	return p
}

func InitEmptyStringLiteralContext(p *StringLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_stringLiteral
}

func (*StringLiteralContext) IsStringLiteralContext() {}

func NewStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringLiteralContext {
	var p = new(StringLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_stringLiteral

	return p
}

func (s *StringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *StringLiteralContext) AllESCAPE_QUOTE() []antlr.TerminalNode {
	return s.GetTokens(XPath3ParserESCAPE_QUOTE)
}

func (s *StringLiteralContext) ESCAPE_QUOTE(i int) antlr.TerminalNode {
	return s.GetToken(XPath3ParserESCAPE_QUOTE, i)
}

func (s *StringLiteralContext) AllESCAPE_APOS() []antlr.TerminalNode {
	return s.GetTokens(XPath3ParserESCAPE_APOS)
}

func (s *StringLiteralContext) ESCAPE_APOS(i int) antlr.TerminalNode {
	return s.GetToken(XPath3ParserESCAPE_APOS, i)
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

func (p *XPath3Parser) StringLiteral() (localctx IStringLiteralContext) {
	localctx = NewStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, XPath3ParserRULE_stringLiteral)
	var _alt int

	p.SetState(820)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserT__89:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(802)
			p.Match(XPath3ParserT__89)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(807)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 66, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1+1 {
				p.SetState(805)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 65, p.GetParserRuleContext()) {
				case 1:
					{
						p.SetState(803)
						p.Match(XPath3ParserESCAPE_QUOTE)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case 2:
					p.SetState(804)
					p.MatchWildcard()

				case antlr.ATNInvalidAltNumber:
					goto errorExit
				}

			}
			p.SetState(809)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 66, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		{
			p.SetState(810)
			p.Match(XPath3ParserT__89)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case XPath3ParserT__90:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(811)
			p.Match(XPath3ParserT__90)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(816)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 68, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1+1 {
				p.SetState(814)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 67, p.GetParserRuleContext()) {
				case 1:
					{
						p.SetState(812)
						p.Match(XPath3ParserESCAPE_APOS)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case 2:
					p.SetState(813)
					p.MatchWildcard()

				case antlr.ATNInvalidAltNumber:
					goto errorExit
				}

			}
			p.SetState(818)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 68, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		{
			p.SetState(819)
			p.Match(XPath3ParserT__90)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *XPath3Parser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 9:
		var t *ForBindingListContext = nil
		if localctx != nil {
			t = localctx.(*ForBindingListContext)
		}
		return p.ForBindingList_Sempred(t, predIndex)

	case 13:
		var t *LetBindingListContext = nil
		if localctx != nil {
			t = localctx.(*LetBindingListContext)
		}
		return p.LetBindingList_Sempred(t, predIndex)

	case 16:
		var t *QuantifiedBindingListContext = nil
		if localctx != nil {
			t = localctx.(*QuantifiedBindingListContext)
		}
		return p.QuantifiedBindingList_Sempred(t, predIndex)

	case 19:
		var t *OrExprContext = nil
		if localctx != nil {
			t = localctx.(*OrExprContext)
		}
		return p.OrExpr_Sempred(t, predIndex)

	case 20:
		var t *AndExprContext = nil
		if localctx != nil {
			t = localctx.(*AndExprContext)
		}
		return p.AndExpr_Sempred(t, predIndex)

	case 22:
		var t *StringConcatExprContext = nil
		if localctx != nil {
			t = localctx.(*StringConcatExprContext)
		}
		return p.StringConcatExpr_Sempred(t, predIndex)

	case 23:
		var t *RangeExprContext = nil
		if localctx != nil {
			t = localctx.(*RangeExprContext)
		}
		return p.RangeExpr_Sempred(t, predIndex)

	case 24:
		var t *AdditiveExprContext = nil
		if localctx != nil {
			t = localctx.(*AdditiveExprContext)
		}
		return p.AdditiveExpr_Sempred(t, predIndex)

	case 25:
		var t *MultiplicativeExprContext = nil
		if localctx != nil {
			t = localctx.(*MultiplicativeExprContext)
		}
		return p.MultiplicativeExpr_Sempred(t, predIndex)

	case 26:
		var t *UnionExprContext = nil
		if localctx != nil {
			t = localctx.(*UnionExprContext)
		}
		return p.UnionExpr_Sempred(t, predIndex)

	case 27:
		var t *IntersectExceptExprContext = nil
		if localctx != nil {
			t = localctx.(*IntersectExceptExprContext)
		}
		return p.IntersectExceptExpr_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *XPath3Parser) ForBindingList_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *XPath3Parser) LetBindingList_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 1:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *XPath3Parser) QuantifiedBindingList_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *XPath3Parser) OrExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 3:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *XPath3Parser) AndExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 4:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *XPath3Parser) StringConcatExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 5:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *XPath3Parser) RangeExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 6:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *XPath3Parser) AdditiveExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 7:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *XPath3Parser) MultiplicativeExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 8:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *XPath3Parser) UnionExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 9:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *XPath3Parser) IntersectExceptExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 10:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
