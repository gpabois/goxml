// Code generated from XPath3.g by ANTLR 4.13.0. DO NOT EDIT.

package parser // XPath3

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type XPath3Parser struct {
	*antlr.BaseParser
}

var XPath3ParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func xpath3ParserInit() {
	staticData := &XPath3ParserStaticData
	staticData.LiteralNames = []string{
		"", "','", "'$'", "'{'", "'}'", "'return'", "'for'", "'in'", "'let'",
		"':='", "'some'", "'any'", "'satisfies'", "'if'", "'('", "')'", "'then'",
		"'else'", "'or'", "'||'", "'to'", "'+'", "'-'", "'*'", "'div'", "'idiv'",
		"'mod'", "'union'", "'|'", "'intersect'", "'except'", "'instance'",
		"'of'", "'treat'", "'as'", "'castable'", "'cast'", "'='", "'!='", "'<='",
		"'>='", "'<'", "'>'", "'eq'", "'ne'", "'lt'", "'le'", "'gt'", "'ge'",
		"'is'", "'<<'", "'>>'", "'!'", "'/'", "'//'", "'child'", "'::'", "'descendant'",
		"'attribute'", "'self'", "'descendant-or-self'", "'following-sibling'",
		"'following'", "'namespace'", "'@'", "'parent'", "'ancestor'", "'preceding-sibling'",
		"'preceding'", "'ancestor-or-self'", "'..'", "':'", "'['", "']'", "'.'",
		"'?'", "'#'", "'function'", "'empty-sequence'", "'item'", "'node'",
		"'document-node'", "'text'", "'comment'", "'namespace-node'", "'processing-instruction'",
		"'schema-attribute'", "'element'", "'schema-element'", "'\"'", "'''",
		"", "", "", "", "'\\\"'", "'\\''",
	}
	staticData.SymbolicNames = []string{
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "NumericLiteral", "IntegerLiteral", "DecimalLiteral",
		"DoubleLiteral", "ESCAPE_QUOTE", "ESCAPE_APOS", "URIQualifiedName",
		"Comment", "BracedURILiteral", "CommentContents", "QNAME", "PREFIXED_NAME",
		"UNPREFIXED_NAME", "PREFIX", "LOCAL_PART", "NC_NAME", "CHAR", "DIGITS",
	}
	staticData.RuleNames = []string{
		"xPath", "paramList", "param", "functionBody", "enclosedExpr", "expr",
		"exprSingle", "forExpr", "simpleForClause", "forBindingList", "simpleForBinding",
		"letExpr", "simpleLetClause", "simpleLetBinding", "quantifiedExpr",
		"ifExpr", "orExpr", "andExpr", "stringConcatexpr", "rangeExpr", "additiveExpr",
		"multiplicativeExpr", "unionExpr", "intersectExceptExpr", "instanceofExpr",
		"treatExpr", "castableExpr", "castExpr", "unaryExpr", "valueExpr", "generalComp",
		"valueComp", "nodeComp", "simpleMapExpr", "pathExpr", "relativePathExpr",
		"stepExpr", "axisStep", "forwardStep", "forwardAxis", "abbrevForwardStep",
		"reverseStep", "reverseAxis", "abbrevReverseStep", "nodeTest", "nameTest",
		"wildCard", "postfixExpr", "argumentList", "predicateList", "predicate",
		"primaryExpr", "varRef", "varName", "literal", "parenthesizedExpr",
		"contextItemExpr", "functionCall", "argument", "argumentPlaceholder",
		"functionItemExpr", "namedFunctionRef", "inlineFunctionExpr", "singleType",
		"type_declaration", "sequenceType", "occurenceIndicator", "itemType",
		"atomicOrUnionType", "kindTest", "anyKindTest", "documentTest", "textTest",
		"commentTest", "namespaceNodeTest", "piTest", "attributeTest", "attribNameOrWildcard",
		"schemaAttributeTest", "attributeDeclaration", "elementTest", "elementNameOrWildcard",
		"schemaElementTest", "elementDeclaration", "attributeName", "elementName",
		"simpleTypeName", "typeName", "functionTest", "anyFunctionTest", "typedFunctionTest",
		"parenthesizedItemType", "eqName", "stringLiteral",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 108, 771, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7,
		4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7,
		10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15,
		2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2,
		21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26,
		7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7,
		31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36,
		2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 2,
		42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 47,
		7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7,
		52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 57,
		2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62, 2,
		63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2, 68,
		7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73, 7,
		73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7, 78,
		2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83, 2,
		84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2, 89,
		7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 1, 0, 1,
		0, 1, 0, 1, 1, 1, 1, 1, 1, 5, 1, 195, 8, 1, 10, 1, 12, 1, 198, 9, 1, 1,
		2, 1, 2, 1, 2, 3, 2, 203, 8, 2, 1, 3, 1, 3, 1, 4, 1, 4, 1, 4, 1, 4, 1,
		5, 1, 5, 1, 5, 5, 5, 214, 8, 5, 10, 5, 12, 5, 217, 9, 5, 1, 6, 1, 6, 1,
		6, 1, 6, 1, 6, 3, 6, 224, 8, 6, 1, 7, 1, 7, 1, 7, 1, 7, 1, 8, 1, 8, 1,
		8, 1, 8, 5, 8, 234, 8, 8, 10, 8, 12, 8, 237, 9, 8, 1, 9, 1, 9, 1, 9, 1,
		9, 1, 9, 1, 9, 5, 9, 245, 8, 9, 10, 9, 12, 9, 248, 9, 9, 1, 10, 1, 10,
		1, 10, 1, 10, 1, 10, 1, 11, 1, 11, 1, 11, 1, 11, 1, 12, 1, 12, 1, 12, 1,
		12, 5, 12, 263, 8, 12, 10, 12, 12, 12, 266, 9, 12, 1, 13, 1, 13, 1, 13,
		1, 13, 1, 13, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1,
		14, 1, 14, 1, 14, 5, 14, 284, 8, 14, 10, 14, 12, 14, 287, 9, 14, 1, 14,
		1, 14, 1, 14, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1,
		15, 1, 16, 1, 16, 1, 16, 5, 16, 304, 8, 16, 10, 16, 12, 16, 307, 9, 16,
		1, 17, 1, 17, 1, 17, 1, 17, 3, 17, 313, 8, 17, 1, 17, 1, 17, 3, 17, 317,
		8, 17, 1, 18, 1, 18, 1, 18, 5, 18, 322, 8, 18, 10, 18, 12, 18, 325, 9,
		18, 1, 19, 1, 19, 1, 19, 3, 19, 330, 8, 19, 1, 20, 1, 20, 1, 20, 5, 20,
		335, 8, 20, 10, 20, 12, 20, 338, 9, 20, 1, 21, 1, 21, 1, 21, 5, 21, 343,
		8, 21, 10, 21, 12, 21, 346, 9, 21, 1, 22, 1, 22, 1, 22, 5, 22, 351, 8,
		22, 10, 22, 12, 22, 354, 9, 22, 1, 23, 1, 23, 1, 23, 5, 23, 359, 8, 23,
		10, 23, 12, 23, 362, 9, 23, 1, 24, 1, 24, 1, 24, 1, 24, 3, 24, 368, 8,
		24, 1, 25, 1, 25, 1, 25, 1, 25, 3, 25, 374, 8, 25, 1, 26, 1, 26, 1, 26,
		1, 26, 3, 26, 380, 8, 26, 1, 27, 1, 27, 1, 27, 1, 27, 3, 27, 386, 8, 27,
		1, 28, 5, 28, 389, 8, 28, 10, 28, 12, 28, 392, 9, 28, 1, 28, 1, 28, 1,
		29, 1, 29, 1, 30, 1, 30, 1, 31, 1, 31, 1, 32, 1, 32, 1, 33, 1, 33, 1, 33,
		5, 33, 407, 8, 33, 10, 33, 12, 33, 410, 9, 33, 1, 34, 1, 34, 3, 34, 414,
		8, 34, 1, 34, 1, 34, 1, 34, 3, 34, 419, 8, 34, 1, 35, 1, 35, 1, 35, 5,
		35, 424, 8, 35, 10, 35, 12, 35, 427, 9, 35, 1, 36, 1, 36, 3, 36, 431, 8,
		36, 1, 37, 1, 37, 3, 37, 435, 8, 37, 1, 37, 1, 37, 1, 38, 1, 38, 1, 38,
		1, 38, 3, 38, 443, 8, 38, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1,
		39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 3, 39,
		461, 8, 39, 1, 40, 3, 40, 464, 8, 40, 1, 40, 1, 40, 1, 41, 1, 41, 1, 41,
		1, 41, 3, 41, 472, 8, 41, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1,
		42, 1, 42, 1, 42, 1, 42, 3, 42, 484, 8, 42, 1, 43, 1, 43, 1, 44, 1, 44,
		3, 44, 490, 8, 44, 1, 45, 1, 45, 3, 45, 494, 8, 45, 1, 46, 1, 46, 1, 46,
		1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 3, 46, 505, 8, 46, 1, 47, 1,
		47, 1, 47, 5, 47, 510, 8, 47, 10, 47, 12, 47, 513, 9, 47, 1, 48, 1, 48,
		1, 48, 1, 48, 5, 48, 519, 8, 48, 10, 48, 12, 48, 522, 9, 48, 3, 48, 524,
		8, 48, 1, 48, 1, 48, 1, 49, 5, 49, 529, 8, 49, 10, 49, 12, 49, 532, 9,
		49, 1, 50, 1, 50, 1, 50, 1, 50, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51,
		3, 51, 544, 8, 51, 1, 52, 1, 52, 1, 52, 1, 53, 1, 53, 1, 54, 1, 54, 3,
		54, 553, 8, 54, 1, 55, 1, 55, 3, 55, 557, 8, 55, 1, 55, 1, 55, 1, 56, 1,
		56, 1, 57, 1, 57, 1, 57, 1, 58, 1, 58, 3, 58, 568, 8, 58, 1, 59, 1, 59,
		1, 60, 1, 60, 3, 60, 574, 8, 60, 1, 61, 1, 61, 1, 61, 1, 61, 1, 62, 1,
		62, 1, 62, 3, 62, 583, 8, 62, 1, 62, 1, 62, 1, 62, 3, 62, 588, 8, 62, 1,
		62, 1, 62, 1, 63, 1, 63, 3, 63, 594, 8, 63, 1, 64, 1, 64, 1, 64, 1, 65,
		1, 65, 1, 65, 1, 65, 1, 65, 3, 65, 604, 8, 65, 3, 65, 606, 8, 65, 1, 66,
		1, 66, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 3, 67, 617, 8,
		67, 1, 68, 1, 68, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69,
		1, 69, 1, 69, 3, 69, 631, 8, 69, 1, 70, 1, 70, 1, 70, 1, 70, 1, 71, 1,
		71, 1, 71, 1, 71, 3, 71, 641, 8, 71, 1, 71, 1, 71, 1, 72, 1, 72, 1, 72,
		1, 72, 1, 73, 1, 73, 1, 73, 1, 73, 1, 74, 1, 74, 1, 74, 1, 74, 1, 75, 1,
		75, 1, 75, 1, 75, 3, 75, 661, 8, 75, 1, 75, 1, 75, 1, 76, 1, 76, 1, 76,
		1, 76, 1, 76, 3, 76, 670, 8, 76, 3, 76, 672, 8, 76, 1, 76, 1, 76, 1, 77,
		1, 77, 3, 77, 678, 8, 77, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 79, 1,
		79, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 3, 80, 693, 8, 80, 3, 80,
		695, 8, 80, 3, 80, 697, 8, 80, 1, 80, 1, 80, 1, 81, 1, 81, 3, 81, 703,
		8, 81, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 83, 1, 83, 1, 84, 1, 84, 1,
		85, 1, 85, 1, 86, 1, 86, 1, 87, 1, 87, 1, 88, 1, 88, 3, 88, 722, 8, 88,
		1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 5,
		90, 734, 8, 90, 10, 90, 12, 90, 737, 9, 90, 3, 90, 739, 8, 90, 1, 90, 1,
		90, 1, 90, 1, 90, 1, 91, 1, 91, 1, 91, 1, 91, 1, 92, 1, 92, 1, 93, 1, 93,
		1, 93, 5, 93, 754, 8, 93, 10, 93, 12, 93, 757, 9, 93, 1, 93, 1, 93, 1,
		93, 1, 93, 5, 93, 763, 8, 93, 10, 93, 12, 93, 766, 9, 93, 1, 93, 3, 93,
		769, 8, 93, 1, 93, 2, 755, 764, 1, 18, 94, 0, 2, 4, 6, 8, 10, 12, 14, 16,
		18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52,
		54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88,
		90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120,
		122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150,
		152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180,
		182, 184, 186, 0, 11, 1, 0, 10, 11, 1, 0, 21, 22, 1, 0, 23, 26, 1, 0, 27,
		28, 1, 0, 29, 30, 1, 0, 37, 42, 1, 0, 43, 48, 1, 0, 49, 51, 1, 0, 53, 54,
		3, 0, 21, 21, 23, 23, 75, 75, 2, 0, 97, 97, 101, 101, 779, 0, 188, 1, 0,
		0, 0, 2, 191, 1, 0, 0, 0, 4, 199, 1, 0, 0, 0, 6, 204, 1, 0, 0, 0, 8, 206,
		1, 0, 0, 0, 10, 210, 1, 0, 0, 0, 12, 223, 1, 0, 0, 0, 14, 225, 1, 0, 0,
		0, 16, 229, 1, 0, 0, 0, 18, 238, 1, 0, 0, 0, 20, 249, 1, 0, 0, 0, 22, 254,
		1, 0, 0, 0, 24, 258, 1, 0, 0, 0, 26, 267, 1, 0, 0, 0, 28, 272, 1, 0, 0,
		0, 30, 291, 1, 0, 0, 0, 32, 300, 1, 0, 0, 0, 34, 308, 1, 0, 0, 0, 36, 318,
		1, 0, 0, 0, 38, 326, 1, 0, 0, 0, 40, 331, 1, 0, 0, 0, 42, 339, 1, 0, 0,
		0, 44, 347, 1, 0, 0, 0, 46, 355, 1, 0, 0, 0, 48, 363, 1, 0, 0, 0, 50, 369,
		1, 0, 0, 0, 52, 375, 1, 0, 0, 0, 54, 381, 1, 0, 0, 0, 56, 390, 1, 0, 0,
		0, 58, 395, 1, 0, 0, 0, 60, 397, 1, 0, 0, 0, 62, 399, 1, 0, 0, 0, 64, 401,
		1, 0, 0, 0, 66, 403, 1, 0, 0, 0, 68, 418, 1, 0, 0, 0, 70, 420, 1, 0, 0,
		0, 72, 430, 1, 0, 0, 0, 74, 434, 1, 0, 0, 0, 76, 442, 1, 0, 0, 0, 78, 460,
		1, 0, 0, 0, 80, 463, 1, 0, 0, 0, 82, 471, 1, 0, 0, 0, 84, 483, 1, 0, 0,
		0, 86, 485, 1, 0, 0, 0, 88, 489, 1, 0, 0, 0, 90, 493, 1, 0, 0, 0, 92, 504,
		1, 0, 0, 0, 94, 506, 1, 0, 0, 0, 96, 514, 1, 0, 0, 0, 98, 530, 1, 0, 0,
		0, 100, 533, 1, 0, 0, 0, 102, 543, 1, 0, 0, 0, 104, 545, 1, 0, 0, 0, 106,
		548, 1, 0, 0, 0, 108, 552, 1, 0, 0, 0, 110, 554, 1, 0, 0, 0, 112, 560,
		1, 0, 0, 0, 114, 562, 1, 0, 0, 0, 116, 567, 1, 0, 0, 0, 118, 569, 1, 0,
		0, 0, 120, 573, 1, 0, 0, 0, 122, 575, 1, 0, 0, 0, 124, 579, 1, 0, 0, 0,
		126, 591, 1, 0, 0, 0, 128, 595, 1, 0, 0, 0, 130, 605, 1, 0, 0, 0, 132,
		607, 1, 0, 0, 0, 134, 616, 1, 0, 0, 0, 136, 618, 1, 0, 0, 0, 138, 630,
		1, 0, 0, 0, 140, 632, 1, 0, 0, 0, 142, 636, 1, 0, 0, 0, 144, 644, 1, 0,
		0, 0, 146, 648, 1, 0, 0, 0, 148, 652, 1, 0, 0, 0, 150, 656, 1, 0, 0, 0,
		152, 664, 1, 0, 0, 0, 154, 677, 1, 0, 0, 0, 156, 679, 1, 0, 0, 0, 158,
		684, 1, 0, 0, 0, 160, 686, 1, 0, 0, 0, 162, 702, 1, 0, 0, 0, 164, 704,
		1, 0, 0, 0, 166, 709, 1, 0, 0, 0, 168, 711, 1, 0, 0, 0, 170, 713, 1, 0,
		0, 0, 172, 715, 1, 0, 0, 0, 174, 717, 1, 0, 0, 0, 176, 721, 1, 0, 0, 0,
		178, 723, 1, 0, 0, 0, 180, 728, 1, 0, 0, 0, 182, 744, 1, 0, 0, 0, 184,
		748, 1, 0, 0, 0, 186, 768, 1, 0, 0, 0, 188, 189, 3, 10, 5, 0, 189, 190,
		5, 0, 0, 1, 190, 1, 1, 0, 0, 0, 191, 196, 3, 4, 2, 0, 192, 193, 5, 1, 0,
		0, 193, 195, 3, 4, 2, 0, 194, 192, 1, 0, 0, 0, 195, 198, 1, 0, 0, 0, 196,
		194, 1, 0, 0, 0, 196, 197, 1, 0, 0, 0, 197, 3, 1, 0, 0, 0, 198, 196, 1,
		0, 0, 0, 199, 200, 5, 2, 0, 0, 200, 202, 3, 184, 92, 0, 201, 203, 3, 128,
		64, 0, 202, 201, 1, 0, 0, 0, 202, 203, 1, 0, 0, 0, 203, 5, 1, 0, 0, 0,
		204, 205, 3, 8, 4, 0, 205, 7, 1, 0, 0, 0, 206, 207, 5, 3, 0, 0, 207, 208,
		3, 10, 5, 0, 208, 209, 5, 4, 0, 0, 209, 9, 1, 0, 0, 0, 210, 215, 3, 12,
		6, 0, 211, 212, 5, 1, 0, 0, 212, 214, 3, 12, 6, 0, 213, 211, 1, 0, 0, 0,
		214, 217, 1, 0, 0, 0, 215, 213, 1, 0, 0, 0, 215, 216, 1, 0, 0, 0, 216,
		11, 1, 0, 0, 0, 217, 215, 1, 0, 0, 0, 218, 224, 3, 14, 7, 0, 219, 224,
		3, 22, 11, 0, 220, 224, 3, 28, 14, 0, 221, 224, 3, 30, 15, 0, 222, 224,
		3, 32, 16, 0, 223, 218, 1, 0, 0, 0, 223, 219, 1, 0, 0, 0, 223, 220, 1,
		0, 0, 0, 223, 221, 1, 0, 0, 0, 223, 222, 1, 0, 0, 0, 224, 13, 1, 0, 0,
		0, 225, 226, 3, 16, 8, 0, 226, 227, 5, 5, 0, 0, 227, 228, 3, 12, 6, 0,
		228, 15, 1, 0, 0, 0, 229, 230, 5, 6, 0, 0, 230, 235, 3, 20, 10, 0, 231,
		232, 5, 1, 0, 0, 232, 234, 3, 20, 10, 0, 233, 231, 1, 0, 0, 0, 234, 237,
		1, 0, 0, 0, 235, 233, 1, 0, 0, 0, 235, 236, 1, 0, 0, 0, 236, 17, 1, 0,
		0, 0, 237, 235, 1, 0, 0, 0, 238, 239, 6, 9, -1, 0, 239, 240, 3, 20, 10,
		0, 240, 246, 1, 0, 0, 0, 241, 242, 10, 1, 0, 0, 242, 243, 5, 1, 0, 0, 243,
		245, 3, 20, 10, 0, 244, 241, 1, 0, 0, 0, 245, 248, 1, 0, 0, 0, 246, 244,
		1, 0, 0, 0, 246, 247, 1, 0, 0, 0, 247, 19, 1, 0, 0, 0, 248, 246, 1, 0,
		0, 0, 249, 250, 5, 2, 0, 0, 250, 251, 3, 106, 53, 0, 251, 252, 5, 7, 0,
		0, 252, 253, 3, 12, 6, 0, 253, 21, 1, 0, 0, 0, 254, 255, 3, 24, 12, 0,
		255, 256, 5, 5, 0, 0, 256, 257, 3, 12, 6, 0, 257, 23, 1, 0, 0, 0, 258,
		259, 5, 8, 0, 0, 259, 264, 3, 26, 13, 0, 260, 261, 5, 1, 0, 0, 261, 263,
		3, 26, 13, 0, 262, 260, 1, 0, 0, 0, 263, 266, 1, 0, 0, 0, 264, 262, 1,
		0, 0, 0, 264, 265, 1, 0, 0, 0, 265, 25, 1, 0, 0, 0, 266, 264, 1, 0, 0,
		0, 267, 268, 5, 2, 0, 0, 268, 269, 3, 106, 53, 0, 269, 270, 5, 9, 0, 0,
		270, 271, 3, 12, 6, 0, 271, 27, 1, 0, 0, 0, 272, 273, 7, 0, 0, 0, 273,
		274, 5, 2, 0, 0, 274, 275, 3, 106, 53, 0, 275, 276, 5, 7, 0, 0, 276, 285,
		3, 12, 6, 0, 277, 278, 5, 1, 0, 0, 278, 279, 5, 2, 0, 0, 279, 280, 3, 106,
		53, 0, 280, 281, 5, 7, 0, 0, 281, 282, 3, 12, 6, 0, 282, 284, 1, 0, 0,
		0, 283, 277, 1, 0, 0, 0, 284, 287, 1, 0, 0, 0, 285, 283, 1, 0, 0, 0, 285,
		286, 1, 0, 0, 0, 286, 288, 1, 0, 0, 0, 287, 285, 1, 0, 0, 0, 288, 289,
		5, 12, 0, 0, 289, 290, 3, 12, 6, 0, 290, 29, 1, 0, 0, 0, 291, 292, 5, 13,
		0, 0, 292, 293, 5, 14, 0, 0, 293, 294, 3, 10, 5, 0, 294, 295, 5, 15, 0,
		0, 295, 296, 5, 16, 0, 0, 296, 297, 3, 12, 6, 0, 297, 298, 5, 17, 0, 0,
		298, 299, 3, 12, 6, 0, 299, 31, 1, 0, 0, 0, 300, 305, 3, 34, 17, 0, 301,
		302, 5, 18, 0, 0, 302, 304, 3, 34, 17, 0, 303, 301, 1, 0, 0, 0, 304, 307,
		1, 0, 0, 0, 305, 303, 1, 0, 0, 0, 305, 306, 1, 0, 0, 0, 306, 33, 1, 0,
		0, 0, 307, 305, 1, 0, 0, 0, 308, 316, 3, 36, 18, 0, 309, 313, 3, 62, 31,
		0, 310, 313, 3, 60, 30, 0, 311, 313, 3, 64, 32, 0, 312, 309, 1, 0, 0, 0,
		312, 310, 1, 0, 0, 0, 312, 311, 1, 0, 0, 0, 313, 314, 1, 0, 0, 0, 314,
		315, 3, 36, 18, 0, 315, 317, 1, 0, 0, 0, 316, 312, 1, 0, 0, 0, 316, 317,
		1, 0, 0, 0, 317, 35, 1, 0, 0, 0, 318, 323, 3, 38, 19, 0, 319, 320, 5, 19,
		0, 0, 320, 322, 3, 38, 19, 0, 321, 319, 1, 0, 0, 0, 322, 325, 1, 0, 0,
		0, 323, 321, 1, 0, 0, 0, 323, 324, 1, 0, 0, 0, 324, 37, 1, 0, 0, 0, 325,
		323, 1, 0, 0, 0, 326, 329, 3, 40, 20, 0, 327, 328, 5, 20, 0, 0, 328, 330,
		3, 40, 20, 0, 329, 327, 1, 0, 0, 0, 329, 330, 1, 0, 0, 0, 330, 39, 1, 0,
		0, 0, 331, 336, 3, 42, 21, 0, 332, 333, 7, 1, 0, 0, 333, 335, 3, 42, 21,
		0, 334, 332, 1, 0, 0, 0, 335, 338, 1, 0, 0, 0, 336, 334, 1, 0, 0, 0, 336,
		337, 1, 0, 0, 0, 337, 41, 1, 0, 0, 0, 338, 336, 1, 0, 0, 0, 339, 344, 3,
		44, 22, 0, 340, 341, 7, 2, 0, 0, 341, 343, 3, 44, 22, 0, 342, 340, 1, 0,
		0, 0, 343, 346, 1, 0, 0, 0, 344, 342, 1, 0, 0, 0, 344, 345, 1, 0, 0, 0,
		345, 43, 1, 0, 0, 0, 346, 344, 1, 0, 0, 0, 347, 352, 3, 46, 23, 0, 348,
		349, 7, 3, 0, 0, 349, 351, 3, 46, 23, 0, 350, 348, 1, 0, 0, 0, 351, 354,
		1, 0, 0, 0, 352, 350, 1, 0, 0, 0, 352, 353, 1, 0, 0, 0, 353, 45, 1, 0,
		0, 0, 354, 352, 1, 0, 0, 0, 355, 360, 3, 48, 24, 0, 356, 357, 7, 4, 0,
		0, 357, 359, 3, 48, 24, 0, 358, 356, 1, 0, 0, 0, 359, 362, 1, 0, 0, 0,
		360, 358, 1, 0, 0, 0, 360, 361, 1, 0, 0, 0, 361, 47, 1, 0, 0, 0, 362, 360,
		1, 0, 0, 0, 363, 367, 3, 50, 25, 0, 364, 365, 5, 31, 0, 0, 365, 366, 5,
		32, 0, 0, 366, 368, 3, 130, 65, 0, 367, 364, 1, 0, 0, 0, 367, 368, 1, 0,
		0, 0, 368, 49, 1, 0, 0, 0, 369, 373, 3, 52, 26, 0, 370, 371, 5, 33, 0,
		0, 371, 372, 5, 34, 0, 0, 372, 374, 3, 130, 65, 0, 373, 370, 1, 0, 0, 0,
		373, 374, 1, 0, 0, 0, 374, 51, 1, 0, 0, 0, 375, 379, 3, 54, 27, 0, 376,
		377, 5, 35, 0, 0, 377, 378, 5, 34, 0, 0, 378, 380, 3, 126, 63, 0, 379,
		376, 1, 0, 0, 0, 379, 380, 1, 0, 0, 0, 380, 53, 1, 0, 0, 0, 381, 385, 3,
		56, 28, 0, 382, 383, 5, 36, 0, 0, 383, 384, 5, 34, 0, 0, 384, 386, 3, 126,
		63, 0, 385, 382, 1, 0, 0, 0, 385, 386, 1, 0, 0, 0, 386, 55, 1, 0, 0, 0,
		387, 389, 7, 1, 0, 0, 388, 387, 1, 0, 0, 0, 389, 392, 1, 0, 0, 0, 390,
		388, 1, 0, 0, 0, 390, 391, 1, 0, 0, 0, 391, 393, 1, 0, 0, 0, 392, 390,
		1, 0, 0, 0, 393, 394, 3, 58, 29, 0, 394, 57, 1, 0, 0, 0, 395, 396, 3, 66,
		33, 0, 396, 59, 1, 0, 0, 0, 397, 398, 7, 5, 0, 0, 398, 61, 1, 0, 0, 0,
		399, 400, 7, 6, 0, 0, 400, 63, 1, 0, 0, 0, 401, 402, 7, 7, 0, 0, 402, 65,
		1, 0, 0, 0, 403, 408, 3, 68, 34, 0, 404, 405, 5, 52, 0, 0, 405, 407, 3,
		68, 34, 0, 406, 404, 1, 0, 0, 0, 407, 410, 1, 0, 0, 0, 408, 406, 1, 0,
		0, 0, 408, 409, 1, 0, 0, 0, 409, 67, 1, 0, 0, 0, 410, 408, 1, 0, 0, 0,
		411, 413, 5, 53, 0, 0, 412, 414, 3, 70, 35, 0, 413, 412, 1, 0, 0, 0, 413,
		414, 1, 0, 0, 0, 414, 419, 1, 0, 0, 0, 415, 416, 5, 54, 0, 0, 416, 419,
		3, 70, 35, 0, 417, 419, 3, 70, 35, 0, 418, 411, 1, 0, 0, 0, 418, 415, 1,
		0, 0, 0, 418, 417, 1, 0, 0, 0, 419, 69, 1, 0, 0, 0, 420, 425, 3, 72, 36,
		0, 421, 422, 7, 8, 0, 0, 422, 424, 3, 72, 36, 0, 423, 421, 1, 0, 0, 0,
		424, 427, 1, 0, 0, 0, 425, 423, 1, 0, 0, 0, 425, 426, 1, 0, 0, 0, 426,
		71, 1, 0, 0, 0, 427, 425, 1, 0, 0, 0, 428, 431, 3, 94, 47, 0, 429, 431,
		3, 74, 37, 0, 430, 428, 1, 0, 0, 0, 430, 429, 1, 0, 0, 0, 431, 73, 1, 0,
		0, 0, 432, 435, 3, 82, 41, 0, 433, 435, 3, 76, 38, 0, 434, 432, 1, 0, 0,
		0, 434, 433, 1, 0, 0, 0, 435, 436, 1, 0, 0, 0, 436, 437, 3, 98, 49, 0,
		437, 75, 1, 0, 0, 0, 438, 439, 3, 78, 39, 0, 439, 440, 3, 88, 44, 0, 440,
		443, 1, 0, 0, 0, 441, 443, 3, 80, 40, 0, 442, 438, 1, 0, 0, 0, 442, 441,
		1, 0, 0, 0, 443, 77, 1, 0, 0, 0, 444, 445, 5, 55, 0, 0, 445, 461, 5, 56,
		0, 0, 446, 447, 5, 57, 0, 0, 447, 461, 5, 56, 0, 0, 448, 449, 5, 58, 0,
		0, 449, 461, 5, 56, 0, 0, 450, 451, 5, 59, 0, 0, 451, 461, 5, 56, 0, 0,
		452, 453, 5, 60, 0, 0, 453, 461, 5, 56, 0, 0, 454, 455, 5, 61, 0, 0, 455,
		461, 5, 56, 0, 0, 456, 457, 5, 62, 0, 0, 457, 461, 5, 56, 0, 0, 458, 459,
		5, 63, 0, 0, 459, 461, 5, 56, 0, 0, 460, 444, 1, 0, 0, 0, 460, 446, 1,
		0, 0, 0, 460, 448, 1, 0, 0, 0, 460, 450, 1, 0, 0, 0, 460, 452, 1, 0, 0,
		0, 460, 454, 1, 0, 0, 0, 460, 456, 1, 0, 0, 0, 460, 458, 1, 0, 0, 0, 461,
		79, 1, 0, 0, 0, 462, 464, 5, 64, 0, 0, 463, 462, 1, 0, 0, 0, 463, 464,
		1, 0, 0, 0, 464, 465, 1, 0, 0, 0, 465, 466, 3, 88, 44, 0, 466, 81, 1, 0,
		0, 0, 467, 468, 3, 84, 42, 0, 468, 469, 3, 88, 44, 0, 469, 472, 1, 0, 0,
		0, 470, 472, 3, 86, 43, 0, 471, 467, 1, 0, 0, 0, 471, 470, 1, 0, 0, 0,
		472, 83, 1, 0, 0, 0, 473, 474, 5, 65, 0, 0, 474, 484, 5, 56, 0, 0, 475,
		476, 5, 66, 0, 0, 476, 484, 5, 56, 0, 0, 477, 478, 5, 67, 0, 0, 478, 484,
		5, 56, 0, 0, 479, 480, 5, 68, 0, 0, 480, 484, 5, 56, 0, 0, 481, 482, 5,
		69, 0, 0, 482, 484, 5, 56, 0, 0, 483, 473, 1, 0, 0, 0, 483, 475, 1, 0,
		0, 0, 483, 477, 1, 0, 0, 0, 483, 479, 1, 0, 0, 0, 483, 481, 1, 0, 0, 0,
		484, 85, 1, 0, 0, 0, 485, 486, 5, 70, 0, 0, 486, 87, 1, 0, 0, 0, 487, 490,
		3, 138, 69, 0, 488, 490, 3, 90, 45, 0, 489, 487, 1, 0, 0, 0, 489, 488,
		1, 0, 0, 0, 490, 89, 1, 0, 0, 0, 491, 494, 3, 184, 92, 0, 492, 494, 3,
		92, 46, 0, 493, 491, 1, 0, 0, 0, 493, 492, 1, 0, 0, 0, 494, 91, 1, 0, 0,
		0, 495, 505, 5, 23, 0, 0, 496, 497, 5, 106, 0, 0, 497, 498, 5, 71, 0, 0,
		498, 505, 5, 23, 0, 0, 499, 500, 5, 23, 0, 0, 500, 501, 5, 71, 0, 0, 501,
		505, 5, 106, 0, 0, 502, 503, 5, 99, 0, 0, 503, 505, 5, 23, 0, 0, 504, 495,
		1, 0, 0, 0, 504, 496, 1, 0, 0, 0, 504, 499, 1, 0, 0, 0, 504, 502, 1, 0,
		0, 0, 505, 93, 1, 0, 0, 0, 506, 511, 3, 102, 51, 0, 507, 510, 3, 100, 50,
		0, 508, 510, 3, 96, 48, 0, 509, 507, 1, 0, 0, 0, 509, 508, 1, 0, 0, 0,
		510, 513, 1, 0, 0, 0, 511, 509, 1, 0, 0, 0, 511, 512, 1, 0, 0, 0, 512,
		95, 1, 0, 0, 0, 513, 511, 1, 0, 0, 0, 514, 523, 5, 14, 0, 0, 515, 520,
		3, 116, 58, 0, 516, 517, 5, 1, 0, 0, 517, 519, 3, 116, 58, 0, 518, 516,
		1, 0, 0, 0, 519, 522, 1, 0, 0, 0, 520, 518, 1, 0, 0, 0, 520, 521, 1, 0,
		0, 0, 521, 524, 1, 0, 0, 0, 522, 520, 1, 0, 0, 0, 523, 515, 1, 0, 0, 0,
		523, 524, 1, 0, 0, 0, 524, 525, 1, 0, 0, 0, 525, 526, 5, 15, 0, 0, 526,
		97, 1, 0, 0, 0, 527, 529, 3, 100, 50, 0, 528, 527, 1, 0, 0, 0, 529, 532,
		1, 0, 0, 0, 530, 528, 1, 0, 0, 0, 530, 531, 1, 0, 0, 0, 531, 99, 1, 0,
		0, 0, 532, 530, 1, 0, 0, 0, 533, 534, 5, 72, 0, 0, 534, 535, 3, 10, 5,
		0, 535, 536, 5, 73, 0, 0, 536, 101, 1, 0, 0, 0, 537, 544, 3, 108, 54, 0,
		538, 544, 3, 104, 52, 0, 539, 544, 3, 110, 55, 0, 540, 544, 3, 112, 56,
		0, 541, 544, 3, 114, 57, 0, 542, 544, 3, 120, 60, 0, 543, 537, 1, 0, 0,
		0, 543, 538, 1, 0, 0, 0, 543, 539, 1, 0, 0, 0, 543, 540, 1, 0, 0, 0, 543,
		541, 1, 0, 0, 0, 543, 542, 1, 0, 0, 0, 544, 103, 1, 0, 0, 0, 545, 546,
		5, 2, 0, 0, 546, 547, 3, 106, 53, 0, 547, 105, 1, 0, 0, 0, 548, 549, 3,
		184, 92, 0, 549, 107, 1, 0, 0, 0, 550, 553, 5, 91, 0, 0, 551, 553, 3, 186,
		93, 0, 552, 550, 1, 0, 0, 0, 552, 551, 1, 0, 0, 0, 553, 109, 1, 0, 0, 0,
		554, 556, 5, 14, 0, 0, 555, 557, 3, 10, 5, 0, 556, 555, 1, 0, 0, 0, 556,
		557, 1, 0, 0, 0, 557, 558, 1, 0, 0, 0, 558, 559, 5, 15, 0, 0, 559, 111,
		1, 0, 0, 0, 560, 561, 5, 74, 0, 0, 561, 113, 1, 0, 0, 0, 562, 563, 3, 184,
		92, 0, 563, 564, 3, 96, 48, 0, 564, 115, 1, 0, 0, 0, 565, 568, 3, 12, 6,
		0, 566, 568, 3, 118, 59, 0, 567, 565, 1, 0, 0, 0, 567, 566, 1, 0, 0, 0,
		568, 117, 1, 0, 0, 0, 569, 570, 5, 75, 0, 0, 570, 119, 1, 0, 0, 0, 571,
		574, 3, 122, 61, 0, 572, 574, 3, 124, 62, 0, 573, 571, 1, 0, 0, 0, 573,
		572, 1, 0, 0, 0, 574, 121, 1, 0, 0, 0, 575, 576, 3, 184, 92, 0, 576, 577,
		5, 76, 0, 0, 577, 578, 5, 92, 0, 0, 578, 123, 1, 0, 0, 0, 579, 580, 5,
		77, 0, 0, 580, 582, 5, 14, 0, 0, 581, 583, 3, 2, 1, 0, 582, 581, 1, 0,
		0, 0, 582, 583, 1, 0, 0, 0, 583, 584, 1, 0, 0, 0, 584, 587, 5, 15, 0, 0,
		585, 586, 5, 34, 0, 0, 586, 588, 3, 130, 65, 0, 587, 585, 1, 0, 0, 0, 587,
		588, 1, 0, 0, 0, 588, 589, 1, 0, 0, 0, 589, 590, 3, 6, 3, 0, 590, 125,
		1, 0, 0, 0, 591, 593, 3, 172, 86, 0, 592, 594, 5, 75, 0, 0, 593, 592, 1,
		0, 0, 0, 593, 594, 1, 0, 0, 0, 594, 127, 1, 0, 0, 0, 595, 596, 5, 34, 0,
		0, 596, 597, 3, 130, 65, 0, 597, 129, 1, 0, 0, 0, 598, 599, 5, 78, 0, 0,
		599, 600, 5, 14, 0, 0, 600, 606, 5, 15, 0, 0, 601, 603, 3, 134, 67, 0,
		602, 604, 3, 132, 66, 0, 603, 602, 1, 0, 0, 0, 603, 604, 1, 0, 0, 0, 604,
		606, 1, 0, 0, 0, 605, 598, 1, 0, 0, 0, 605, 601, 1, 0, 0, 0, 606, 131,
		1, 0, 0, 0, 607, 608, 7, 9, 0, 0, 608, 133, 1, 0, 0, 0, 609, 617, 3, 138,
		69, 0, 610, 611, 5, 79, 0, 0, 611, 612, 5, 14, 0, 0, 612, 617, 5, 15, 0,
		0, 613, 617, 3, 176, 88, 0, 614, 617, 3, 136, 68, 0, 615, 617, 3, 182,
		91, 0, 616, 609, 1, 0, 0, 0, 616, 610, 1, 0, 0, 0, 616, 613, 1, 0, 0, 0,
		616, 614, 1, 0, 0, 0, 616, 615, 1, 0, 0, 0, 617, 135, 1, 0, 0, 0, 618,
		619, 3, 184, 92, 0, 619, 137, 1, 0, 0, 0, 620, 631, 3, 142, 71, 0, 621,
		631, 3, 160, 80, 0, 622, 631, 3, 152, 76, 0, 623, 631, 3, 164, 82, 0, 624,
		631, 3, 156, 78, 0, 625, 631, 3, 150, 75, 0, 626, 631, 3, 146, 73, 0, 627,
		631, 3, 144, 72, 0, 628, 631, 3, 148, 74, 0, 629, 631, 3, 140, 70, 0, 630,
		620, 1, 0, 0, 0, 630, 621, 1, 0, 0, 0, 630, 622, 1, 0, 0, 0, 630, 623,
		1, 0, 0, 0, 630, 624, 1, 0, 0, 0, 630, 625, 1, 0, 0, 0, 630, 626, 1, 0,
		0, 0, 630, 627, 1, 0, 0, 0, 630, 628, 1, 0, 0, 0, 630, 629, 1, 0, 0, 0,
		631, 139, 1, 0, 0, 0, 632, 633, 5, 80, 0, 0, 633, 634, 5, 14, 0, 0, 634,
		635, 5, 15, 0, 0, 635, 141, 1, 0, 0, 0, 636, 637, 5, 81, 0, 0, 637, 640,
		5, 14, 0, 0, 638, 641, 3, 160, 80, 0, 639, 641, 3, 164, 82, 0, 640, 638,
		1, 0, 0, 0, 640, 639, 1, 0, 0, 0, 640, 641, 1, 0, 0, 0, 641, 642, 1, 0,
		0, 0, 642, 643, 5, 15, 0, 0, 643, 143, 1, 0, 0, 0, 644, 645, 5, 82, 0,
		0, 645, 646, 5, 14, 0, 0, 646, 647, 5, 15, 0, 0, 647, 145, 1, 0, 0, 0,
		648, 649, 5, 83, 0, 0, 649, 650, 5, 14, 0, 0, 650, 651, 5, 15, 0, 0, 651,
		147, 1, 0, 0, 0, 652, 653, 5, 84, 0, 0, 653, 654, 5, 14, 0, 0, 654, 655,
		5, 15, 0, 0, 655, 149, 1, 0, 0, 0, 656, 657, 5, 85, 0, 0, 657, 660, 5,
		14, 0, 0, 658, 661, 5, 106, 0, 0, 659, 661, 3, 186, 93, 0, 660, 658, 1,
		0, 0, 0, 660, 659, 1, 0, 0, 0, 660, 661, 1, 0, 0, 0, 661, 662, 1, 0, 0,
		0, 662, 663, 5, 15, 0, 0, 663, 151, 1, 0, 0, 0, 664, 665, 5, 58, 0, 0,
		665, 671, 5, 14, 0, 0, 666, 669, 3, 154, 77, 0, 667, 668, 5, 1, 0, 0, 668,
		670, 3, 174, 87, 0, 669, 667, 1, 0, 0, 0, 669, 670, 1, 0, 0, 0, 670, 672,
		1, 0, 0, 0, 671, 666, 1, 0, 0, 0, 671, 672, 1, 0, 0, 0, 672, 673, 1, 0,
		0, 0, 673, 674, 5, 15, 0, 0, 674, 153, 1, 0, 0, 0, 675, 678, 3, 168, 84,
		0, 676, 678, 5, 23, 0, 0, 677, 675, 1, 0, 0, 0, 677, 676, 1, 0, 0, 0, 678,
		155, 1, 0, 0, 0, 679, 680, 5, 86, 0, 0, 680, 681, 5, 14, 0, 0, 681, 682,
		3, 158, 79, 0, 682, 683, 5, 15, 0, 0, 683, 157, 1, 0, 0, 0, 684, 685, 3,
		168, 84, 0, 685, 159, 1, 0, 0, 0, 686, 687, 5, 87, 0, 0, 687, 696, 5, 14,
		0, 0, 688, 694, 3, 162, 81, 0, 689, 690, 5, 1, 0, 0, 690, 692, 3, 174,
		87, 0, 691, 693, 5, 75, 0, 0, 692, 691, 1, 0, 0, 0, 692, 693, 1, 0, 0,
		0, 693, 695, 1, 0, 0, 0, 694, 689, 1, 0, 0, 0, 694, 695, 1, 0, 0, 0, 695,
		697, 1, 0, 0, 0, 696, 688, 1, 0, 0, 0, 696, 697, 1, 0, 0, 0, 697, 698,
		1, 0, 0, 0, 698, 699, 5, 15, 0, 0, 699, 161, 1, 0, 0, 0, 700, 703, 3, 170,
		85, 0, 701, 703, 5, 23, 0, 0, 702, 700, 1, 0, 0, 0, 702, 701, 1, 0, 0,
		0, 703, 163, 1, 0, 0, 0, 704, 705, 5, 88, 0, 0, 705, 706, 5, 14, 0, 0,
		706, 707, 3, 166, 83, 0, 707, 708, 5, 15, 0, 0, 708, 165, 1, 0, 0, 0, 709,
		710, 3, 170, 85, 0, 710, 167, 1, 0, 0, 0, 711, 712, 3, 184, 92, 0, 712,
		169, 1, 0, 0, 0, 713, 714, 3, 184, 92, 0, 714, 171, 1, 0, 0, 0, 715, 716,
		3, 174, 87, 0, 716, 173, 1, 0, 0, 0, 717, 718, 5, 101, 0, 0, 718, 175,
		1, 0, 0, 0, 719, 722, 3, 178, 89, 0, 720, 722, 3, 180, 90, 0, 721, 719,
		1, 0, 0, 0, 721, 720, 1, 0, 0, 0, 722, 177, 1, 0, 0, 0, 723, 724, 5, 77,
		0, 0, 724, 725, 5, 14, 0, 0, 725, 726, 5, 23, 0, 0, 726, 727, 5, 15, 0,
		0, 727, 179, 1, 0, 0, 0, 728, 729, 5, 77, 0, 0, 729, 738, 5, 14, 0, 0,
		730, 735, 3, 130, 65, 0, 731, 732, 5, 1, 0, 0, 732, 734, 3, 130, 65, 0,
		733, 731, 1, 0, 0, 0, 734, 737, 1, 0, 0, 0, 735, 733, 1, 0, 0, 0, 735,
		736, 1, 0, 0, 0, 736, 739, 1, 0, 0, 0, 737, 735, 1, 0, 0, 0, 738, 730,
		1, 0, 0, 0, 738, 739, 1, 0, 0, 0, 739, 740, 1, 0, 0, 0, 740, 741, 5, 15,
		0, 0, 741, 742, 5, 34, 0, 0, 742, 743, 3, 130, 65, 0, 743, 181, 1, 0, 0,
		0, 744, 745, 5, 14, 0, 0, 745, 746, 3, 134, 67, 0, 746, 747, 5, 15, 0,
		0, 747, 183, 1, 0, 0, 0, 748, 749, 7, 10, 0, 0, 749, 185, 1, 0, 0, 0, 750,
		755, 5, 89, 0, 0, 751, 754, 5, 95, 0, 0, 752, 754, 9, 0, 0, 0, 753, 751,
		1, 0, 0, 0, 753, 752, 1, 0, 0, 0, 754, 757, 1, 0, 0, 0, 755, 756, 1, 0,
		0, 0, 755, 753, 1, 0, 0, 0, 756, 758, 1, 0, 0, 0, 757, 755, 1, 0, 0, 0,
		758, 769, 5, 89, 0, 0, 759, 764, 5, 90, 0, 0, 760, 763, 5, 96, 0, 0, 761,
		763, 9, 0, 0, 0, 762, 760, 1, 0, 0, 0, 762, 761, 1, 0, 0, 0, 763, 766,
		1, 0, 0, 0, 764, 765, 1, 0, 0, 0, 764, 762, 1, 0, 0, 0, 765, 767, 1, 0,
		0, 0, 766, 764, 1, 0, 0, 0, 767, 769, 5, 90, 0, 0, 768, 750, 1, 0, 0, 0,
		768, 759, 1, 0, 0, 0, 769, 187, 1, 0, 0, 0, 70, 196, 202, 215, 223, 235,
		246, 264, 285, 305, 312, 316, 323, 329, 336, 344, 352, 360, 367, 373, 379,
		385, 390, 408, 413, 418, 425, 430, 434, 442, 460, 463, 471, 483, 489, 493,
		504, 509, 511, 520, 523, 530, 543, 552, 556, 567, 573, 582, 587, 593, 603,
		605, 616, 630, 640, 660, 669, 671, 677, 692, 694, 696, 702, 721, 735, 738,
		753, 755, 762, 764, 768,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// XPath3ParserInit initializes any static state used to implement XPath3Parser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewXPath3Parser(). You can call this function if you wish to initialize the static state ahead
// of time.
func XPath3ParserInit() {
	staticData := &XPath3ParserStaticData
	staticData.once.Do(xpath3ParserInit)
}

// NewXPath3Parser produces a new parser instance for the optional input antlr.TokenStream.
func NewXPath3Parser(input antlr.TokenStream) *XPath3Parser {
	XPath3ParserInit()
	this := new(XPath3Parser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &XPath3ParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "XPath3.g"

	return this
}

// XPath3Parser tokens.
const (
	XPath3ParserEOF              = antlr.TokenEOF
	XPath3ParserT__0             = 1
	XPath3ParserT__1             = 2
	XPath3ParserT__2             = 3
	XPath3ParserT__3             = 4
	XPath3ParserT__4             = 5
	XPath3ParserT__5             = 6
	XPath3ParserT__6             = 7
	XPath3ParserT__7             = 8
	XPath3ParserT__8             = 9
	XPath3ParserT__9             = 10
	XPath3ParserT__10            = 11
	XPath3ParserT__11            = 12
	XPath3ParserT__12            = 13
	XPath3ParserT__13            = 14
	XPath3ParserT__14            = 15
	XPath3ParserT__15            = 16
	XPath3ParserT__16            = 17
	XPath3ParserT__17            = 18
	XPath3ParserT__18            = 19
	XPath3ParserT__19            = 20
	XPath3ParserT__20            = 21
	XPath3ParserT__21            = 22
	XPath3ParserT__22            = 23
	XPath3ParserT__23            = 24
	XPath3ParserT__24            = 25
	XPath3ParserT__25            = 26
	XPath3ParserT__26            = 27
	XPath3ParserT__27            = 28
	XPath3ParserT__28            = 29
	XPath3ParserT__29            = 30
	XPath3ParserT__30            = 31
	XPath3ParserT__31            = 32
	XPath3ParserT__32            = 33
	XPath3ParserT__33            = 34
	XPath3ParserT__34            = 35
	XPath3ParserT__35            = 36
	XPath3ParserT__36            = 37
	XPath3ParserT__37            = 38
	XPath3ParserT__38            = 39
	XPath3ParserT__39            = 40
	XPath3ParserT__40            = 41
	XPath3ParserT__41            = 42
	XPath3ParserT__42            = 43
	XPath3ParserT__43            = 44
	XPath3ParserT__44            = 45
	XPath3ParserT__45            = 46
	XPath3ParserT__46            = 47
	XPath3ParserT__47            = 48
	XPath3ParserT__48            = 49
	XPath3ParserT__49            = 50
	XPath3ParserT__50            = 51
	XPath3ParserT__51            = 52
	XPath3ParserT__52            = 53
	XPath3ParserT__53            = 54
	XPath3ParserT__54            = 55
	XPath3ParserT__55            = 56
	XPath3ParserT__56            = 57
	XPath3ParserT__57            = 58
	XPath3ParserT__58            = 59
	XPath3ParserT__59            = 60
	XPath3ParserT__60            = 61
	XPath3ParserT__61            = 62
	XPath3ParserT__62            = 63
	XPath3ParserT__63            = 64
	XPath3ParserT__64            = 65
	XPath3ParserT__65            = 66
	XPath3ParserT__66            = 67
	XPath3ParserT__67            = 68
	XPath3ParserT__68            = 69
	XPath3ParserT__69            = 70
	XPath3ParserT__70            = 71
	XPath3ParserT__71            = 72
	XPath3ParserT__72            = 73
	XPath3ParserT__73            = 74
	XPath3ParserT__74            = 75
	XPath3ParserT__75            = 76
	XPath3ParserT__76            = 77
	XPath3ParserT__77            = 78
	XPath3ParserT__78            = 79
	XPath3ParserT__79            = 80
	XPath3ParserT__80            = 81
	XPath3ParserT__81            = 82
	XPath3ParserT__82            = 83
	XPath3ParserT__83            = 84
	XPath3ParserT__84            = 85
	XPath3ParserT__85            = 86
	XPath3ParserT__86            = 87
	XPath3ParserT__87            = 88
	XPath3ParserT__88            = 89
	XPath3ParserT__89            = 90
	XPath3ParserNumericLiteral   = 91
	XPath3ParserIntegerLiteral   = 92
	XPath3ParserDecimalLiteral   = 93
	XPath3ParserDoubleLiteral    = 94
	XPath3ParserESCAPE_QUOTE     = 95
	XPath3ParserESCAPE_APOS      = 96
	XPath3ParserURIQualifiedName = 97
	XPath3ParserComment          = 98
	XPath3ParserBracedURILiteral = 99
	XPath3ParserCommentContents  = 100
	XPath3ParserQNAME            = 101
	XPath3ParserPREFIXED_NAME    = 102
	XPath3ParserUNPREFIXED_NAME  = 103
	XPath3ParserPREFIX           = 104
	XPath3ParserLOCAL_PART       = 105
	XPath3ParserNC_NAME          = 106
	XPath3ParserCHAR             = 107
	XPath3ParserDIGITS           = 108
)

// XPath3Parser rules.
const (
	XPath3ParserRULE_xPath                 = 0
	XPath3ParserRULE_paramList             = 1
	XPath3ParserRULE_param                 = 2
	XPath3ParserRULE_functionBody          = 3
	XPath3ParserRULE_enclosedExpr          = 4
	XPath3ParserRULE_expr                  = 5
	XPath3ParserRULE_exprSingle            = 6
	XPath3ParserRULE_forExpr               = 7
	XPath3ParserRULE_simpleForClause       = 8
	XPath3ParserRULE_forBindingList        = 9
	XPath3ParserRULE_simpleForBinding      = 10
	XPath3ParserRULE_letExpr               = 11
	XPath3ParserRULE_simpleLetClause       = 12
	XPath3ParserRULE_simpleLetBinding      = 13
	XPath3ParserRULE_quantifiedExpr        = 14
	XPath3ParserRULE_ifExpr                = 15
	XPath3ParserRULE_orExpr                = 16
	XPath3ParserRULE_andExpr               = 17
	XPath3ParserRULE_stringConcatexpr      = 18
	XPath3ParserRULE_rangeExpr             = 19
	XPath3ParserRULE_additiveExpr          = 20
	XPath3ParserRULE_multiplicativeExpr    = 21
	XPath3ParserRULE_unionExpr             = 22
	XPath3ParserRULE_intersectExceptExpr   = 23
	XPath3ParserRULE_instanceofExpr        = 24
	XPath3ParserRULE_treatExpr             = 25
	XPath3ParserRULE_castableExpr          = 26
	XPath3ParserRULE_castExpr              = 27
	XPath3ParserRULE_unaryExpr             = 28
	XPath3ParserRULE_valueExpr             = 29
	XPath3ParserRULE_generalComp           = 30
	XPath3ParserRULE_valueComp             = 31
	XPath3ParserRULE_nodeComp              = 32
	XPath3ParserRULE_simpleMapExpr         = 33
	XPath3ParserRULE_pathExpr              = 34
	XPath3ParserRULE_relativePathExpr      = 35
	XPath3ParserRULE_stepExpr              = 36
	XPath3ParserRULE_axisStep              = 37
	XPath3ParserRULE_forwardStep           = 38
	XPath3ParserRULE_forwardAxis           = 39
	XPath3ParserRULE_abbrevForwardStep     = 40
	XPath3ParserRULE_reverseStep           = 41
	XPath3ParserRULE_reverseAxis           = 42
	XPath3ParserRULE_abbrevReverseStep     = 43
	XPath3ParserRULE_nodeTest              = 44
	XPath3ParserRULE_nameTest              = 45
	XPath3ParserRULE_wildCard              = 46
	XPath3ParserRULE_postfixExpr           = 47
	XPath3ParserRULE_argumentList          = 48
	XPath3ParserRULE_predicateList         = 49
	XPath3ParserRULE_predicate             = 50
	XPath3ParserRULE_primaryExpr           = 51
	XPath3ParserRULE_varRef                = 52
	XPath3ParserRULE_varName               = 53
	XPath3ParserRULE_literal               = 54
	XPath3ParserRULE_parenthesizedExpr     = 55
	XPath3ParserRULE_contextItemExpr       = 56
	XPath3ParserRULE_functionCall          = 57
	XPath3ParserRULE_argument              = 58
	XPath3ParserRULE_argumentPlaceholder   = 59
	XPath3ParserRULE_functionItemExpr      = 60
	XPath3ParserRULE_namedFunctionRef      = 61
	XPath3ParserRULE_inlineFunctionExpr    = 62
	XPath3ParserRULE_singleType            = 63
	XPath3ParserRULE_type_declaration      = 64
	XPath3ParserRULE_sequenceType          = 65
	XPath3ParserRULE_occurenceIndicator    = 66
	XPath3ParserRULE_itemType              = 67
	XPath3ParserRULE_atomicOrUnionType     = 68
	XPath3ParserRULE_kindTest              = 69
	XPath3ParserRULE_anyKindTest           = 70
	XPath3ParserRULE_documentTest          = 71
	XPath3ParserRULE_textTest              = 72
	XPath3ParserRULE_commentTest           = 73
	XPath3ParserRULE_namespaceNodeTest     = 74
	XPath3ParserRULE_piTest                = 75
	XPath3ParserRULE_attributeTest         = 76
	XPath3ParserRULE_attribNameOrWildcard  = 77
	XPath3ParserRULE_schemaAttributeTest   = 78
	XPath3ParserRULE_attributeDeclaration  = 79
	XPath3ParserRULE_elementTest           = 80
	XPath3ParserRULE_elementNameOrWildcard = 81
	XPath3ParserRULE_schemaElementTest     = 82
	XPath3ParserRULE_elementDeclaration    = 83
	XPath3ParserRULE_attributeName         = 84
	XPath3ParserRULE_elementName           = 85
	XPath3ParserRULE_simpleTypeName        = 86
	XPath3ParserRULE_typeName              = 87
	XPath3ParserRULE_functionTest          = 88
	XPath3ParserRULE_anyFunctionTest       = 89
	XPath3ParserRULE_typedFunctionTest     = 90
	XPath3ParserRULE_parenthesizedItemType = 91
	XPath3ParserRULE_eqName                = 92
	XPath3ParserRULE_stringLiteral         = 93
)

// IXPathContext is an interface to support dynamic dispatch.
type IXPathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	EOF() antlr.TerminalNode

	// IsXPathContext differentiates from other interfaces.
	IsXPathContext()
}

type XPathContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXPathContext() *XPathContext {
	var p = new(XPathContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_xPath
	return p
}

func InitEmptyXPathContext(p *XPathContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_xPath
}

func (*XPathContext) IsXPathContext() {}

func NewXPathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XPathContext {
	var p = new(XPathContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_xPath

	return p
}

func (s *XPathContext) GetParser() antlr.Parser { return s.parser }

func (s *XPathContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *XPathContext) EOF() antlr.TerminalNode {
	return s.GetToken(XPath3ParserEOF, 0)
}

func (s *XPathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XPathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *XPathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterXPath(s)
	}
}

func (s *XPathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitXPath(s)
	}
}

func (p *XPath3Parser) XPath() (localctx IXPathContext) {
	localctx = NewXPathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, XPath3ParserRULE_xPath)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(188)
		p.Expr()
	}
	{
		p.SetState(189)
		p.Match(XPath3ParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParamListContext is an interface to support dynamic dispatch.
type IParamListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllParam() []IParamContext
	Param(i int) IParamContext

	// IsParamListContext differentiates from other interfaces.
	IsParamListContext()
}

type ParamListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParamListContext() *ParamListContext {
	var p = new(ParamListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_paramList
	return p
}

func InitEmptyParamListContext(p *ParamListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_paramList
}

func (*ParamListContext) IsParamListContext() {}

func NewParamListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamListContext {
	var p = new(ParamListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_paramList

	return p
}

func (s *ParamListContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamListContext) AllParam() []IParamContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParamContext); ok {
			len++
		}
	}

	tst := make([]IParamContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParamContext); ok {
			tst[i] = t.(IParamContext)
			i++
		}
	}

	return tst
}

func (s *ParamListContext) Param(i int) IParamContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParamContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParamContext)
}

func (s *ParamListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParamListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterParamList(s)
	}
}

func (s *ParamListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitParamList(s)
	}
}

func (p *XPath3Parser) ParamList() (localctx IParamListContext) {
	localctx = NewParamListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, XPath3ParserRULE_paramList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(191)
		p.Param()
	}
	p.SetState(196)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == XPath3ParserT__0 {
		{
			p.SetState(192)
			p.Match(XPath3ParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(193)
			p.Param()
		}

		p.SetState(198)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParamContext is an interface to support dynamic dispatch.
type IParamContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EqName() IEqNameContext
	Type_declaration() IType_declarationContext

	// IsParamContext differentiates from other interfaces.
	IsParamContext()
}

type ParamContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParamContext() *ParamContext {
	var p = new(ParamContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_param
	return p
}

func InitEmptyParamContext(p *ParamContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_param
}

func (*ParamContext) IsParamContext() {}

func NewParamContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamContext {
	var p = new(ParamContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_param

	return p
}

func (s *ParamContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamContext) EqName() IEqNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqNameContext)
}

func (s *ParamContext) Type_declaration() IType_declarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_declarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_declarationContext)
}

func (s *ParamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterParam(s)
	}
}

func (s *ParamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitParam(s)
	}
}

func (p *XPath3Parser) Param() (localctx IParamContext) {
	localctx = NewParamContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, XPath3ParserRULE_param)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(199)
		p.Match(XPath3ParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(200)
		p.EqName()
	}
	p.SetState(202)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == XPath3ParserT__33 {
		{
			p.SetState(201)
			p.Type_declaration()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionBodyContext is an interface to support dynamic dispatch.
type IFunctionBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EnclosedExpr() IEnclosedExprContext

	// IsFunctionBodyContext differentiates from other interfaces.
	IsFunctionBodyContext()
}

type FunctionBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionBodyContext() *FunctionBodyContext {
	var p = new(FunctionBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_functionBody
	return p
}

func InitEmptyFunctionBodyContext(p *FunctionBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_functionBody
}

func (*FunctionBodyContext) IsFunctionBodyContext() {}

func NewFunctionBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionBodyContext {
	var p = new(FunctionBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_functionBody

	return p
}

func (s *FunctionBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionBodyContext) EnclosedExpr() IEnclosedExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnclosedExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnclosedExprContext)
}

func (s *FunctionBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterFunctionBody(s)
	}
}

func (s *FunctionBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitFunctionBody(s)
	}
}

func (p *XPath3Parser) FunctionBody() (localctx IFunctionBodyContext) {
	localctx = NewFunctionBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, XPath3ParserRULE_functionBody)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(204)
		p.EnclosedExpr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnclosedExprContext is an interface to support dynamic dispatch.
type IEnclosedExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext

	// IsEnclosedExprContext differentiates from other interfaces.
	IsEnclosedExprContext()
}

type EnclosedExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnclosedExprContext() *EnclosedExprContext {
	var p = new(EnclosedExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_enclosedExpr
	return p
}

func InitEmptyEnclosedExprContext(p *EnclosedExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_enclosedExpr
}

func (*EnclosedExprContext) IsEnclosedExprContext() {}

func NewEnclosedExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnclosedExprContext {
	var p = new(EnclosedExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_enclosedExpr

	return p
}

func (s *EnclosedExprContext) GetParser() antlr.Parser { return s.parser }

func (s *EnclosedExprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *EnclosedExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnclosedExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnclosedExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterEnclosedExpr(s)
	}
}

func (s *EnclosedExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitEnclosedExpr(s)
	}
}

func (p *XPath3Parser) EnclosedExpr() (localctx IEnclosedExprContext) {
	localctx = NewEnclosedExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, XPath3ParserRULE_enclosedExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(206)
		p.Match(XPath3ParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(207)
		p.Expr()
	}
	{
		p.SetState(208)
		p.Match(XPath3ParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExprSingle() []IExprSingleContext
	ExprSingle(i int) IExprSingleContext

	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_expr
	return p
}

func InitEmptyExprContext(p *ExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_expr
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) AllExprSingle() []IExprSingleContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprSingleContext); ok {
			len++
		}
	}

	tst := make([]IExprSingleContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprSingleContext); ok {
			tst[i] = t.(IExprSingleContext)
			i++
		}
	}

	return tst
}

func (s *ExprContext) ExprSingle(i int) IExprSingleContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprSingleContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprSingleContext)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterExpr(s)
	}
}

func (s *ExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitExpr(s)
	}
}

func (p *XPath3Parser) Expr() (localctx IExprContext) {
	localctx = NewExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, XPath3ParserRULE_expr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(210)
		p.ExprSingle()
	}
	p.SetState(215)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == XPath3ParserT__0 {
		{
			p.SetState(211)
			p.Match(XPath3ParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(212)
			p.ExprSingle()
		}

		p.SetState(217)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprSingleContext is an interface to support dynamic dispatch.
type IExprSingleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ForExpr() IForExprContext
	LetExpr() ILetExprContext
	QuantifiedExpr() IQuantifiedExprContext
	IfExpr() IIfExprContext
	OrExpr() IOrExprContext

	// IsExprSingleContext differentiates from other interfaces.
	IsExprSingleContext()
}

type ExprSingleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprSingleContext() *ExprSingleContext {
	var p = new(ExprSingleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_exprSingle
	return p
}

func InitEmptyExprSingleContext(p *ExprSingleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_exprSingle
}

func (*ExprSingleContext) IsExprSingleContext() {}

func NewExprSingleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprSingleContext {
	var p = new(ExprSingleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_exprSingle

	return p
}

func (s *ExprSingleContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprSingleContext) ForExpr() IForExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForExprContext)
}

func (s *ExprSingleContext) LetExpr() ILetExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetExprContext)
}

func (s *ExprSingleContext) QuantifiedExpr() IQuantifiedExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuantifiedExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuantifiedExprContext)
}

func (s *ExprSingleContext) IfExpr() IIfExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExprContext)
}

func (s *ExprSingleContext) OrExpr() IOrExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrExprContext)
}

func (s *ExprSingleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprSingleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprSingleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterExprSingle(s)
	}
}

func (s *ExprSingleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitExprSingle(s)
	}
}

func (p *XPath3Parser) ExprSingle() (localctx IExprSingleContext) {
	localctx = NewExprSingleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, XPath3ParserRULE_exprSingle)
	p.SetState(223)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserT__5:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(218)
			p.ForExpr()
		}

	case XPath3ParserT__7:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(219)
			p.LetExpr()
		}

	case XPath3ParserT__9, XPath3ParserT__10:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(220)
			p.QuantifiedExpr()
		}

	case XPath3ParserT__12:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(221)
			p.IfExpr()
		}

	case XPath3ParserT__1, XPath3ParserT__13, XPath3ParserT__20, XPath3ParserT__21, XPath3ParserT__22, XPath3ParserT__52, XPath3ParserT__53, XPath3ParserT__54, XPath3ParserT__56, XPath3ParserT__57, XPath3ParserT__58, XPath3ParserT__59, XPath3ParserT__60, XPath3ParserT__61, XPath3ParserT__62, XPath3ParserT__63, XPath3ParserT__64, XPath3ParserT__65, XPath3ParserT__66, XPath3ParserT__67, XPath3ParserT__68, XPath3ParserT__69, XPath3ParserT__73, XPath3ParserT__76, XPath3ParserT__79, XPath3ParserT__80, XPath3ParserT__81, XPath3ParserT__82, XPath3ParserT__83, XPath3ParserT__84, XPath3ParserT__85, XPath3ParserT__86, XPath3ParserT__87, XPath3ParserT__88, XPath3ParserT__89, XPath3ParserNumericLiteral, XPath3ParserURIQualifiedName, XPath3ParserBracedURILiteral, XPath3ParserQNAME, XPath3ParserNC_NAME:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(222)
			p.OrExpr()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForExprContext is an interface to support dynamic dispatch.
type IForExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleForClause() ISimpleForClauseContext
	ExprSingle() IExprSingleContext

	// IsForExprContext differentiates from other interfaces.
	IsForExprContext()
}

type ForExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForExprContext() *ForExprContext {
	var p = new(ForExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_forExpr
	return p
}

func InitEmptyForExprContext(p *ForExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_forExpr
}

func (*ForExprContext) IsForExprContext() {}

func NewForExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForExprContext {
	var p = new(ForExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_forExpr

	return p
}

func (s *ForExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ForExprContext) SimpleForClause() ISimpleForClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleForClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleForClauseContext)
}

func (s *ForExprContext) ExprSingle() IExprSingleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprSingleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprSingleContext)
}

func (s *ForExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterForExpr(s)
	}
}

func (s *ForExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitForExpr(s)
	}
}

func (p *XPath3Parser) ForExpr() (localctx IForExprContext) {
	localctx = NewForExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, XPath3ParserRULE_forExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(225)
		p.SimpleForClause()
	}
	{
		p.SetState(226)
		p.Match(XPath3ParserT__4)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(227)
		p.ExprSingle()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleForClauseContext is an interface to support dynamic dispatch.
type ISimpleForClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSimpleForBinding() []ISimpleForBindingContext
	SimpleForBinding(i int) ISimpleForBindingContext

	// IsSimpleForClauseContext differentiates from other interfaces.
	IsSimpleForClauseContext()
}

type SimpleForClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleForClauseContext() *SimpleForClauseContext {
	var p = new(SimpleForClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_simpleForClause
	return p
}

func InitEmptySimpleForClauseContext(p *SimpleForClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_simpleForClause
}

func (*SimpleForClauseContext) IsSimpleForClauseContext() {}

func NewSimpleForClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleForClauseContext {
	var p = new(SimpleForClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_simpleForClause

	return p
}

func (s *SimpleForClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleForClauseContext) AllSimpleForBinding() []ISimpleForBindingContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISimpleForBindingContext); ok {
			len++
		}
	}

	tst := make([]ISimpleForBindingContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISimpleForBindingContext); ok {
			tst[i] = t.(ISimpleForBindingContext)
			i++
		}
	}

	return tst
}

func (s *SimpleForClauseContext) SimpleForBinding(i int) ISimpleForBindingContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleForBindingContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleForBindingContext)
}

func (s *SimpleForClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleForClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleForClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterSimpleForClause(s)
	}
}

func (s *SimpleForClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitSimpleForClause(s)
	}
}

func (p *XPath3Parser) SimpleForClause() (localctx ISimpleForClauseContext) {
	localctx = NewSimpleForClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, XPath3ParserRULE_simpleForClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(229)
		p.Match(XPath3ParserT__5)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(230)
		p.SimpleForBinding()
	}
	p.SetState(235)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == XPath3ParserT__0 {
		{
			p.SetState(231)
			p.Match(XPath3ParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(232)
			p.SimpleForBinding()
		}

		p.SetState(237)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForBindingListContext is an interface to support dynamic dispatch.
type IForBindingListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleForBinding() ISimpleForBindingContext
	ForBindingList() IForBindingListContext

	// IsForBindingListContext differentiates from other interfaces.
	IsForBindingListContext()
}

type ForBindingListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForBindingListContext() *ForBindingListContext {
	var p = new(ForBindingListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_forBindingList
	return p
}

func InitEmptyForBindingListContext(p *ForBindingListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_forBindingList
}

func (*ForBindingListContext) IsForBindingListContext() {}

func NewForBindingListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForBindingListContext {
	var p = new(ForBindingListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_forBindingList

	return p
}

func (s *ForBindingListContext) GetParser() antlr.Parser { return s.parser }

func (s *ForBindingListContext) SimpleForBinding() ISimpleForBindingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleForBindingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleForBindingContext)
}

func (s *ForBindingListContext) ForBindingList() IForBindingListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForBindingListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForBindingListContext)
}

func (s *ForBindingListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForBindingListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForBindingListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterForBindingList(s)
	}
}

func (s *ForBindingListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitForBindingList(s)
	}
}

func (p *XPath3Parser) ForBindingList() (localctx IForBindingListContext) {
	return p.forBindingList(0)
}

func (p *XPath3Parser) forBindingList(_p int) (localctx IForBindingListContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewForBindingListContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IForBindingListContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 18
	p.EnterRecursionRule(localctx, 18, XPath3ParserRULE_forBindingList, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(239)
		p.SimpleForBinding()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(246)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewForBindingListContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, XPath3ParserRULE_forBindingList)
			p.SetState(241)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(242)
				p.Match(XPath3ParserT__0)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(243)
				p.SimpleForBinding()
			}

		}
		p.SetState(248)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleForBindingContext is an interface to support dynamic dispatch.
type ISimpleForBindingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VarName() IVarNameContext
	ExprSingle() IExprSingleContext

	// IsSimpleForBindingContext differentiates from other interfaces.
	IsSimpleForBindingContext()
}

type SimpleForBindingContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleForBindingContext() *SimpleForBindingContext {
	var p = new(SimpleForBindingContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_simpleForBinding
	return p
}

func InitEmptySimpleForBindingContext(p *SimpleForBindingContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_simpleForBinding
}

func (*SimpleForBindingContext) IsSimpleForBindingContext() {}

func NewSimpleForBindingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleForBindingContext {
	var p = new(SimpleForBindingContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_simpleForBinding

	return p
}

func (s *SimpleForBindingContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleForBindingContext) VarName() IVarNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarNameContext)
}

func (s *SimpleForBindingContext) ExprSingle() IExprSingleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprSingleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprSingleContext)
}

func (s *SimpleForBindingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleForBindingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleForBindingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterSimpleForBinding(s)
	}
}

func (s *SimpleForBindingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitSimpleForBinding(s)
	}
}

func (p *XPath3Parser) SimpleForBinding() (localctx ISimpleForBindingContext) {
	localctx = NewSimpleForBindingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, XPath3ParserRULE_simpleForBinding)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(249)
		p.Match(XPath3ParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(250)
		p.VarName()
	}
	{
		p.SetState(251)
		p.Match(XPath3ParserT__6)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(252)
		p.ExprSingle()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetExprContext is an interface to support dynamic dispatch.
type ILetExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleLetClause() ISimpleLetClauseContext
	ExprSingle() IExprSingleContext

	// IsLetExprContext differentiates from other interfaces.
	IsLetExprContext()
}

type LetExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetExprContext() *LetExprContext {
	var p = new(LetExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_letExpr
	return p
}

func InitEmptyLetExprContext(p *LetExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_letExpr
}

func (*LetExprContext) IsLetExprContext() {}

func NewLetExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetExprContext {
	var p = new(LetExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_letExpr

	return p
}

func (s *LetExprContext) GetParser() antlr.Parser { return s.parser }

func (s *LetExprContext) SimpleLetClause() ISimpleLetClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleLetClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleLetClauseContext)
}

func (s *LetExprContext) ExprSingle() IExprSingleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprSingleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprSingleContext)
}

func (s *LetExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterLetExpr(s)
	}
}

func (s *LetExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitLetExpr(s)
	}
}

func (p *XPath3Parser) LetExpr() (localctx ILetExprContext) {
	localctx = NewLetExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, XPath3ParserRULE_letExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(254)
		p.SimpleLetClause()
	}
	{
		p.SetState(255)
		p.Match(XPath3ParserT__4)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(256)
		p.ExprSingle()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleLetClauseContext is an interface to support dynamic dispatch.
type ISimpleLetClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSimpleLetBinding() []ISimpleLetBindingContext
	SimpleLetBinding(i int) ISimpleLetBindingContext

	// IsSimpleLetClauseContext differentiates from other interfaces.
	IsSimpleLetClauseContext()
}

type SimpleLetClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleLetClauseContext() *SimpleLetClauseContext {
	var p = new(SimpleLetClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_simpleLetClause
	return p
}

func InitEmptySimpleLetClauseContext(p *SimpleLetClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_simpleLetClause
}

func (*SimpleLetClauseContext) IsSimpleLetClauseContext() {}

func NewSimpleLetClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleLetClauseContext {
	var p = new(SimpleLetClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_simpleLetClause

	return p
}

func (s *SimpleLetClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleLetClauseContext) AllSimpleLetBinding() []ISimpleLetBindingContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISimpleLetBindingContext); ok {
			len++
		}
	}

	tst := make([]ISimpleLetBindingContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISimpleLetBindingContext); ok {
			tst[i] = t.(ISimpleLetBindingContext)
			i++
		}
	}

	return tst
}

func (s *SimpleLetClauseContext) SimpleLetBinding(i int) ISimpleLetBindingContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleLetBindingContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleLetBindingContext)
}

func (s *SimpleLetClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleLetClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleLetClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterSimpleLetClause(s)
	}
}

func (s *SimpleLetClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitSimpleLetClause(s)
	}
}

func (p *XPath3Parser) SimpleLetClause() (localctx ISimpleLetClauseContext) {
	localctx = NewSimpleLetClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, XPath3ParserRULE_simpleLetClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(258)
		p.Match(XPath3ParserT__7)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(259)
		p.SimpleLetBinding()
	}
	p.SetState(264)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == XPath3ParserT__0 {
		{
			p.SetState(260)
			p.Match(XPath3ParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(261)
			p.SimpleLetBinding()
		}

		p.SetState(266)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleLetBindingContext is an interface to support dynamic dispatch.
type ISimpleLetBindingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VarName() IVarNameContext
	ExprSingle() IExprSingleContext

	// IsSimpleLetBindingContext differentiates from other interfaces.
	IsSimpleLetBindingContext()
}

type SimpleLetBindingContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleLetBindingContext() *SimpleLetBindingContext {
	var p = new(SimpleLetBindingContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_simpleLetBinding
	return p
}

func InitEmptySimpleLetBindingContext(p *SimpleLetBindingContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_simpleLetBinding
}

func (*SimpleLetBindingContext) IsSimpleLetBindingContext() {}

func NewSimpleLetBindingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleLetBindingContext {
	var p = new(SimpleLetBindingContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_simpleLetBinding

	return p
}

func (s *SimpleLetBindingContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleLetBindingContext) VarName() IVarNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarNameContext)
}

func (s *SimpleLetBindingContext) ExprSingle() IExprSingleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprSingleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprSingleContext)
}

func (s *SimpleLetBindingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleLetBindingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleLetBindingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterSimpleLetBinding(s)
	}
}

func (s *SimpleLetBindingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitSimpleLetBinding(s)
	}
}

func (p *XPath3Parser) SimpleLetBinding() (localctx ISimpleLetBindingContext) {
	localctx = NewSimpleLetBindingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, XPath3ParserRULE_simpleLetBinding)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(267)
		p.Match(XPath3ParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(268)
		p.VarName()
	}
	{
		p.SetState(269)
		p.Match(XPath3ParserT__8)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(270)
		p.ExprSingle()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQuantifiedExprContext is an interface to support dynamic dispatch.
type IQuantifiedExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllVarName() []IVarNameContext
	VarName(i int) IVarNameContext
	AllExprSingle() []IExprSingleContext
	ExprSingle(i int) IExprSingleContext

	// IsQuantifiedExprContext differentiates from other interfaces.
	IsQuantifiedExprContext()
}

type QuantifiedExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuantifiedExprContext() *QuantifiedExprContext {
	var p = new(QuantifiedExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_quantifiedExpr
	return p
}

func InitEmptyQuantifiedExprContext(p *QuantifiedExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_quantifiedExpr
}

func (*QuantifiedExprContext) IsQuantifiedExprContext() {}

func NewQuantifiedExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuantifiedExprContext {
	var p = new(QuantifiedExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_quantifiedExpr

	return p
}

func (s *QuantifiedExprContext) GetParser() antlr.Parser { return s.parser }

func (s *QuantifiedExprContext) AllVarName() []IVarNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVarNameContext); ok {
			len++
		}
	}

	tst := make([]IVarNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVarNameContext); ok {
			tst[i] = t.(IVarNameContext)
			i++
		}
	}

	return tst
}

func (s *QuantifiedExprContext) VarName(i int) IVarNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarNameContext)
}

func (s *QuantifiedExprContext) AllExprSingle() []IExprSingleContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprSingleContext); ok {
			len++
		}
	}

	tst := make([]IExprSingleContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprSingleContext); ok {
			tst[i] = t.(IExprSingleContext)
			i++
		}
	}

	return tst
}

func (s *QuantifiedExprContext) ExprSingle(i int) IExprSingleContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprSingleContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprSingleContext)
}

func (s *QuantifiedExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuantifiedExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuantifiedExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterQuantifiedExpr(s)
	}
}

func (s *QuantifiedExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitQuantifiedExpr(s)
	}
}

func (p *XPath3Parser) QuantifiedExpr() (localctx IQuantifiedExprContext) {
	localctx = NewQuantifiedExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, XPath3ParserRULE_quantifiedExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(272)
		_la = p.GetTokenStream().LA(1)

		if !(_la == XPath3ParserT__9 || _la == XPath3ParserT__10) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(273)
		p.Match(XPath3ParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(274)
		p.VarName()
	}
	{
		p.SetState(275)
		p.Match(XPath3ParserT__6)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(276)
		p.ExprSingle()
	}
	p.SetState(285)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == XPath3ParserT__0 {
		{
			p.SetState(277)
			p.Match(XPath3ParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(278)
			p.Match(XPath3ParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(279)
			p.VarName()
		}
		{
			p.SetState(280)
			p.Match(XPath3ParserT__6)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(281)
			p.ExprSingle()
		}

		p.SetState(287)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(288)
		p.Match(XPath3ParserT__11)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(289)
		p.ExprSingle()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfExprContext is an interface to support dynamic dispatch.
type IIfExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	AllExprSingle() []IExprSingleContext
	ExprSingle(i int) IExprSingleContext

	// IsIfExprContext differentiates from other interfaces.
	IsIfExprContext()
}

type IfExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfExprContext() *IfExprContext {
	var p = new(IfExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_ifExpr
	return p
}

func InitEmptyIfExprContext(p *IfExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_ifExpr
}

func (*IfExprContext) IsIfExprContext() {}

func NewIfExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfExprContext {
	var p = new(IfExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_ifExpr

	return p
}

func (s *IfExprContext) GetParser() antlr.Parser { return s.parser }

func (s *IfExprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *IfExprContext) AllExprSingle() []IExprSingleContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprSingleContext); ok {
			len++
		}
	}

	tst := make([]IExprSingleContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprSingleContext); ok {
			tst[i] = t.(IExprSingleContext)
			i++
		}
	}

	return tst
}

func (s *IfExprContext) ExprSingle(i int) IExprSingleContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprSingleContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprSingleContext)
}

func (s *IfExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterIfExpr(s)
	}
}

func (s *IfExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitIfExpr(s)
	}
}

func (p *XPath3Parser) IfExpr() (localctx IIfExprContext) {
	localctx = NewIfExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, XPath3ParserRULE_ifExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(291)
		p.Match(XPath3ParserT__12)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(292)
		p.Match(XPath3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(293)
		p.Expr()
	}
	{
		p.SetState(294)
		p.Match(XPath3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(295)
		p.Match(XPath3ParserT__15)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(296)
		p.ExprSingle()
	}
	{
		p.SetState(297)
		p.Match(XPath3ParserT__16)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(298)
		p.ExprSingle()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrExprContext is an interface to support dynamic dispatch.
type IOrExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAndExpr() []IAndExprContext
	AndExpr(i int) IAndExprContext

	// IsOrExprContext differentiates from other interfaces.
	IsOrExprContext()
}

type OrExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrExprContext() *OrExprContext {
	var p = new(OrExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_orExpr
	return p
}

func InitEmptyOrExprContext(p *OrExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_orExpr
}

func (*OrExprContext) IsOrExprContext() {}

func NewOrExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrExprContext {
	var p = new(OrExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_orExpr

	return p
}

func (s *OrExprContext) GetParser() antlr.Parser { return s.parser }

func (s *OrExprContext) AllAndExpr() []IAndExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAndExprContext); ok {
			len++
		}
	}

	tst := make([]IAndExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAndExprContext); ok {
			tst[i] = t.(IAndExprContext)
			i++
		}
	}

	return tst
}

func (s *OrExprContext) AndExpr(i int) IAndExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAndExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAndExprContext)
}

func (s *OrExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterOrExpr(s)
	}
}

func (s *OrExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitOrExpr(s)
	}
}

func (p *XPath3Parser) OrExpr() (localctx IOrExprContext) {
	localctx = NewOrExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, XPath3ParserRULE_orExpr)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(300)
		p.AndExpr()
	}
	p.SetState(305)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 8, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(301)
				p.Match(XPath3ParserT__17)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(302)
				p.AndExpr()
			}

		}
		p.SetState(307)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 8, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAndExprContext is an interface to support dynamic dispatch.
type IAndExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllStringConcatexpr() []IStringConcatexprContext
	StringConcatexpr(i int) IStringConcatexprContext
	ValueComp() IValueCompContext
	GeneralComp() IGeneralCompContext
	NodeComp() INodeCompContext

	// IsAndExprContext differentiates from other interfaces.
	IsAndExprContext()
}

type AndExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAndExprContext() *AndExprContext {
	var p = new(AndExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_andExpr
	return p
}

func InitEmptyAndExprContext(p *AndExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_andExpr
}

func (*AndExprContext) IsAndExprContext() {}

func NewAndExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AndExprContext {
	var p = new(AndExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_andExpr

	return p
}

func (s *AndExprContext) GetParser() antlr.Parser { return s.parser }

func (s *AndExprContext) AllStringConcatexpr() []IStringConcatexprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringConcatexprContext); ok {
			len++
		}
	}

	tst := make([]IStringConcatexprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringConcatexprContext); ok {
			tst[i] = t.(IStringConcatexprContext)
			i++
		}
	}

	return tst
}

func (s *AndExprContext) StringConcatexpr(i int) IStringConcatexprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringConcatexprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringConcatexprContext)
}

func (s *AndExprContext) ValueComp() IValueCompContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueCompContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueCompContext)
}

func (s *AndExprContext) GeneralComp() IGeneralCompContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGeneralCompContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGeneralCompContext)
}

func (s *AndExprContext) NodeComp() INodeCompContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeCompContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeCompContext)
}

func (s *AndExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AndExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AndExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterAndExpr(s)
	}
}

func (s *AndExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitAndExpr(s)
	}
}

func (p *XPath3Parser) AndExpr() (localctx IAndExprContext) {
	localctx = NewAndExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, XPath3ParserRULE_andExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(308)
		p.StringConcatexpr()
	}
	p.SetState(316)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext()) == 1 {
		p.SetState(312)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case XPath3ParserT__42, XPath3ParserT__43, XPath3ParserT__44, XPath3ParserT__45, XPath3ParserT__46, XPath3ParserT__47:
			{
				p.SetState(309)
				p.ValueComp()
			}

		case XPath3ParserT__36, XPath3ParserT__37, XPath3ParserT__38, XPath3ParserT__39, XPath3ParserT__40, XPath3ParserT__41:
			{
				p.SetState(310)
				p.GeneralComp()
			}

		case XPath3ParserT__48, XPath3ParserT__49, XPath3ParserT__50:
			{
				p.SetState(311)
				p.NodeComp()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(314)
			p.StringConcatexpr()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringConcatexprContext is an interface to support dynamic dispatch.
type IStringConcatexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRangeExpr() []IRangeExprContext
	RangeExpr(i int) IRangeExprContext

	// IsStringConcatexprContext differentiates from other interfaces.
	IsStringConcatexprContext()
}

type StringConcatexprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringConcatexprContext() *StringConcatexprContext {
	var p = new(StringConcatexprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_stringConcatexpr
	return p
}

func InitEmptyStringConcatexprContext(p *StringConcatexprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_stringConcatexpr
}

func (*StringConcatexprContext) IsStringConcatexprContext() {}

func NewStringConcatexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringConcatexprContext {
	var p = new(StringConcatexprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_stringConcatexpr

	return p
}

func (s *StringConcatexprContext) GetParser() antlr.Parser { return s.parser }

func (s *StringConcatexprContext) AllRangeExpr() []IRangeExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRangeExprContext); ok {
			len++
		}
	}

	tst := make([]IRangeExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRangeExprContext); ok {
			tst[i] = t.(IRangeExprContext)
			i++
		}
	}

	return tst
}

func (s *StringConcatexprContext) RangeExpr(i int) IRangeExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRangeExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRangeExprContext)
}

func (s *StringConcatexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringConcatexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringConcatexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterStringConcatexpr(s)
	}
}

func (s *StringConcatexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitStringConcatexpr(s)
	}
}

func (p *XPath3Parser) StringConcatexpr() (localctx IStringConcatexprContext) {
	localctx = NewStringConcatexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, XPath3ParserRULE_stringConcatexpr)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(318)
		p.RangeExpr()
	}
	p.SetState(323)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 11, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(319)
				p.Match(XPath3ParserT__18)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(320)
				p.RangeExpr()
			}

		}
		p.SetState(325)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 11, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRangeExprContext is an interface to support dynamic dispatch.
type IRangeExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAdditiveExpr() []IAdditiveExprContext
	AdditiveExpr(i int) IAdditiveExprContext

	// IsRangeExprContext differentiates from other interfaces.
	IsRangeExprContext()
}

type RangeExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRangeExprContext() *RangeExprContext {
	var p = new(RangeExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_rangeExpr
	return p
}

func InitEmptyRangeExprContext(p *RangeExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_rangeExpr
}

func (*RangeExprContext) IsRangeExprContext() {}

func NewRangeExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RangeExprContext {
	var p = new(RangeExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_rangeExpr

	return p
}

func (s *RangeExprContext) GetParser() antlr.Parser { return s.parser }

func (s *RangeExprContext) AllAdditiveExpr() []IAdditiveExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAdditiveExprContext); ok {
			len++
		}
	}

	tst := make([]IAdditiveExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAdditiveExprContext); ok {
			tst[i] = t.(IAdditiveExprContext)
			i++
		}
	}

	return tst
}

func (s *RangeExprContext) AdditiveExpr(i int) IAdditiveExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdditiveExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdditiveExprContext)
}

func (s *RangeExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RangeExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RangeExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterRangeExpr(s)
	}
}

func (s *RangeExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitRangeExpr(s)
	}
}

func (p *XPath3Parser) RangeExpr() (localctx IRangeExprContext) {
	localctx = NewRangeExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, XPath3ParserRULE_rangeExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(326)
		p.AdditiveExpr()
	}
	p.SetState(329)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(327)
			p.Match(XPath3ParserT__19)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(328)
			p.AdditiveExpr()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdditiveExprContext is an interface to support dynamic dispatch.
type IAdditiveExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMultiplicativeExpr() []IMultiplicativeExprContext
	MultiplicativeExpr(i int) IMultiplicativeExprContext

	// IsAdditiveExprContext differentiates from other interfaces.
	IsAdditiveExprContext()
}

type AdditiveExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdditiveExprContext() *AdditiveExprContext {
	var p = new(AdditiveExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_additiveExpr
	return p
}

func InitEmptyAdditiveExprContext(p *AdditiveExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_additiveExpr
}

func (*AdditiveExprContext) IsAdditiveExprContext() {}

func NewAdditiveExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdditiveExprContext {
	var p = new(AdditiveExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_additiveExpr

	return p
}

func (s *AdditiveExprContext) GetParser() antlr.Parser { return s.parser }

func (s *AdditiveExprContext) AllMultiplicativeExpr() []IMultiplicativeExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultiplicativeExprContext); ok {
			len++
		}
	}

	tst := make([]IMultiplicativeExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultiplicativeExprContext); ok {
			tst[i] = t.(IMultiplicativeExprContext)
			i++
		}
	}

	return tst
}

func (s *AdditiveExprContext) MultiplicativeExpr(i int) IMultiplicativeExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiplicativeExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiplicativeExprContext)
}

func (s *AdditiveExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditiveExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdditiveExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterAdditiveExpr(s)
	}
}

func (s *AdditiveExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitAdditiveExpr(s)
	}
}

func (p *XPath3Parser) AdditiveExpr() (localctx IAdditiveExprContext) {
	localctx = NewAdditiveExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, XPath3ParserRULE_additiveExpr)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(331)
		p.MultiplicativeExpr()
	}
	p.SetState(336)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(332)
				_la = p.GetTokenStream().LA(1)

				if !(_la == XPath3ParserT__20 || _la == XPath3ParserT__21) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(333)
				p.MultiplicativeExpr()
			}

		}
		p.SetState(338)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiplicativeExprContext is an interface to support dynamic dispatch.
type IMultiplicativeExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllUnionExpr() []IUnionExprContext
	UnionExpr(i int) IUnionExprContext

	// IsMultiplicativeExprContext differentiates from other interfaces.
	IsMultiplicativeExprContext()
}

type MultiplicativeExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplicativeExprContext() *MultiplicativeExprContext {
	var p = new(MultiplicativeExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_multiplicativeExpr
	return p
}

func InitEmptyMultiplicativeExprContext(p *MultiplicativeExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_multiplicativeExpr
}

func (*MultiplicativeExprContext) IsMultiplicativeExprContext() {}

func NewMultiplicativeExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplicativeExprContext {
	var p = new(MultiplicativeExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_multiplicativeExpr

	return p
}

func (s *MultiplicativeExprContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplicativeExprContext) AllUnionExpr() []IUnionExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnionExprContext); ok {
			len++
		}
	}

	tst := make([]IUnionExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnionExprContext); ok {
			tst[i] = t.(IUnionExprContext)
			i++
		}
	}

	return tst
}

func (s *MultiplicativeExprContext) UnionExpr(i int) IUnionExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnionExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnionExprContext)
}

func (s *MultiplicativeExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplicativeExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplicativeExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterMultiplicativeExpr(s)
	}
}

func (s *MultiplicativeExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitMultiplicativeExpr(s)
	}
}

func (p *XPath3Parser) MultiplicativeExpr() (localctx IMultiplicativeExprContext) {
	localctx = NewMultiplicativeExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, XPath3ParserRULE_multiplicativeExpr)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(339)
		p.UnionExpr()
	}
	p.SetState(344)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 14, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(340)
				_la = p.GetTokenStream().LA(1)

				if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&125829120) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(341)
				p.UnionExpr()
			}

		}
		p.SetState(346)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 14, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnionExprContext is an interface to support dynamic dispatch.
type IUnionExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIntersectExceptExpr() []IIntersectExceptExprContext
	IntersectExceptExpr(i int) IIntersectExceptExprContext

	// IsUnionExprContext differentiates from other interfaces.
	IsUnionExprContext()
}

type UnionExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnionExprContext() *UnionExprContext {
	var p = new(UnionExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_unionExpr
	return p
}

func InitEmptyUnionExprContext(p *UnionExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_unionExpr
}

func (*UnionExprContext) IsUnionExprContext() {}

func NewUnionExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionExprContext {
	var p = new(UnionExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_unionExpr

	return p
}

func (s *UnionExprContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionExprContext) AllIntersectExceptExpr() []IIntersectExceptExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIntersectExceptExprContext); ok {
			len++
		}
	}

	tst := make([]IIntersectExceptExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIntersectExceptExprContext); ok {
			tst[i] = t.(IIntersectExceptExprContext)
			i++
		}
	}

	return tst
}

func (s *UnionExprContext) IntersectExceptExpr(i int) IIntersectExceptExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntersectExceptExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntersectExceptExprContext)
}

func (s *UnionExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnionExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterUnionExpr(s)
	}
}

func (s *UnionExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitUnionExpr(s)
	}
}

func (p *XPath3Parser) UnionExpr() (localctx IUnionExprContext) {
	localctx = NewUnionExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, XPath3ParserRULE_unionExpr)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(347)
		p.IntersectExceptExpr()
	}
	p.SetState(352)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 15, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(348)
				_la = p.GetTokenStream().LA(1)

				if !(_la == XPath3ParserT__26 || _la == XPath3ParserT__27) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(349)
				p.IntersectExceptExpr()
			}

		}
		p.SetState(354)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 15, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntersectExceptExprContext is an interface to support dynamic dispatch.
type IIntersectExceptExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllInstanceofExpr() []IInstanceofExprContext
	InstanceofExpr(i int) IInstanceofExprContext

	// IsIntersectExceptExprContext differentiates from other interfaces.
	IsIntersectExceptExprContext()
}

type IntersectExceptExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntersectExceptExprContext() *IntersectExceptExprContext {
	var p = new(IntersectExceptExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_intersectExceptExpr
	return p
}

func InitEmptyIntersectExceptExprContext(p *IntersectExceptExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_intersectExceptExpr
}

func (*IntersectExceptExprContext) IsIntersectExceptExprContext() {}

func NewIntersectExceptExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntersectExceptExprContext {
	var p = new(IntersectExceptExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_intersectExceptExpr

	return p
}

func (s *IntersectExceptExprContext) GetParser() antlr.Parser { return s.parser }

func (s *IntersectExceptExprContext) AllInstanceofExpr() []IInstanceofExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInstanceofExprContext); ok {
			len++
		}
	}

	tst := make([]IInstanceofExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInstanceofExprContext); ok {
			tst[i] = t.(IInstanceofExprContext)
			i++
		}
	}

	return tst
}

func (s *IntersectExceptExprContext) InstanceofExpr(i int) IInstanceofExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInstanceofExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInstanceofExprContext)
}

func (s *IntersectExceptExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntersectExceptExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntersectExceptExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterIntersectExceptExpr(s)
	}
}

func (s *IntersectExceptExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitIntersectExceptExpr(s)
	}
}

func (p *XPath3Parser) IntersectExceptExpr() (localctx IIntersectExceptExprContext) {
	localctx = NewIntersectExceptExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, XPath3ParserRULE_intersectExceptExpr)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(355)
		p.InstanceofExpr()
	}
	p.SetState(360)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 16, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(356)
				_la = p.GetTokenStream().LA(1)

				if !(_la == XPath3ParserT__28 || _la == XPath3ParserT__29) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(357)
				p.InstanceofExpr()
			}

		}
		p.SetState(362)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 16, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInstanceofExprContext is an interface to support dynamic dispatch.
type IInstanceofExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TreatExpr() ITreatExprContext
	SequenceType() ISequenceTypeContext

	// IsInstanceofExprContext differentiates from other interfaces.
	IsInstanceofExprContext()
}

type InstanceofExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInstanceofExprContext() *InstanceofExprContext {
	var p = new(InstanceofExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_instanceofExpr
	return p
}

func InitEmptyInstanceofExprContext(p *InstanceofExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_instanceofExpr
}

func (*InstanceofExprContext) IsInstanceofExprContext() {}

func NewInstanceofExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InstanceofExprContext {
	var p = new(InstanceofExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_instanceofExpr

	return p
}

func (s *InstanceofExprContext) GetParser() antlr.Parser { return s.parser }

func (s *InstanceofExprContext) TreatExpr() ITreatExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITreatExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITreatExprContext)
}

func (s *InstanceofExprContext) SequenceType() ISequenceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISequenceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISequenceTypeContext)
}

func (s *InstanceofExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstanceofExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InstanceofExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterInstanceofExpr(s)
	}
}

func (s *InstanceofExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitInstanceofExpr(s)
	}
}

func (p *XPath3Parser) InstanceofExpr() (localctx IInstanceofExprContext) {
	localctx = NewInstanceofExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, XPath3ParserRULE_instanceofExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(363)
		p.TreatExpr()
	}
	p.SetState(367)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(364)
			p.Match(XPath3ParserT__30)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(365)
			p.Match(XPath3ParserT__31)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(366)
			p.SequenceType()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITreatExprContext is an interface to support dynamic dispatch.
type ITreatExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CastableExpr() ICastableExprContext
	SequenceType() ISequenceTypeContext

	// IsTreatExprContext differentiates from other interfaces.
	IsTreatExprContext()
}

type TreatExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTreatExprContext() *TreatExprContext {
	var p = new(TreatExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_treatExpr
	return p
}

func InitEmptyTreatExprContext(p *TreatExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_treatExpr
}

func (*TreatExprContext) IsTreatExprContext() {}

func NewTreatExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TreatExprContext {
	var p = new(TreatExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_treatExpr

	return p
}

func (s *TreatExprContext) GetParser() antlr.Parser { return s.parser }

func (s *TreatExprContext) CastableExpr() ICastableExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastableExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastableExprContext)
}

func (s *TreatExprContext) SequenceType() ISequenceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISequenceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISequenceTypeContext)
}

func (s *TreatExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TreatExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TreatExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterTreatExpr(s)
	}
}

func (s *TreatExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitTreatExpr(s)
	}
}

func (p *XPath3Parser) TreatExpr() (localctx ITreatExprContext) {
	localctx = NewTreatExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, XPath3ParserRULE_treatExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(369)
		p.CastableExpr()
	}
	p.SetState(373)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 18, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(370)
			p.Match(XPath3ParserT__32)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(371)
			p.Match(XPath3ParserT__33)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(372)
			p.SequenceType()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICastableExprContext is an interface to support dynamic dispatch.
type ICastableExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CastExpr() ICastExprContext
	SingleType() ISingleTypeContext

	// IsCastableExprContext differentiates from other interfaces.
	IsCastableExprContext()
}

type CastableExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCastableExprContext() *CastableExprContext {
	var p = new(CastableExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_castableExpr
	return p
}

func InitEmptyCastableExprContext(p *CastableExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_castableExpr
}

func (*CastableExprContext) IsCastableExprContext() {}

func NewCastableExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CastableExprContext {
	var p = new(CastableExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_castableExpr

	return p
}

func (s *CastableExprContext) GetParser() antlr.Parser { return s.parser }

func (s *CastableExprContext) CastExpr() ICastExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastExprContext)
}

func (s *CastableExprContext) SingleType() ISingleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleTypeContext)
}

func (s *CastableExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastableExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CastableExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterCastableExpr(s)
	}
}

func (s *CastableExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitCastableExpr(s)
	}
}

func (p *XPath3Parser) CastableExpr() (localctx ICastableExprContext) {
	localctx = NewCastableExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, XPath3ParserRULE_castableExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(375)
		p.CastExpr()
	}
	p.SetState(379)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 19, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(376)
			p.Match(XPath3ParserT__34)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(377)
			p.Match(XPath3ParserT__33)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(378)
			p.SingleType()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICastExprContext is an interface to support dynamic dispatch.
type ICastExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnaryExpr() IUnaryExprContext
	SingleType() ISingleTypeContext

	// IsCastExprContext differentiates from other interfaces.
	IsCastExprContext()
}

type CastExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCastExprContext() *CastExprContext {
	var p = new(CastExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_castExpr
	return p
}

func InitEmptyCastExprContext(p *CastExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_castExpr
}

func (*CastExprContext) IsCastExprContext() {}

func NewCastExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CastExprContext {
	var p = new(CastExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_castExpr

	return p
}

func (s *CastExprContext) GetParser() antlr.Parser { return s.parser }

func (s *CastExprContext) UnaryExpr() IUnaryExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryExprContext)
}

func (s *CastExprContext) SingleType() ISingleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleTypeContext)
}

func (s *CastExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CastExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterCastExpr(s)
	}
}

func (s *CastExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitCastExpr(s)
	}
}

func (p *XPath3Parser) CastExpr() (localctx ICastExprContext) {
	localctx = NewCastExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, XPath3ParserRULE_castExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(381)
		p.UnaryExpr()
	}
	p.SetState(385)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 20, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(382)
			p.Match(XPath3ParserT__35)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(383)
			p.Match(XPath3ParserT__33)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(384)
			p.SingleType()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnaryExprContext is an interface to support dynamic dispatch.
type IUnaryExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ValueExpr() IValueExprContext

	// IsUnaryExprContext differentiates from other interfaces.
	IsUnaryExprContext()
}

type UnaryExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnaryExprContext() *UnaryExprContext {
	var p = new(UnaryExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_unaryExpr
	return p
}

func InitEmptyUnaryExprContext(p *UnaryExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_unaryExpr
}

func (*UnaryExprContext) IsUnaryExprContext() {}

func NewUnaryExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryExprContext {
	var p = new(UnaryExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_unaryExpr

	return p
}

func (s *UnaryExprContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryExprContext) ValueExpr() IValueExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExprContext)
}

func (s *UnaryExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnaryExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterUnaryExpr(s)
	}
}

func (s *UnaryExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitUnaryExpr(s)
	}
}

func (p *XPath3Parser) UnaryExpr() (localctx IUnaryExprContext) {
	localctx = NewUnaryExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, XPath3ParserRULE_unaryExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(390)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == XPath3ParserT__20 || _la == XPath3ParserT__21 {
		{
			p.SetState(387)
			_la = p.GetTokenStream().LA(1)

			if !(_la == XPath3ParserT__20 || _la == XPath3ParserT__21) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

		p.SetState(392)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(393)
		p.ValueExpr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValueExprContext is an interface to support dynamic dispatch.
type IValueExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleMapExpr() ISimpleMapExprContext

	// IsValueExprContext differentiates from other interfaces.
	IsValueExprContext()
}

type ValueExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueExprContext() *ValueExprContext {
	var p = new(ValueExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_valueExpr
	return p
}

func InitEmptyValueExprContext(p *ValueExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_valueExpr
}

func (*ValueExprContext) IsValueExprContext() {}

func NewValueExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueExprContext {
	var p = new(ValueExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_valueExpr

	return p
}

func (s *ValueExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueExprContext) SimpleMapExpr() ISimpleMapExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleMapExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleMapExprContext)
}

func (s *ValueExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterValueExpr(s)
	}
}

func (s *ValueExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitValueExpr(s)
	}
}

func (p *XPath3Parser) ValueExpr() (localctx IValueExprContext) {
	localctx = NewValueExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, XPath3ParserRULE_valueExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(395)
		p.SimpleMapExpr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGeneralCompContext is an interface to support dynamic dispatch.
type IGeneralCompContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsGeneralCompContext differentiates from other interfaces.
	IsGeneralCompContext()
}

type GeneralCompContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneralCompContext() *GeneralCompContext {
	var p = new(GeneralCompContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_generalComp
	return p
}

func InitEmptyGeneralCompContext(p *GeneralCompContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_generalComp
}

func (*GeneralCompContext) IsGeneralCompContext() {}

func NewGeneralCompContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GeneralCompContext {
	var p = new(GeneralCompContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_generalComp

	return p
}

func (s *GeneralCompContext) GetParser() antlr.Parser { return s.parser }
func (s *GeneralCompContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneralCompContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GeneralCompContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterGeneralComp(s)
	}
}

func (s *GeneralCompContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitGeneralComp(s)
	}
}

func (p *XPath3Parser) GeneralComp() (localctx IGeneralCompContext) {
	localctx = NewGeneralCompContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, XPath3ParserRULE_generalComp)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(397)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8658654068736) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValueCompContext is an interface to support dynamic dispatch.
type IValueCompContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsValueCompContext differentiates from other interfaces.
	IsValueCompContext()
}

type ValueCompContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueCompContext() *ValueCompContext {
	var p = new(ValueCompContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_valueComp
	return p
}

func InitEmptyValueCompContext(p *ValueCompContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_valueComp
}

func (*ValueCompContext) IsValueCompContext() {}

func NewValueCompContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueCompContext {
	var p = new(ValueCompContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_valueComp

	return p
}

func (s *ValueCompContext) GetParser() antlr.Parser { return s.parser }
func (s *ValueCompContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueCompContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueCompContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterValueComp(s)
	}
}

func (s *ValueCompContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitValueComp(s)
	}
}

func (p *XPath3Parser) ValueComp() (localctx IValueCompContext) {
	localctx = NewValueCompContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, XPath3ParserRULE_valueComp)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(399)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&554153860399104) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INodeCompContext is an interface to support dynamic dispatch.
type INodeCompContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsNodeCompContext differentiates from other interfaces.
	IsNodeCompContext()
}

type NodeCompContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNodeCompContext() *NodeCompContext {
	var p = new(NodeCompContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_nodeComp
	return p
}

func InitEmptyNodeCompContext(p *NodeCompContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_nodeComp
}

func (*NodeCompContext) IsNodeCompContext() {}

func NewNodeCompContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NodeCompContext {
	var p = new(NodeCompContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_nodeComp

	return p
}

func (s *NodeCompContext) GetParser() antlr.Parser { return s.parser }
func (s *NodeCompContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NodeCompContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NodeCompContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterNodeComp(s)
	}
}

func (s *NodeCompContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitNodeComp(s)
	}
}

func (p *XPath3Parser) NodeComp() (localctx INodeCompContext) {
	localctx = NewNodeCompContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, XPath3ParserRULE_nodeComp)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(401)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3940649673949184) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleMapExprContext is an interface to support dynamic dispatch.
type ISimpleMapExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPathExpr() []IPathExprContext
	PathExpr(i int) IPathExprContext

	// IsSimpleMapExprContext differentiates from other interfaces.
	IsSimpleMapExprContext()
}

type SimpleMapExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleMapExprContext() *SimpleMapExprContext {
	var p = new(SimpleMapExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_simpleMapExpr
	return p
}

func InitEmptySimpleMapExprContext(p *SimpleMapExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_simpleMapExpr
}

func (*SimpleMapExprContext) IsSimpleMapExprContext() {}

func NewSimpleMapExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleMapExprContext {
	var p = new(SimpleMapExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_simpleMapExpr

	return p
}

func (s *SimpleMapExprContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleMapExprContext) AllPathExpr() []IPathExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPathExprContext); ok {
			len++
		}
	}

	tst := make([]IPathExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPathExprContext); ok {
			tst[i] = t.(IPathExprContext)
			i++
		}
	}

	return tst
}

func (s *SimpleMapExprContext) PathExpr(i int) IPathExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathExprContext)
}

func (s *SimpleMapExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleMapExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleMapExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterSimpleMapExpr(s)
	}
}

func (s *SimpleMapExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitSimpleMapExpr(s)
	}
}

func (p *XPath3Parser) SimpleMapExpr() (localctx ISimpleMapExprContext) {
	localctx = NewSimpleMapExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, XPath3ParserRULE_simpleMapExpr)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(403)
		p.PathExpr()
	}
	p.SetState(408)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 22, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(404)
				p.Match(XPath3ParserT__51)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(405)
				p.PathExpr()
			}

		}
		p.SetState(410)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 22, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPathExprContext is an interface to support dynamic dispatch.
type IPathExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RelativePathExpr() IRelativePathExprContext

	// IsPathExprContext differentiates from other interfaces.
	IsPathExprContext()
}

type PathExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPathExprContext() *PathExprContext {
	var p = new(PathExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_pathExpr
	return p
}

func InitEmptyPathExprContext(p *PathExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_pathExpr
}

func (*PathExprContext) IsPathExprContext() {}

func NewPathExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PathExprContext {
	var p = new(PathExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_pathExpr

	return p
}

func (s *PathExprContext) GetParser() antlr.Parser { return s.parser }

func (s *PathExprContext) RelativePathExpr() IRelativePathExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelativePathExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelativePathExprContext)
}

func (s *PathExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PathExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PathExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterPathExpr(s)
	}
}

func (s *PathExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitPathExpr(s)
	}
}

func (p *XPath3Parser) PathExpr() (localctx IPathExprContext) {
	localctx = NewPathExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, XPath3ParserRULE_pathExpr)
	p.SetState(418)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserT__52:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(411)
			p.Match(XPath3ParserT__52)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(413)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 23, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(412)
				p.RelativePathExpr()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case XPath3ParserT__53:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(415)
			p.Match(XPath3ParserT__53)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(416)
			p.RelativePathExpr()
		}

	case XPath3ParserT__1, XPath3ParserT__13, XPath3ParserT__22, XPath3ParserT__54, XPath3ParserT__56, XPath3ParserT__57, XPath3ParserT__58, XPath3ParserT__59, XPath3ParserT__60, XPath3ParserT__61, XPath3ParserT__62, XPath3ParserT__63, XPath3ParserT__64, XPath3ParserT__65, XPath3ParserT__66, XPath3ParserT__67, XPath3ParserT__68, XPath3ParserT__69, XPath3ParserT__73, XPath3ParserT__76, XPath3ParserT__79, XPath3ParserT__80, XPath3ParserT__81, XPath3ParserT__82, XPath3ParserT__83, XPath3ParserT__84, XPath3ParserT__85, XPath3ParserT__86, XPath3ParserT__87, XPath3ParserT__88, XPath3ParserT__89, XPath3ParserNumericLiteral, XPath3ParserURIQualifiedName, XPath3ParserBracedURILiteral, XPath3ParserQNAME, XPath3ParserNC_NAME:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(417)
			p.RelativePathExpr()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelativePathExprContext is an interface to support dynamic dispatch.
type IRelativePathExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllStepExpr() []IStepExprContext
	StepExpr(i int) IStepExprContext

	// IsRelativePathExprContext differentiates from other interfaces.
	IsRelativePathExprContext()
}

type RelativePathExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelativePathExprContext() *RelativePathExprContext {
	var p = new(RelativePathExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_relativePathExpr
	return p
}

func InitEmptyRelativePathExprContext(p *RelativePathExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_relativePathExpr
}

func (*RelativePathExprContext) IsRelativePathExprContext() {}

func NewRelativePathExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelativePathExprContext {
	var p = new(RelativePathExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_relativePathExpr

	return p
}

func (s *RelativePathExprContext) GetParser() antlr.Parser { return s.parser }

func (s *RelativePathExprContext) AllStepExpr() []IStepExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStepExprContext); ok {
			len++
		}
	}

	tst := make([]IStepExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStepExprContext); ok {
			tst[i] = t.(IStepExprContext)
			i++
		}
	}

	return tst
}

func (s *RelativePathExprContext) StepExpr(i int) IStepExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStepExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStepExprContext)
}

func (s *RelativePathExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelativePathExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelativePathExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterRelativePathExpr(s)
	}
}

func (s *RelativePathExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitRelativePathExpr(s)
	}
}

func (p *XPath3Parser) RelativePathExpr() (localctx IRelativePathExprContext) {
	localctx = NewRelativePathExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, XPath3ParserRULE_relativePathExpr)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(420)
		p.StepExpr()
	}
	p.SetState(425)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(421)
				_la = p.GetTokenStream().LA(1)

				if !(_la == XPath3ParserT__52 || _la == XPath3ParserT__53) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(422)
				p.StepExpr()
			}

		}
		p.SetState(427)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStepExprContext is an interface to support dynamic dispatch.
type IStepExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PostfixExpr() IPostfixExprContext
	AxisStep() IAxisStepContext

	// IsStepExprContext differentiates from other interfaces.
	IsStepExprContext()
}

type StepExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStepExprContext() *StepExprContext {
	var p = new(StepExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_stepExpr
	return p
}

func InitEmptyStepExprContext(p *StepExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_stepExpr
}

func (*StepExprContext) IsStepExprContext() {}

func NewStepExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StepExprContext {
	var p = new(StepExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_stepExpr

	return p
}

func (s *StepExprContext) GetParser() antlr.Parser { return s.parser }

func (s *StepExprContext) PostfixExpr() IPostfixExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixExprContext)
}

func (s *StepExprContext) AxisStep() IAxisStepContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAxisStepContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAxisStepContext)
}

func (s *StepExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StepExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StepExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterStepExpr(s)
	}
}

func (s *StepExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitStepExpr(s)
	}
}

func (p *XPath3Parser) StepExpr() (localctx IStepExprContext) {
	localctx = NewStepExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, XPath3ParserRULE_stepExpr)
	p.SetState(430)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 26, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(428)
			p.PostfixExpr()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(429)
			p.AxisStep()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAxisStepContext is an interface to support dynamic dispatch.
type IAxisStepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PredicateList() IPredicateListContext
	ReverseStep() IReverseStepContext
	ForwardStep() IForwardStepContext

	// IsAxisStepContext differentiates from other interfaces.
	IsAxisStepContext()
}

type AxisStepContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAxisStepContext() *AxisStepContext {
	var p = new(AxisStepContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_axisStep
	return p
}

func InitEmptyAxisStepContext(p *AxisStepContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_axisStep
}

func (*AxisStepContext) IsAxisStepContext() {}

func NewAxisStepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AxisStepContext {
	var p = new(AxisStepContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_axisStep

	return p
}

func (s *AxisStepContext) GetParser() antlr.Parser { return s.parser }

func (s *AxisStepContext) PredicateList() IPredicateListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateListContext)
}

func (s *AxisStepContext) ReverseStep() IReverseStepContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReverseStepContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReverseStepContext)
}

func (s *AxisStepContext) ForwardStep() IForwardStepContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForwardStepContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForwardStepContext)
}

func (s *AxisStepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AxisStepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AxisStepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterAxisStep(s)
	}
}

func (s *AxisStepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitAxisStep(s)
	}
}

func (p *XPath3Parser) AxisStep() (localctx IAxisStepContext) {
	localctx = NewAxisStepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, XPath3ParserRULE_axisStep)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(434)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserT__64, XPath3ParserT__65, XPath3ParserT__66, XPath3ParserT__67, XPath3ParserT__68, XPath3ParserT__69:
		{
			p.SetState(432)
			p.ReverseStep()
		}

	case XPath3ParserT__22, XPath3ParserT__54, XPath3ParserT__56, XPath3ParserT__57, XPath3ParserT__58, XPath3ParserT__59, XPath3ParserT__60, XPath3ParserT__61, XPath3ParserT__62, XPath3ParserT__63, XPath3ParserT__79, XPath3ParserT__80, XPath3ParserT__81, XPath3ParserT__82, XPath3ParserT__83, XPath3ParserT__84, XPath3ParserT__85, XPath3ParserT__86, XPath3ParserT__87, XPath3ParserURIQualifiedName, XPath3ParserBracedURILiteral, XPath3ParserQNAME, XPath3ParserNC_NAME:
		{
			p.SetState(433)
			p.ForwardStep()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(436)
		p.PredicateList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForwardStepContext is an interface to support dynamic dispatch.
type IForwardStepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ForwardAxis() IForwardAxisContext
	NodeTest() INodeTestContext
	AbbrevForwardStep() IAbbrevForwardStepContext

	// IsForwardStepContext differentiates from other interfaces.
	IsForwardStepContext()
}

type ForwardStepContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForwardStepContext() *ForwardStepContext {
	var p = new(ForwardStepContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_forwardStep
	return p
}

func InitEmptyForwardStepContext(p *ForwardStepContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_forwardStep
}

func (*ForwardStepContext) IsForwardStepContext() {}

func NewForwardStepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForwardStepContext {
	var p = new(ForwardStepContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_forwardStep

	return p
}

func (s *ForwardStepContext) GetParser() antlr.Parser { return s.parser }

func (s *ForwardStepContext) ForwardAxis() IForwardAxisContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForwardAxisContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForwardAxisContext)
}

func (s *ForwardStepContext) NodeTest() INodeTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeTestContext)
}

func (s *ForwardStepContext) AbbrevForwardStep() IAbbrevForwardStepContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAbbrevForwardStepContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAbbrevForwardStepContext)
}

func (s *ForwardStepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForwardStepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForwardStepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterForwardStep(s)
	}
}

func (s *ForwardStepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitForwardStep(s)
	}
}

func (p *XPath3Parser) ForwardStep() (localctx IForwardStepContext) {
	localctx = NewForwardStepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, XPath3ParserRULE_forwardStep)
	p.SetState(442)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 28, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(438)
			p.ForwardAxis()
		}
		{
			p.SetState(439)
			p.NodeTest()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(441)
			p.AbbrevForwardStep()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForwardAxisContext is an interface to support dynamic dispatch.
type IForwardAxisContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsForwardAxisContext differentiates from other interfaces.
	IsForwardAxisContext()
}

type ForwardAxisContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForwardAxisContext() *ForwardAxisContext {
	var p = new(ForwardAxisContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_forwardAxis
	return p
}

func InitEmptyForwardAxisContext(p *ForwardAxisContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_forwardAxis
}

func (*ForwardAxisContext) IsForwardAxisContext() {}

func NewForwardAxisContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForwardAxisContext {
	var p = new(ForwardAxisContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_forwardAxis

	return p
}

func (s *ForwardAxisContext) GetParser() antlr.Parser { return s.parser }
func (s *ForwardAxisContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForwardAxisContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForwardAxisContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterForwardAxis(s)
	}
}

func (s *ForwardAxisContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitForwardAxis(s)
	}
}

func (p *XPath3Parser) ForwardAxis() (localctx IForwardAxisContext) {
	localctx = NewForwardAxisContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, XPath3ParserRULE_forwardAxis)
	p.SetState(460)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserT__54:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(444)
			p.Match(XPath3ParserT__54)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(445)
			p.Match(XPath3ParserT__55)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case XPath3ParserT__56:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(446)
			p.Match(XPath3ParserT__56)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(447)
			p.Match(XPath3ParserT__55)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case XPath3ParserT__57:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(448)
			p.Match(XPath3ParserT__57)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(449)
			p.Match(XPath3ParserT__55)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case XPath3ParserT__58:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(450)
			p.Match(XPath3ParserT__58)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(451)
			p.Match(XPath3ParserT__55)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case XPath3ParserT__59:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(452)
			p.Match(XPath3ParserT__59)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(453)
			p.Match(XPath3ParserT__55)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case XPath3ParserT__60:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(454)
			p.Match(XPath3ParserT__60)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(455)
			p.Match(XPath3ParserT__55)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case XPath3ParserT__61:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(456)
			p.Match(XPath3ParserT__61)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(457)
			p.Match(XPath3ParserT__55)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case XPath3ParserT__62:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(458)
			p.Match(XPath3ParserT__62)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(459)
			p.Match(XPath3ParserT__55)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAbbrevForwardStepContext is an interface to support dynamic dispatch.
type IAbbrevForwardStepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NodeTest() INodeTestContext

	// IsAbbrevForwardStepContext differentiates from other interfaces.
	IsAbbrevForwardStepContext()
}

type AbbrevForwardStepContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAbbrevForwardStepContext() *AbbrevForwardStepContext {
	var p = new(AbbrevForwardStepContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_abbrevForwardStep
	return p
}

func InitEmptyAbbrevForwardStepContext(p *AbbrevForwardStepContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_abbrevForwardStep
}

func (*AbbrevForwardStepContext) IsAbbrevForwardStepContext() {}

func NewAbbrevForwardStepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AbbrevForwardStepContext {
	var p = new(AbbrevForwardStepContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_abbrevForwardStep

	return p
}

func (s *AbbrevForwardStepContext) GetParser() antlr.Parser { return s.parser }

func (s *AbbrevForwardStepContext) NodeTest() INodeTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeTestContext)
}

func (s *AbbrevForwardStepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AbbrevForwardStepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AbbrevForwardStepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterAbbrevForwardStep(s)
	}
}

func (s *AbbrevForwardStepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitAbbrevForwardStep(s)
	}
}

func (p *XPath3Parser) AbbrevForwardStep() (localctx IAbbrevForwardStepContext) {
	localctx = NewAbbrevForwardStepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, XPath3ParserRULE_abbrevForwardStep)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(463)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == XPath3ParserT__63 {
		{
			p.SetState(462)
			p.Match(XPath3ParserT__63)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(465)
		p.NodeTest()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReverseStepContext is an interface to support dynamic dispatch.
type IReverseStepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ReverseAxis() IReverseAxisContext
	NodeTest() INodeTestContext
	AbbrevReverseStep() IAbbrevReverseStepContext

	// IsReverseStepContext differentiates from other interfaces.
	IsReverseStepContext()
}

type ReverseStepContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReverseStepContext() *ReverseStepContext {
	var p = new(ReverseStepContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_reverseStep
	return p
}

func InitEmptyReverseStepContext(p *ReverseStepContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_reverseStep
}

func (*ReverseStepContext) IsReverseStepContext() {}

func NewReverseStepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReverseStepContext {
	var p = new(ReverseStepContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_reverseStep

	return p
}

func (s *ReverseStepContext) GetParser() antlr.Parser { return s.parser }

func (s *ReverseStepContext) ReverseAxis() IReverseAxisContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReverseAxisContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReverseAxisContext)
}

func (s *ReverseStepContext) NodeTest() INodeTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeTestContext)
}

func (s *ReverseStepContext) AbbrevReverseStep() IAbbrevReverseStepContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAbbrevReverseStepContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAbbrevReverseStepContext)
}

func (s *ReverseStepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReverseStepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReverseStepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterReverseStep(s)
	}
}

func (s *ReverseStepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitReverseStep(s)
	}
}

func (p *XPath3Parser) ReverseStep() (localctx IReverseStepContext) {
	localctx = NewReverseStepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, XPath3ParserRULE_reverseStep)
	p.SetState(471)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserT__64, XPath3ParserT__65, XPath3ParserT__66, XPath3ParserT__67, XPath3ParserT__68:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(467)
			p.ReverseAxis()
		}
		{
			p.SetState(468)
			p.NodeTest()
		}

	case XPath3ParserT__69:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(470)
			p.AbbrevReverseStep()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReverseAxisContext is an interface to support dynamic dispatch.
type IReverseAxisContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsReverseAxisContext differentiates from other interfaces.
	IsReverseAxisContext()
}

type ReverseAxisContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReverseAxisContext() *ReverseAxisContext {
	var p = new(ReverseAxisContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_reverseAxis
	return p
}

func InitEmptyReverseAxisContext(p *ReverseAxisContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_reverseAxis
}

func (*ReverseAxisContext) IsReverseAxisContext() {}

func NewReverseAxisContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReverseAxisContext {
	var p = new(ReverseAxisContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_reverseAxis

	return p
}

func (s *ReverseAxisContext) GetParser() antlr.Parser { return s.parser }
func (s *ReverseAxisContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReverseAxisContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReverseAxisContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterReverseAxis(s)
	}
}

func (s *ReverseAxisContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitReverseAxis(s)
	}
}

func (p *XPath3Parser) ReverseAxis() (localctx IReverseAxisContext) {
	localctx = NewReverseAxisContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, XPath3ParserRULE_reverseAxis)
	p.SetState(483)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserT__64:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(473)
			p.Match(XPath3ParserT__64)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(474)
			p.Match(XPath3ParserT__55)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case XPath3ParserT__65:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(475)
			p.Match(XPath3ParserT__65)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(476)
			p.Match(XPath3ParserT__55)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case XPath3ParserT__66:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(477)
			p.Match(XPath3ParserT__66)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(478)
			p.Match(XPath3ParserT__55)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case XPath3ParserT__67:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(479)
			p.Match(XPath3ParserT__67)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(480)
			p.Match(XPath3ParserT__55)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case XPath3ParserT__68:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(481)
			p.Match(XPath3ParserT__68)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(482)
			p.Match(XPath3ParserT__55)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAbbrevReverseStepContext is an interface to support dynamic dispatch.
type IAbbrevReverseStepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAbbrevReverseStepContext differentiates from other interfaces.
	IsAbbrevReverseStepContext()
}

type AbbrevReverseStepContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAbbrevReverseStepContext() *AbbrevReverseStepContext {
	var p = new(AbbrevReverseStepContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_abbrevReverseStep
	return p
}

func InitEmptyAbbrevReverseStepContext(p *AbbrevReverseStepContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_abbrevReverseStep
}

func (*AbbrevReverseStepContext) IsAbbrevReverseStepContext() {}

func NewAbbrevReverseStepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AbbrevReverseStepContext {
	var p = new(AbbrevReverseStepContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_abbrevReverseStep

	return p
}

func (s *AbbrevReverseStepContext) GetParser() antlr.Parser { return s.parser }
func (s *AbbrevReverseStepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AbbrevReverseStepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AbbrevReverseStepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterAbbrevReverseStep(s)
	}
}

func (s *AbbrevReverseStepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitAbbrevReverseStep(s)
	}
}

func (p *XPath3Parser) AbbrevReverseStep() (localctx IAbbrevReverseStepContext) {
	localctx = NewAbbrevReverseStepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, XPath3ParserRULE_abbrevReverseStep)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(485)
		p.Match(XPath3ParserT__69)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INodeTestContext is an interface to support dynamic dispatch.
type INodeTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KindTest() IKindTestContext
	NameTest() INameTestContext

	// IsNodeTestContext differentiates from other interfaces.
	IsNodeTestContext()
}

type NodeTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNodeTestContext() *NodeTestContext {
	var p = new(NodeTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_nodeTest
	return p
}

func InitEmptyNodeTestContext(p *NodeTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_nodeTest
}

func (*NodeTestContext) IsNodeTestContext() {}

func NewNodeTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NodeTestContext {
	var p = new(NodeTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_nodeTest

	return p
}

func (s *NodeTestContext) GetParser() antlr.Parser { return s.parser }

func (s *NodeTestContext) KindTest() IKindTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKindTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKindTestContext)
}

func (s *NodeTestContext) NameTest() INameTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameTestContext)
}

func (s *NodeTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NodeTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NodeTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterNodeTest(s)
	}
}

func (s *NodeTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitNodeTest(s)
	}
}

func (p *XPath3Parser) NodeTest() (localctx INodeTestContext) {
	localctx = NewNodeTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, XPath3ParserRULE_nodeTest)
	p.SetState(489)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserT__57, XPath3ParserT__79, XPath3ParserT__80, XPath3ParserT__81, XPath3ParserT__82, XPath3ParserT__83, XPath3ParserT__84, XPath3ParserT__85, XPath3ParserT__86, XPath3ParserT__87:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(487)
			p.KindTest()
		}

	case XPath3ParserT__22, XPath3ParserURIQualifiedName, XPath3ParserBracedURILiteral, XPath3ParserQNAME, XPath3ParserNC_NAME:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(488)
			p.NameTest()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INameTestContext is an interface to support dynamic dispatch.
type INameTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EqName() IEqNameContext
	WildCard() IWildCardContext

	// IsNameTestContext differentiates from other interfaces.
	IsNameTestContext()
}

type NameTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNameTestContext() *NameTestContext {
	var p = new(NameTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_nameTest
	return p
}

func InitEmptyNameTestContext(p *NameTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_nameTest
}

func (*NameTestContext) IsNameTestContext() {}

func NewNameTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NameTestContext {
	var p = new(NameTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_nameTest

	return p
}

func (s *NameTestContext) GetParser() antlr.Parser { return s.parser }

func (s *NameTestContext) EqName() IEqNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqNameContext)
}

func (s *NameTestContext) WildCard() IWildCardContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildCardContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildCardContext)
}

func (s *NameTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NameTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NameTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterNameTest(s)
	}
}

func (s *NameTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitNameTest(s)
	}
}

func (p *XPath3Parser) NameTest() (localctx INameTestContext) {
	localctx = NewNameTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, XPath3ParserRULE_nameTest)
	p.SetState(493)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserURIQualifiedName, XPath3ParserQNAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(491)
			p.EqName()
		}

	case XPath3ParserT__22, XPath3ParserBracedURILiteral, XPath3ParserNC_NAME:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(492)
			p.WildCard()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWildCardContext is an interface to support dynamic dispatch.
type IWildCardContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NC_NAME() antlr.TerminalNode
	BracedURILiteral() antlr.TerminalNode

	// IsWildCardContext differentiates from other interfaces.
	IsWildCardContext()
}

type WildCardContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWildCardContext() *WildCardContext {
	var p = new(WildCardContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_wildCard
	return p
}

func InitEmptyWildCardContext(p *WildCardContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_wildCard
}

func (*WildCardContext) IsWildCardContext() {}

func NewWildCardContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WildCardContext {
	var p = new(WildCardContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_wildCard

	return p
}

func (s *WildCardContext) GetParser() antlr.Parser { return s.parser }

func (s *WildCardContext) NC_NAME() antlr.TerminalNode {
	return s.GetToken(XPath3ParserNC_NAME, 0)
}

func (s *WildCardContext) BracedURILiteral() antlr.TerminalNode {
	return s.GetToken(XPath3ParserBracedURILiteral, 0)
}

func (s *WildCardContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WildCardContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WildCardContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterWildCard(s)
	}
}

func (s *WildCardContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitWildCard(s)
	}
}

func (p *XPath3Parser) WildCard() (localctx IWildCardContext) {
	localctx = NewWildCardContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, XPath3ParserRULE_wildCard)
	p.SetState(504)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 35, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(495)
			p.Match(XPath3ParserT__22)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(496)
			p.Match(XPath3ParserNC_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(497)
			p.Match(XPath3ParserT__70)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(498)
			p.Match(XPath3ParserT__22)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(499)
			p.Match(XPath3ParserT__22)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(500)
			p.Match(XPath3ParserT__70)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(501)
			p.Match(XPath3ParserNC_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(502)
			p.Match(XPath3ParserBracedURILiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(503)
			p.Match(XPath3ParserT__22)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPostfixExprContext is an interface to support dynamic dispatch.
type IPostfixExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrimaryExpr() IPrimaryExprContext
	AllPredicate() []IPredicateContext
	Predicate(i int) IPredicateContext
	AllArgumentList() []IArgumentListContext
	ArgumentList(i int) IArgumentListContext

	// IsPostfixExprContext differentiates from other interfaces.
	IsPostfixExprContext()
}

type PostfixExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostfixExprContext() *PostfixExprContext {
	var p = new(PostfixExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_postfixExpr
	return p
}

func InitEmptyPostfixExprContext(p *PostfixExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_postfixExpr
}

func (*PostfixExprContext) IsPostfixExprContext() {}

func NewPostfixExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixExprContext {
	var p = new(PostfixExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_postfixExpr

	return p
}

func (s *PostfixExprContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixExprContext) PrimaryExpr() IPrimaryExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExprContext)
}

func (s *PostfixExprContext) AllPredicate() []IPredicateContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPredicateContext); ok {
			len++
		}
	}

	tst := make([]IPredicateContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPredicateContext); ok {
			tst[i] = t.(IPredicateContext)
			i++
		}
	}

	return tst
}

func (s *PostfixExprContext) Predicate(i int) IPredicateContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *PostfixExprContext) AllArgumentList() []IArgumentListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArgumentListContext); ok {
			len++
		}
	}

	tst := make([]IArgumentListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArgumentListContext); ok {
			tst[i] = t.(IArgumentListContext)
			i++
		}
	}

	return tst
}

func (s *PostfixExprContext) ArgumentList(i int) IArgumentListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *PostfixExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostfixExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterPostfixExpr(s)
	}
}

func (s *PostfixExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitPostfixExpr(s)
	}
}

func (p *XPath3Parser) PostfixExpr() (localctx IPostfixExprContext) {
	localctx = NewPostfixExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, XPath3ParserRULE_postfixExpr)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(506)
		p.PrimaryExpr()
	}
	p.SetState(511)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 37, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(509)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case XPath3ParserT__71:
				{
					p.SetState(507)
					p.Predicate()
				}

			case XPath3ParserT__13:
				{
					p.SetState(508)
					p.ArgumentList()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(513)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 37, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgumentListContext is an interface to support dynamic dispatch.
type IArgumentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllArgument() []IArgumentContext
	Argument(i int) IArgumentContext

	// IsArgumentListContext differentiates from other interfaces.
	IsArgumentListContext()
}

type ArgumentListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentListContext() *ArgumentListContext {
	var p = new(ArgumentListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_argumentList
	return p
}

func InitEmptyArgumentListContext(p *ArgumentListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_argumentList
}

func (*ArgumentListContext) IsArgumentListContext() {}

func NewArgumentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentListContext {
	var p = new(ArgumentListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_argumentList

	return p
}

func (s *ArgumentListContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentListContext) AllArgument() []IArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArgumentContext); ok {
			len++
		}
	}

	tst := make([]IArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArgumentContext); ok {
			tst[i] = t.(IArgumentContext)
			i++
		}
	}

	return tst
}

func (s *ArgumentListContext) Argument(i int) IArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentContext)
}

func (s *ArgumentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterArgumentList(s)
	}
}

func (s *ArgumentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitArgumentList(s)
	}
}

func (p *XPath3Parser) ArgumentList() (localctx IArgumentListContext) {
	localctx = NewArgumentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, XPath3ParserRULE_argumentList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(514)
		p.Match(XPath3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(523)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-81064793277960892) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&4578703518847) != 0) {
		{
			p.SetState(515)
			p.Argument()
		}
		p.SetState(520)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == XPath3ParserT__0 {
			{
				p.SetState(516)
				p.Match(XPath3ParserT__0)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(517)
				p.Argument()
			}

			p.SetState(522)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(525)
		p.Match(XPath3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPredicateListContext is an interface to support dynamic dispatch.
type IPredicateListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPredicate() []IPredicateContext
	Predicate(i int) IPredicateContext

	// IsPredicateListContext differentiates from other interfaces.
	IsPredicateListContext()
}

type PredicateListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPredicateListContext() *PredicateListContext {
	var p = new(PredicateListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_predicateList
	return p
}

func InitEmptyPredicateListContext(p *PredicateListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_predicateList
}

func (*PredicateListContext) IsPredicateListContext() {}

func NewPredicateListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredicateListContext {
	var p = new(PredicateListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_predicateList

	return p
}

func (s *PredicateListContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateListContext) AllPredicate() []IPredicateContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPredicateContext); ok {
			len++
		}
	}

	tst := make([]IPredicateContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPredicateContext); ok {
			tst[i] = t.(IPredicateContext)
			i++
		}
	}

	return tst
}

func (s *PredicateListContext) Predicate(i int) IPredicateContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *PredicateListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PredicateListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterPredicateList(s)
	}
}

func (s *PredicateListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitPredicateList(s)
	}
}

func (p *XPath3Parser) PredicateList() (localctx IPredicateListContext) {
	localctx = NewPredicateListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, XPath3ParserRULE_predicateList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(530)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 40, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(527)
				p.Predicate()
			}

		}
		p.SetState(532)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 40, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPredicateContext is an interface to support dynamic dispatch.
type IPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext

	// IsPredicateContext differentiates from other interfaces.
	IsPredicateContext()
}

type PredicateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPredicateContext() *PredicateContext {
	var p = new(PredicateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_predicate
	return p
}

func InitEmptyPredicateContext(p *PredicateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_predicate
}

func (*PredicateContext) IsPredicateContext() {}

func NewPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredicateContext {
	var p = new(PredicateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_predicate

	return p
}

func (s *PredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *PredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterPredicate(s)
	}
}

func (s *PredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitPredicate(s)
	}
}

func (p *XPath3Parser) Predicate() (localctx IPredicateContext) {
	localctx = NewPredicateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, XPath3ParserRULE_predicate)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(533)
		p.Match(XPath3ParserT__71)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(534)
		p.Expr()
	}
	{
		p.SetState(535)
		p.Match(XPath3ParserT__72)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimaryExprContext is an interface to support dynamic dispatch.
type IPrimaryExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Literal() ILiteralContext
	VarRef() IVarRefContext
	ParenthesizedExpr() IParenthesizedExprContext
	ContextItemExpr() IContextItemExprContext
	FunctionCall() IFunctionCallContext
	FunctionItemExpr() IFunctionItemExprContext

	// IsPrimaryExprContext differentiates from other interfaces.
	IsPrimaryExprContext()
}

type PrimaryExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryExprContext() *PrimaryExprContext {
	var p = new(PrimaryExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_primaryExpr
	return p
}

func InitEmptyPrimaryExprContext(p *PrimaryExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_primaryExpr
}

func (*PrimaryExprContext) IsPrimaryExprContext() {}

func NewPrimaryExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExprContext {
	var p = new(PrimaryExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_primaryExpr

	return p
}

func (s *PrimaryExprContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExprContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *PrimaryExprContext) VarRef() IVarRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarRefContext)
}

func (s *PrimaryExprContext) ParenthesizedExpr() IParenthesizedExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesizedExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesizedExprContext)
}

func (s *PrimaryExprContext) ContextItemExpr() IContextItemExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContextItemExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContextItemExprContext)
}

func (s *PrimaryExprContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *PrimaryExprContext) FunctionItemExpr() IFunctionItemExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionItemExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionItemExprContext)
}

func (s *PrimaryExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterPrimaryExpr(s)
	}
}

func (s *PrimaryExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitPrimaryExpr(s)
	}
}

func (p *XPath3Parser) PrimaryExpr() (localctx IPrimaryExprContext) {
	localctx = NewPrimaryExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, XPath3ParserRULE_primaryExpr)
	p.SetState(543)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 41, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(537)
			p.Literal()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(538)
			p.VarRef()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(539)
			p.ParenthesizedExpr()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(540)
			p.ContextItemExpr()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(541)
			p.FunctionCall()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(542)
			p.FunctionItemExpr()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVarRefContext is an interface to support dynamic dispatch.
type IVarRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VarName() IVarNameContext

	// IsVarRefContext differentiates from other interfaces.
	IsVarRefContext()
}

type VarRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarRefContext() *VarRefContext {
	var p = new(VarRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_varRef
	return p
}

func InitEmptyVarRefContext(p *VarRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_varRef
}

func (*VarRefContext) IsVarRefContext() {}

func NewVarRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarRefContext {
	var p = new(VarRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_varRef

	return p
}

func (s *VarRefContext) GetParser() antlr.Parser { return s.parser }

func (s *VarRefContext) VarName() IVarNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarNameContext)
}

func (s *VarRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterVarRef(s)
	}
}

func (s *VarRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitVarRef(s)
	}
}

func (p *XPath3Parser) VarRef() (localctx IVarRefContext) {
	localctx = NewVarRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, XPath3ParserRULE_varRef)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(545)
		p.Match(XPath3ParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(546)
		p.VarName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVarNameContext is an interface to support dynamic dispatch.
type IVarNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EqName() IEqNameContext

	// IsVarNameContext differentiates from other interfaces.
	IsVarNameContext()
}

type VarNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarNameContext() *VarNameContext {
	var p = new(VarNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_varName
	return p
}

func InitEmptyVarNameContext(p *VarNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_varName
}

func (*VarNameContext) IsVarNameContext() {}

func NewVarNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarNameContext {
	var p = new(VarNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_varName

	return p
}

func (s *VarNameContext) GetParser() antlr.Parser { return s.parser }

func (s *VarNameContext) EqName() IEqNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqNameContext)
}

func (s *VarNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterVarName(s)
	}
}

func (s *VarNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitVarName(s)
	}
}

func (p *XPath3Parser) VarName() (localctx IVarNameContext) {
	localctx = NewVarNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, XPath3ParserRULE_varName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(548)
		p.EqName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NumericLiteral() antlr.TerminalNode
	StringLiteral() IStringLiteralContext

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_literal
	return p
}

func InitEmptyLiteralContext(p *LiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_literal
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) NumericLiteral() antlr.TerminalNode {
	return s.GetToken(XPath3ParserNumericLiteral, 0)
}

func (s *LiteralContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (p *XPath3Parser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, XPath3ParserRULE_literal)
	p.SetState(552)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserNumericLiteral:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(550)
			p.Match(XPath3ParserNumericLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case XPath3ParserT__88, XPath3ParserT__89:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(551)
			p.StringLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParenthesizedExprContext is an interface to support dynamic dispatch.
type IParenthesizedExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext

	// IsParenthesizedExprContext differentiates from other interfaces.
	IsParenthesizedExprContext()
}

type ParenthesizedExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParenthesizedExprContext() *ParenthesizedExprContext {
	var p = new(ParenthesizedExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_parenthesizedExpr
	return p
}

func InitEmptyParenthesizedExprContext(p *ParenthesizedExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_parenthesizedExpr
}

func (*ParenthesizedExprContext) IsParenthesizedExprContext() {}

func NewParenthesizedExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParenthesizedExprContext {
	var p = new(ParenthesizedExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_parenthesizedExpr

	return p
}

func (s *ParenthesizedExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ParenthesizedExprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ParenthesizedExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParenthesizedExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterParenthesizedExpr(s)
	}
}

func (s *ParenthesizedExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitParenthesizedExpr(s)
	}
}

func (p *XPath3Parser) ParenthesizedExpr() (localctx IParenthesizedExprContext) {
	localctx = NewParenthesizedExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, XPath3ParserRULE_parenthesizedExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(554)
		p.Match(XPath3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(556)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-81064793277960892) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&4578703516799) != 0) {
		{
			p.SetState(555)
			p.Expr()
		}

	}
	{
		p.SetState(558)
		p.Match(XPath3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IContextItemExprContext is an interface to support dynamic dispatch.
type IContextItemExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsContextItemExprContext differentiates from other interfaces.
	IsContextItemExprContext()
}

type ContextItemExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContextItemExprContext() *ContextItemExprContext {
	var p = new(ContextItemExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_contextItemExpr
	return p
}

func InitEmptyContextItemExprContext(p *ContextItemExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_contextItemExpr
}

func (*ContextItemExprContext) IsContextItemExprContext() {}

func NewContextItemExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContextItemExprContext {
	var p = new(ContextItemExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_contextItemExpr

	return p
}

func (s *ContextItemExprContext) GetParser() antlr.Parser { return s.parser }
func (s *ContextItemExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContextItemExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContextItemExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterContextItemExpr(s)
	}
}

func (s *ContextItemExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitContextItemExpr(s)
	}
}

func (p *XPath3Parser) ContextItemExpr() (localctx IContextItemExprContext) {
	localctx = NewContextItemExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, XPath3ParserRULE_contextItemExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(560)
		p.Match(XPath3ParserT__73)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionCallContext is an interface to support dynamic dispatch.
type IFunctionCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EqName() IEqNameContext
	ArgumentList() IArgumentListContext

	// IsFunctionCallContext differentiates from other interfaces.
	IsFunctionCallContext()
}

type FunctionCallContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionCallContext() *FunctionCallContext {
	var p = new(FunctionCallContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_functionCall
	return p
}

func InitEmptyFunctionCallContext(p *FunctionCallContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_functionCall
}

func (*FunctionCallContext) IsFunctionCallContext() {}

func NewFunctionCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallContext {
	var p = new(FunctionCallContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_functionCall

	return p
}

func (s *FunctionCallContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallContext) EqName() IEqNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqNameContext)
}

func (s *FunctionCallContext) ArgumentList() IArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterFunctionCall(s)
	}
}

func (s *FunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitFunctionCall(s)
	}
}

func (p *XPath3Parser) FunctionCall() (localctx IFunctionCallContext) {
	localctx = NewFunctionCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, XPath3ParserRULE_functionCall)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(562)
		p.EqName()
	}
	{
		p.SetState(563)
		p.ArgumentList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgumentContext is an interface to support dynamic dispatch.
type IArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExprSingle() IExprSingleContext
	ArgumentPlaceholder() IArgumentPlaceholderContext

	// IsArgumentContext differentiates from other interfaces.
	IsArgumentContext()
}

type ArgumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentContext() *ArgumentContext {
	var p = new(ArgumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_argument
	return p
}

func InitEmptyArgumentContext(p *ArgumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_argument
}

func (*ArgumentContext) IsArgumentContext() {}

func NewArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentContext {
	var p = new(ArgumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_argument

	return p
}

func (s *ArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentContext) ExprSingle() IExprSingleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprSingleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprSingleContext)
}

func (s *ArgumentContext) ArgumentPlaceholder() IArgumentPlaceholderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentPlaceholderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentPlaceholderContext)
}

func (s *ArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterArgument(s)
	}
}

func (s *ArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitArgument(s)
	}
}

func (p *XPath3Parser) Argument() (localctx IArgumentContext) {
	localctx = NewArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, XPath3ParserRULE_argument)
	p.SetState(567)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserT__1, XPath3ParserT__5, XPath3ParserT__7, XPath3ParserT__9, XPath3ParserT__10, XPath3ParserT__12, XPath3ParserT__13, XPath3ParserT__20, XPath3ParserT__21, XPath3ParserT__22, XPath3ParserT__52, XPath3ParserT__53, XPath3ParserT__54, XPath3ParserT__56, XPath3ParserT__57, XPath3ParserT__58, XPath3ParserT__59, XPath3ParserT__60, XPath3ParserT__61, XPath3ParserT__62, XPath3ParserT__63, XPath3ParserT__64, XPath3ParserT__65, XPath3ParserT__66, XPath3ParserT__67, XPath3ParserT__68, XPath3ParserT__69, XPath3ParserT__73, XPath3ParserT__76, XPath3ParserT__79, XPath3ParserT__80, XPath3ParserT__81, XPath3ParserT__82, XPath3ParserT__83, XPath3ParserT__84, XPath3ParserT__85, XPath3ParserT__86, XPath3ParserT__87, XPath3ParserT__88, XPath3ParserT__89, XPath3ParserNumericLiteral, XPath3ParserURIQualifiedName, XPath3ParserBracedURILiteral, XPath3ParserQNAME, XPath3ParserNC_NAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(565)
			p.ExprSingle()
		}

	case XPath3ParserT__74:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(566)
			p.ArgumentPlaceholder()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgumentPlaceholderContext is an interface to support dynamic dispatch.
type IArgumentPlaceholderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsArgumentPlaceholderContext differentiates from other interfaces.
	IsArgumentPlaceholderContext()
}

type ArgumentPlaceholderContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentPlaceholderContext() *ArgumentPlaceholderContext {
	var p = new(ArgumentPlaceholderContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_argumentPlaceholder
	return p
}

func InitEmptyArgumentPlaceholderContext(p *ArgumentPlaceholderContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_argumentPlaceholder
}

func (*ArgumentPlaceholderContext) IsArgumentPlaceholderContext() {}

func NewArgumentPlaceholderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentPlaceholderContext {
	var p = new(ArgumentPlaceholderContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_argumentPlaceholder

	return p
}

func (s *ArgumentPlaceholderContext) GetParser() antlr.Parser { return s.parser }
func (s *ArgumentPlaceholderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentPlaceholderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentPlaceholderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterArgumentPlaceholder(s)
	}
}

func (s *ArgumentPlaceholderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitArgumentPlaceholder(s)
	}
}

func (p *XPath3Parser) ArgumentPlaceholder() (localctx IArgumentPlaceholderContext) {
	localctx = NewArgumentPlaceholderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, XPath3ParserRULE_argumentPlaceholder)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(569)
		p.Match(XPath3ParserT__74)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionItemExprContext is an interface to support dynamic dispatch.
type IFunctionItemExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NamedFunctionRef() INamedFunctionRefContext
	InlineFunctionExpr() IInlineFunctionExprContext

	// IsFunctionItemExprContext differentiates from other interfaces.
	IsFunctionItemExprContext()
}

type FunctionItemExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionItemExprContext() *FunctionItemExprContext {
	var p = new(FunctionItemExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_functionItemExpr
	return p
}

func InitEmptyFunctionItemExprContext(p *FunctionItemExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_functionItemExpr
}

func (*FunctionItemExprContext) IsFunctionItemExprContext() {}

func NewFunctionItemExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionItemExprContext {
	var p = new(FunctionItemExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_functionItemExpr

	return p
}

func (s *FunctionItemExprContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionItemExprContext) NamedFunctionRef() INamedFunctionRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedFunctionRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedFunctionRefContext)
}

func (s *FunctionItemExprContext) InlineFunctionExpr() IInlineFunctionExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInlineFunctionExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInlineFunctionExprContext)
}

func (s *FunctionItemExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionItemExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionItemExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterFunctionItemExpr(s)
	}
}

func (s *FunctionItemExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitFunctionItemExpr(s)
	}
}

func (p *XPath3Parser) FunctionItemExpr() (localctx IFunctionItemExprContext) {
	localctx = NewFunctionItemExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, XPath3ParserRULE_functionItemExpr)
	p.SetState(573)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserURIQualifiedName, XPath3ParserQNAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(571)
			p.NamedFunctionRef()
		}

	case XPath3ParserT__76:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(572)
			p.InlineFunctionExpr()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedFunctionRefContext is an interface to support dynamic dispatch.
type INamedFunctionRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EqName() IEqNameContext
	IntegerLiteral() antlr.TerminalNode

	// IsNamedFunctionRefContext differentiates from other interfaces.
	IsNamedFunctionRefContext()
}

type NamedFunctionRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedFunctionRefContext() *NamedFunctionRefContext {
	var p = new(NamedFunctionRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_namedFunctionRef
	return p
}

func InitEmptyNamedFunctionRefContext(p *NamedFunctionRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_namedFunctionRef
}

func (*NamedFunctionRefContext) IsNamedFunctionRefContext() {}

func NewNamedFunctionRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedFunctionRefContext {
	var p = new(NamedFunctionRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_namedFunctionRef

	return p
}

func (s *NamedFunctionRefContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedFunctionRefContext) EqName() IEqNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqNameContext)
}

func (s *NamedFunctionRefContext) IntegerLiteral() antlr.TerminalNode {
	return s.GetToken(XPath3ParserIntegerLiteral, 0)
}

func (s *NamedFunctionRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedFunctionRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedFunctionRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterNamedFunctionRef(s)
	}
}

func (s *NamedFunctionRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitNamedFunctionRef(s)
	}
}

func (p *XPath3Parser) NamedFunctionRef() (localctx INamedFunctionRefContext) {
	localctx = NewNamedFunctionRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, XPath3ParserRULE_namedFunctionRef)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(575)
		p.EqName()
	}
	{
		p.SetState(576)
		p.Match(XPath3ParserT__75)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(577)
		p.Match(XPath3ParserIntegerLiteral)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInlineFunctionExprContext is an interface to support dynamic dispatch.
type IInlineFunctionExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionBody() IFunctionBodyContext
	ParamList() IParamListContext
	SequenceType() ISequenceTypeContext

	// IsInlineFunctionExprContext differentiates from other interfaces.
	IsInlineFunctionExprContext()
}

type InlineFunctionExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInlineFunctionExprContext() *InlineFunctionExprContext {
	var p = new(InlineFunctionExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_inlineFunctionExpr
	return p
}

func InitEmptyInlineFunctionExprContext(p *InlineFunctionExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_inlineFunctionExpr
}

func (*InlineFunctionExprContext) IsInlineFunctionExprContext() {}

func NewInlineFunctionExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InlineFunctionExprContext {
	var p = new(InlineFunctionExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_inlineFunctionExpr

	return p
}

func (s *InlineFunctionExprContext) GetParser() antlr.Parser { return s.parser }

func (s *InlineFunctionExprContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *InlineFunctionExprContext) ParamList() IParamListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParamListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParamListContext)
}

func (s *InlineFunctionExprContext) SequenceType() ISequenceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISequenceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISequenceTypeContext)
}

func (s *InlineFunctionExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlineFunctionExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InlineFunctionExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterInlineFunctionExpr(s)
	}
}

func (s *InlineFunctionExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitInlineFunctionExpr(s)
	}
}

func (p *XPath3Parser) InlineFunctionExpr() (localctx IInlineFunctionExprContext) {
	localctx = NewInlineFunctionExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, XPath3ParserRULE_inlineFunctionExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(579)
		p.Match(XPath3ParserT__76)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(580)
		p.Match(XPath3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(582)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == XPath3ParserT__1 {
		{
			p.SetState(581)
			p.ParamList()
		}

	}
	{
		p.SetState(584)
		p.Match(XPath3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(587)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == XPath3ParserT__33 {
		{
			p.SetState(585)
			p.Match(XPath3ParserT__33)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(586)
			p.SequenceType()
		}

	}
	{
		p.SetState(589)
		p.FunctionBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleTypeContext is an interface to support dynamic dispatch.
type ISingleTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleTypeName() ISimpleTypeNameContext

	// IsSingleTypeContext differentiates from other interfaces.
	IsSingleTypeContext()
}

type SingleTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleTypeContext() *SingleTypeContext {
	var p = new(SingleTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_singleType
	return p
}

func InitEmptySingleTypeContext(p *SingleTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_singleType
}

func (*SingleTypeContext) IsSingleTypeContext() {}

func NewSingleTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleTypeContext {
	var p = new(SingleTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_singleType

	return p
}

func (s *SingleTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleTypeContext) SimpleTypeName() ISimpleTypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleTypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleTypeNameContext)
}

func (s *SingleTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterSingleType(s)
	}
}

func (s *SingleTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitSingleType(s)
	}
}

func (p *XPath3Parser) SingleType() (localctx ISingleTypeContext) {
	localctx = NewSingleTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, XPath3ParserRULE_singleType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(591)
		p.SimpleTypeName()
	}
	p.SetState(593)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 48, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(592)
			p.Match(XPath3ParserT__74)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IType_declarationContext is an interface to support dynamic dispatch.
type IType_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SequenceType() ISequenceTypeContext

	// IsType_declarationContext differentiates from other interfaces.
	IsType_declarationContext()
}

type Type_declarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_declarationContext() *Type_declarationContext {
	var p = new(Type_declarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_type_declaration
	return p
}

func InitEmptyType_declarationContext(p *Type_declarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_type_declaration
}

func (*Type_declarationContext) IsType_declarationContext() {}

func NewType_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_declarationContext {
	var p = new(Type_declarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_type_declaration

	return p
}

func (s *Type_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_declarationContext) SequenceType() ISequenceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISequenceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISequenceTypeContext)
}

func (s *Type_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterType_declaration(s)
	}
}

func (s *Type_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitType_declaration(s)
	}
}

func (p *XPath3Parser) Type_declaration() (localctx IType_declarationContext) {
	localctx = NewType_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, XPath3ParserRULE_type_declaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(595)
		p.Match(XPath3ParserT__33)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(596)
		p.SequenceType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISequenceTypeContext is an interface to support dynamic dispatch.
type ISequenceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ItemType() IItemTypeContext
	OccurenceIndicator() IOccurenceIndicatorContext

	// IsSequenceTypeContext differentiates from other interfaces.
	IsSequenceTypeContext()
}

type SequenceTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequenceTypeContext() *SequenceTypeContext {
	var p = new(SequenceTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_sequenceType
	return p
}

func InitEmptySequenceTypeContext(p *SequenceTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_sequenceType
}

func (*SequenceTypeContext) IsSequenceTypeContext() {}

func NewSequenceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SequenceTypeContext {
	var p = new(SequenceTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_sequenceType

	return p
}

func (s *SequenceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SequenceTypeContext) ItemType() IItemTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IItemTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IItemTypeContext)
}

func (s *SequenceTypeContext) OccurenceIndicator() IOccurenceIndicatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOccurenceIndicatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOccurenceIndicatorContext)
}

func (s *SequenceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SequenceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SequenceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterSequenceType(s)
	}
}

func (s *SequenceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitSequenceType(s)
	}
}

func (p *XPath3Parser) SequenceType() (localctx ISequenceTypeContext) {
	localctx = NewSequenceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, XPath3ParserRULE_sequenceType)
	p.SetState(605)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserT__77:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(598)
			p.Match(XPath3ParserT__77)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(599)
			p.Match(XPath3ParserT__13)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(600)
			p.Match(XPath3ParserT__14)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case XPath3ParserT__13, XPath3ParserT__57, XPath3ParserT__76, XPath3ParserT__78, XPath3ParserT__79, XPath3ParserT__80, XPath3ParserT__81, XPath3ParserT__82, XPath3ParserT__83, XPath3ParserT__84, XPath3ParserT__85, XPath3ParserT__86, XPath3ParserT__87, XPath3ParserURIQualifiedName, XPath3ParserQNAME:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(601)
			p.ItemType()
		}
		p.SetState(603)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 49, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(602)
				p.OccurenceIndicator()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOccurenceIndicatorContext is an interface to support dynamic dispatch.
type IOccurenceIndicatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsOccurenceIndicatorContext differentiates from other interfaces.
	IsOccurenceIndicatorContext()
}

type OccurenceIndicatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOccurenceIndicatorContext() *OccurenceIndicatorContext {
	var p = new(OccurenceIndicatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_occurenceIndicator
	return p
}

func InitEmptyOccurenceIndicatorContext(p *OccurenceIndicatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_occurenceIndicator
}

func (*OccurenceIndicatorContext) IsOccurenceIndicatorContext() {}

func NewOccurenceIndicatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OccurenceIndicatorContext {
	var p = new(OccurenceIndicatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_occurenceIndicator

	return p
}

func (s *OccurenceIndicatorContext) GetParser() antlr.Parser { return s.parser }
func (s *OccurenceIndicatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OccurenceIndicatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OccurenceIndicatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterOccurenceIndicator(s)
	}
}

func (s *OccurenceIndicatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitOccurenceIndicator(s)
	}
}

func (p *XPath3Parser) OccurenceIndicator() (localctx IOccurenceIndicatorContext) {
	localctx = NewOccurenceIndicatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, XPath3ParserRULE_occurenceIndicator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(607)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-21)) & ^0x3f) == 0 && ((int64(1)<<(_la-21))&18014398509481989) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IItemTypeContext is an interface to support dynamic dispatch.
type IItemTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KindTest() IKindTestContext
	FunctionTest() IFunctionTestContext
	AtomicOrUnionType() IAtomicOrUnionTypeContext
	ParenthesizedItemType() IParenthesizedItemTypeContext

	// IsItemTypeContext differentiates from other interfaces.
	IsItemTypeContext()
}

type ItemTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyItemTypeContext() *ItemTypeContext {
	var p = new(ItemTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_itemType
	return p
}

func InitEmptyItemTypeContext(p *ItemTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_itemType
}

func (*ItemTypeContext) IsItemTypeContext() {}

func NewItemTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ItemTypeContext {
	var p = new(ItemTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_itemType

	return p
}

func (s *ItemTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ItemTypeContext) KindTest() IKindTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKindTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKindTestContext)
}

func (s *ItemTypeContext) FunctionTest() IFunctionTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionTestContext)
}

func (s *ItemTypeContext) AtomicOrUnionType() IAtomicOrUnionTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAtomicOrUnionTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAtomicOrUnionTypeContext)
}

func (s *ItemTypeContext) ParenthesizedItemType() IParenthesizedItemTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesizedItemTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesizedItemTypeContext)
}

func (s *ItemTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ItemTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ItemTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterItemType(s)
	}
}

func (s *ItemTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitItemType(s)
	}
}

func (p *XPath3Parser) ItemType() (localctx IItemTypeContext) {
	localctx = NewItemTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, XPath3ParserRULE_itemType)
	p.SetState(616)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserT__57, XPath3ParserT__79, XPath3ParserT__80, XPath3ParserT__81, XPath3ParserT__82, XPath3ParserT__83, XPath3ParserT__84, XPath3ParserT__85, XPath3ParserT__86, XPath3ParserT__87:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(609)
			p.KindTest()
		}

	case XPath3ParserT__78:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(610)
			p.Match(XPath3ParserT__78)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(611)
			p.Match(XPath3ParserT__13)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(612)
			p.Match(XPath3ParserT__14)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case XPath3ParserT__76:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(613)
			p.FunctionTest()
		}

	case XPath3ParserURIQualifiedName, XPath3ParserQNAME:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(614)
			p.AtomicOrUnionType()
		}

	case XPath3ParserT__13:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(615)
			p.ParenthesizedItemType()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAtomicOrUnionTypeContext is an interface to support dynamic dispatch.
type IAtomicOrUnionTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EqName() IEqNameContext

	// IsAtomicOrUnionTypeContext differentiates from other interfaces.
	IsAtomicOrUnionTypeContext()
}

type AtomicOrUnionTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomicOrUnionTypeContext() *AtomicOrUnionTypeContext {
	var p = new(AtomicOrUnionTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_atomicOrUnionType
	return p
}

func InitEmptyAtomicOrUnionTypeContext(p *AtomicOrUnionTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_atomicOrUnionType
}

func (*AtomicOrUnionTypeContext) IsAtomicOrUnionTypeContext() {}

func NewAtomicOrUnionTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomicOrUnionTypeContext {
	var p = new(AtomicOrUnionTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_atomicOrUnionType

	return p
}

func (s *AtomicOrUnionTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomicOrUnionTypeContext) EqName() IEqNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqNameContext)
}

func (s *AtomicOrUnionTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomicOrUnionTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomicOrUnionTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterAtomicOrUnionType(s)
	}
}

func (s *AtomicOrUnionTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitAtomicOrUnionType(s)
	}
}

func (p *XPath3Parser) AtomicOrUnionType() (localctx IAtomicOrUnionTypeContext) {
	localctx = NewAtomicOrUnionTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, XPath3ParserRULE_atomicOrUnionType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(618)
		p.EqName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKindTestContext is an interface to support dynamic dispatch.
type IKindTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DocumentTest() IDocumentTestContext
	ElementTest() IElementTestContext
	AttributeTest() IAttributeTestContext
	SchemaElementTest() ISchemaElementTestContext
	SchemaAttributeTest() ISchemaAttributeTestContext
	PiTest() IPiTestContext
	CommentTest() ICommentTestContext
	TextTest() ITextTestContext
	NamespaceNodeTest() INamespaceNodeTestContext
	AnyKindTest() IAnyKindTestContext

	// IsKindTestContext differentiates from other interfaces.
	IsKindTestContext()
}

type KindTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKindTestContext() *KindTestContext {
	var p = new(KindTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_kindTest
	return p
}

func InitEmptyKindTestContext(p *KindTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_kindTest
}

func (*KindTestContext) IsKindTestContext() {}

func NewKindTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KindTestContext {
	var p = new(KindTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_kindTest

	return p
}

func (s *KindTestContext) GetParser() antlr.Parser { return s.parser }

func (s *KindTestContext) DocumentTest() IDocumentTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDocumentTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDocumentTestContext)
}

func (s *KindTestContext) ElementTest() IElementTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementTestContext)
}

func (s *KindTestContext) AttributeTest() IAttributeTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeTestContext)
}

func (s *KindTestContext) SchemaElementTest() ISchemaElementTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISchemaElementTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISchemaElementTestContext)
}

func (s *KindTestContext) SchemaAttributeTest() ISchemaAttributeTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISchemaAttributeTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISchemaAttributeTestContext)
}

func (s *KindTestContext) PiTest() IPiTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPiTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPiTestContext)
}

func (s *KindTestContext) CommentTest() ICommentTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentTestContext)
}

func (s *KindTestContext) TextTest() ITextTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextTestContext)
}

func (s *KindTestContext) NamespaceNodeTest() INamespaceNodeTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceNodeTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceNodeTestContext)
}

func (s *KindTestContext) AnyKindTest() IAnyKindTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnyKindTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnyKindTestContext)
}

func (s *KindTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KindTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KindTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterKindTest(s)
	}
}

func (s *KindTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitKindTest(s)
	}
}

func (p *XPath3Parser) KindTest() (localctx IKindTestContext) {
	localctx = NewKindTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, XPath3ParserRULE_kindTest)
	p.SetState(630)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserT__80:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(620)
			p.DocumentTest()
		}

	case XPath3ParserT__86:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(621)
			p.ElementTest()
		}

	case XPath3ParserT__57:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(622)
			p.AttributeTest()
		}

	case XPath3ParserT__87:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(623)
			p.SchemaElementTest()
		}

	case XPath3ParserT__85:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(624)
			p.SchemaAttributeTest()
		}

	case XPath3ParserT__84:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(625)
			p.PiTest()
		}

	case XPath3ParserT__82:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(626)
			p.CommentTest()
		}

	case XPath3ParserT__81:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(627)
			p.TextTest()
		}

	case XPath3ParserT__83:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(628)
			p.NamespaceNodeTest()
		}

	case XPath3ParserT__79:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(629)
			p.AnyKindTest()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnyKindTestContext is an interface to support dynamic dispatch.
type IAnyKindTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAnyKindTestContext differentiates from other interfaces.
	IsAnyKindTestContext()
}

type AnyKindTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnyKindTestContext() *AnyKindTestContext {
	var p = new(AnyKindTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_anyKindTest
	return p
}

func InitEmptyAnyKindTestContext(p *AnyKindTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_anyKindTest
}

func (*AnyKindTestContext) IsAnyKindTestContext() {}

func NewAnyKindTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnyKindTestContext {
	var p = new(AnyKindTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_anyKindTest

	return p
}

func (s *AnyKindTestContext) GetParser() antlr.Parser { return s.parser }
func (s *AnyKindTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnyKindTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnyKindTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterAnyKindTest(s)
	}
}

func (s *AnyKindTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitAnyKindTest(s)
	}
}

func (p *XPath3Parser) AnyKindTest() (localctx IAnyKindTestContext) {
	localctx = NewAnyKindTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, XPath3ParserRULE_anyKindTest)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(632)
		p.Match(XPath3ParserT__79)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(633)
		p.Match(XPath3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(634)
		p.Match(XPath3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDocumentTestContext is an interface to support dynamic dispatch.
type IDocumentTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ElementTest() IElementTestContext
	SchemaElementTest() ISchemaElementTestContext

	// IsDocumentTestContext differentiates from other interfaces.
	IsDocumentTestContext()
}

type DocumentTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDocumentTestContext() *DocumentTestContext {
	var p = new(DocumentTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_documentTest
	return p
}

func InitEmptyDocumentTestContext(p *DocumentTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_documentTest
}

func (*DocumentTestContext) IsDocumentTestContext() {}

func NewDocumentTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DocumentTestContext {
	var p = new(DocumentTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_documentTest

	return p
}

func (s *DocumentTestContext) GetParser() antlr.Parser { return s.parser }

func (s *DocumentTestContext) ElementTest() IElementTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementTestContext)
}

func (s *DocumentTestContext) SchemaElementTest() ISchemaElementTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISchemaElementTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISchemaElementTestContext)
}

func (s *DocumentTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DocumentTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DocumentTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterDocumentTest(s)
	}
}

func (s *DocumentTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitDocumentTest(s)
	}
}

func (p *XPath3Parser) DocumentTest() (localctx IDocumentTestContext) {
	localctx = NewDocumentTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, XPath3ParserRULE_documentTest)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(636)
		p.Match(XPath3ParserT__80)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(637)
		p.Match(XPath3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(640)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case XPath3ParserT__86:
		{
			p.SetState(638)
			p.ElementTest()
		}

	case XPath3ParserT__87:
		{
			p.SetState(639)
			p.SchemaElementTest()
		}

	case XPath3ParserT__14:

	default:
	}
	{
		p.SetState(642)
		p.Match(XPath3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITextTestContext is an interface to support dynamic dispatch.
type ITextTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTextTestContext differentiates from other interfaces.
	IsTextTestContext()
}

type TextTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTextTestContext() *TextTestContext {
	var p = new(TextTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_textTest
	return p
}

func InitEmptyTextTestContext(p *TextTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_textTest
}

func (*TextTestContext) IsTextTestContext() {}

func NewTextTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TextTestContext {
	var p = new(TextTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_textTest

	return p
}

func (s *TextTestContext) GetParser() antlr.Parser { return s.parser }
func (s *TextTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TextTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TextTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterTextTest(s)
	}
}

func (s *TextTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitTextTest(s)
	}
}

func (p *XPath3Parser) TextTest() (localctx ITextTestContext) {
	localctx = NewTextTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, XPath3ParserRULE_textTest)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(644)
		p.Match(XPath3ParserT__81)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(645)
		p.Match(XPath3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(646)
		p.Match(XPath3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommentTestContext is an interface to support dynamic dispatch.
type ICommentTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsCommentTestContext differentiates from other interfaces.
	IsCommentTestContext()
}

type CommentTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommentTestContext() *CommentTestContext {
	var p = new(CommentTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_commentTest
	return p
}

func InitEmptyCommentTestContext(p *CommentTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_commentTest
}

func (*CommentTestContext) IsCommentTestContext() {}

func NewCommentTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommentTestContext {
	var p = new(CommentTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_commentTest

	return p
}

func (s *CommentTestContext) GetParser() antlr.Parser { return s.parser }
func (s *CommentTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommentTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterCommentTest(s)
	}
}

func (s *CommentTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitCommentTest(s)
	}
}

func (p *XPath3Parser) CommentTest() (localctx ICommentTestContext) {
	localctx = NewCommentTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, XPath3ParserRULE_commentTest)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(648)
		p.Match(XPath3ParserT__82)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(649)
		p.Match(XPath3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(650)
		p.Match(XPath3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamespaceNodeTestContext is an interface to support dynamic dispatch.
type INamespaceNodeTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsNamespaceNodeTestContext differentiates from other interfaces.
	IsNamespaceNodeTestContext()
}

type NamespaceNodeTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamespaceNodeTestContext() *NamespaceNodeTestContext {
	var p = new(NamespaceNodeTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_namespaceNodeTest
	return p
}

func InitEmptyNamespaceNodeTestContext(p *NamespaceNodeTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_namespaceNodeTest
}

func (*NamespaceNodeTestContext) IsNamespaceNodeTestContext() {}

func NewNamespaceNodeTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamespaceNodeTestContext {
	var p = new(NamespaceNodeTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_namespaceNodeTest

	return p
}

func (s *NamespaceNodeTestContext) GetParser() antlr.Parser { return s.parser }
func (s *NamespaceNodeTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamespaceNodeTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamespaceNodeTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterNamespaceNodeTest(s)
	}
}

func (s *NamespaceNodeTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitNamespaceNodeTest(s)
	}
}

func (p *XPath3Parser) NamespaceNodeTest() (localctx INamespaceNodeTestContext) {
	localctx = NewNamespaceNodeTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, XPath3ParserRULE_namespaceNodeTest)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(652)
		p.Match(XPath3ParserT__83)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(653)
		p.Match(XPath3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(654)
		p.Match(XPath3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPiTestContext is an interface to support dynamic dispatch.
type IPiTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NC_NAME() antlr.TerminalNode
	StringLiteral() IStringLiteralContext

	// IsPiTestContext differentiates from other interfaces.
	IsPiTestContext()
}

type PiTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPiTestContext() *PiTestContext {
	var p = new(PiTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_piTest
	return p
}

func InitEmptyPiTestContext(p *PiTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_piTest
}

func (*PiTestContext) IsPiTestContext() {}

func NewPiTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PiTestContext {
	var p = new(PiTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_piTest

	return p
}

func (s *PiTestContext) GetParser() antlr.Parser { return s.parser }

func (s *PiTestContext) NC_NAME() antlr.TerminalNode {
	return s.GetToken(XPath3ParserNC_NAME, 0)
}

func (s *PiTestContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *PiTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PiTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PiTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterPiTest(s)
	}
}

func (s *PiTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitPiTest(s)
	}
}

func (p *XPath3Parser) PiTest() (localctx IPiTestContext) {
	localctx = NewPiTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, XPath3ParserRULE_piTest)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(656)
		p.Match(XPath3ParserT__84)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(657)
		p.Match(XPath3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(660)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case XPath3ParserNC_NAME:
		{
			p.SetState(658)
			p.Match(XPath3ParserNC_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case XPath3ParserT__88, XPath3ParserT__89:
		{
			p.SetState(659)
			p.StringLiteral()
		}

	case XPath3ParserT__14:

	default:
	}
	{
		p.SetState(662)
		p.Match(XPath3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeTestContext is an interface to support dynamic dispatch.
type IAttributeTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AttribNameOrWildcard() IAttribNameOrWildcardContext
	TypeName() ITypeNameContext

	// IsAttributeTestContext differentiates from other interfaces.
	IsAttributeTestContext()
}

type AttributeTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeTestContext() *AttributeTestContext {
	var p = new(AttributeTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_attributeTest
	return p
}

func InitEmptyAttributeTestContext(p *AttributeTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_attributeTest
}

func (*AttributeTestContext) IsAttributeTestContext() {}

func NewAttributeTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeTestContext {
	var p = new(AttributeTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_attributeTest

	return p
}

func (s *AttributeTestContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeTestContext) AttribNameOrWildcard() IAttribNameOrWildcardContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttribNameOrWildcardContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttribNameOrWildcardContext)
}

func (s *AttributeTestContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *AttributeTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterAttributeTest(s)
	}
}

func (s *AttributeTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitAttributeTest(s)
	}
}

func (p *XPath3Parser) AttributeTest() (localctx IAttributeTestContext) {
	localctx = NewAttributeTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, XPath3ParserRULE_attributeTest)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(664)
		p.Match(XPath3ParserT__57)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(665)
		p.Match(XPath3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(671)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == XPath3ParserT__22 || _la == XPath3ParserURIQualifiedName || _la == XPath3ParserQNAME {
		{
			p.SetState(666)
			p.AttribNameOrWildcard()
		}
		p.SetState(669)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == XPath3ParserT__0 {
			{
				p.SetState(667)
				p.Match(XPath3ParserT__0)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(668)
				p.TypeName()
			}

		}

	}
	{
		p.SetState(673)
		p.Match(XPath3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttribNameOrWildcardContext is an interface to support dynamic dispatch.
type IAttribNameOrWildcardContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AttributeName() IAttributeNameContext

	// IsAttribNameOrWildcardContext differentiates from other interfaces.
	IsAttribNameOrWildcardContext()
}

type AttribNameOrWildcardContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttribNameOrWildcardContext() *AttribNameOrWildcardContext {
	var p = new(AttribNameOrWildcardContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_attribNameOrWildcard
	return p
}

func InitEmptyAttribNameOrWildcardContext(p *AttribNameOrWildcardContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_attribNameOrWildcard
}

func (*AttribNameOrWildcardContext) IsAttribNameOrWildcardContext() {}

func NewAttribNameOrWildcardContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttribNameOrWildcardContext {
	var p = new(AttribNameOrWildcardContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_attribNameOrWildcard

	return p
}

func (s *AttribNameOrWildcardContext) GetParser() antlr.Parser { return s.parser }

func (s *AttribNameOrWildcardContext) AttributeName() IAttributeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeNameContext)
}

func (s *AttribNameOrWildcardContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttribNameOrWildcardContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttribNameOrWildcardContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterAttribNameOrWildcard(s)
	}
}

func (s *AttribNameOrWildcardContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitAttribNameOrWildcard(s)
	}
}

func (p *XPath3Parser) AttribNameOrWildcard() (localctx IAttribNameOrWildcardContext) {
	localctx = NewAttribNameOrWildcardContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, XPath3ParserRULE_attribNameOrWildcard)
	p.SetState(677)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserURIQualifiedName, XPath3ParserQNAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(675)
			p.AttributeName()
		}

	case XPath3ParserT__22:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(676)
			p.Match(XPath3ParserT__22)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISchemaAttributeTestContext is an interface to support dynamic dispatch.
type ISchemaAttributeTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AttributeDeclaration() IAttributeDeclarationContext

	// IsSchemaAttributeTestContext differentiates from other interfaces.
	IsSchemaAttributeTestContext()
}

type SchemaAttributeTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySchemaAttributeTestContext() *SchemaAttributeTestContext {
	var p = new(SchemaAttributeTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_schemaAttributeTest
	return p
}

func InitEmptySchemaAttributeTestContext(p *SchemaAttributeTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_schemaAttributeTest
}

func (*SchemaAttributeTestContext) IsSchemaAttributeTestContext() {}

func NewSchemaAttributeTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SchemaAttributeTestContext {
	var p = new(SchemaAttributeTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_schemaAttributeTest

	return p
}

func (s *SchemaAttributeTestContext) GetParser() antlr.Parser { return s.parser }

func (s *SchemaAttributeTestContext) AttributeDeclaration() IAttributeDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeDeclarationContext)
}

func (s *SchemaAttributeTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SchemaAttributeTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SchemaAttributeTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterSchemaAttributeTest(s)
	}
}

func (s *SchemaAttributeTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitSchemaAttributeTest(s)
	}
}

func (p *XPath3Parser) SchemaAttributeTest() (localctx ISchemaAttributeTestContext) {
	localctx = NewSchemaAttributeTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, XPath3ParserRULE_schemaAttributeTest)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(679)
		p.Match(XPath3ParserT__85)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(680)
		p.Match(XPath3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(681)
		p.AttributeDeclaration()
	}
	{
		p.SetState(682)
		p.Match(XPath3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeDeclarationContext is an interface to support dynamic dispatch.
type IAttributeDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AttributeName() IAttributeNameContext

	// IsAttributeDeclarationContext differentiates from other interfaces.
	IsAttributeDeclarationContext()
}

type AttributeDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeDeclarationContext() *AttributeDeclarationContext {
	var p = new(AttributeDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_attributeDeclaration
	return p
}

func InitEmptyAttributeDeclarationContext(p *AttributeDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_attributeDeclaration
}

func (*AttributeDeclarationContext) IsAttributeDeclarationContext() {}

func NewAttributeDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeDeclarationContext {
	var p = new(AttributeDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_attributeDeclaration

	return p
}

func (s *AttributeDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeDeclarationContext) AttributeName() IAttributeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeNameContext)
}

func (s *AttributeDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterAttributeDeclaration(s)
	}
}

func (s *AttributeDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitAttributeDeclaration(s)
	}
}

func (p *XPath3Parser) AttributeDeclaration() (localctx IAttributeDeclarationContext) {
	localctx = NewAttributeDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, XPath3ParserRULE_attributeDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(684)
		p.AttributeName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementTestContext is an interface to support dynamic dispatch.
type IElementTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ElementNameOrWildcard() IElementNameOrWildcardContext
	TypeName() ITypeNameContext

	// IsElementTestContext differentiates from other interfaces.
	IsElementTestContext()
}

type ElementTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementTestContext() *ElementTestContext {
	var p = new(ElementTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_elementTest
	return p
}

func InitEmptyElementTestContext(p *ElementTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_elementTest
}

func (*ElementTestContext) IsElementTestContext() {}

func NewElementTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementTestContext {
	var p = new(ElementTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_elementTest

	return p
}

func (s *ElementTestContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementTestContext) ElementNameOrWildcard() IElementNameOrWildcardContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementNameOrWildcardContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementNameOrWildcardContext)
}

func (s *ElementTestContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *ElementTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterElementTest(s)
	}
}

func (s *ElementTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitElementTest(s)
	}
}

func (p *XPath3Parser) ElementTest() (localctx IElementTestContext) {
	localctx = NewElementTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, XPath3ParserRULE_elementTest)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(686)
		p.Match(XPath3ParserT__86)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(687)
		p.Match(XPath3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(696)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == XPath3ParserT__22 || _la == XPath3ParserURIQualifiedName || _la == XPath3ParserQNAME {
		{
			p.SetState(688)
			p.ElementNameOrWildcard()
		}
		p.SetState(694)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == XPath3ParserT__0 {
			{
				p.SetState(689)
				p.Match(XPath3ParserT__0)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(690)
				p.TypeName()
			}
			p.SetState(692)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == XPath3ParserT__74 {
				{
					p.SetState(691)
					p.Match(XPath3ParserT__74)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		}

	}
	{
		p.SetState(698)
		p.Match(XPath3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementNameOrWildcardContext is an interface to support dynamic dispatch.
type IElementNameOrWildcardContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ElementName() IElementNameContext

	// IsElementNameOrWildcardContext differentiates from other interfaces.
	IsElementNameOrWildcardContext()
}

type ElementNameOrWildcardContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementNameOrWildcardContext() *ElementNameOrWildcardContext {
	var p = new(ElementNameOrWildcardContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_elementNameOrWildcard
	return p
}

func InitEmptyElementNameOrWildcardContext(p *ElementNameOrWildcardContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_elementNameOrWildcard
}

func (*ElementNameOrWildcardContext) IsElementNameOrWildcardContext() {}

func NewElementNameOrWildcardContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementNameOrWildcardContext {
	var p = new(ElementNameOrWildcardContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_elementNameOrWildcard

	return p
}

func (s *ElementNameOrWildcardContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementNameOrWildcardContext) ElementName() IElementNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementNameContext)
}

func (s *ElementNameOrWildcardContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementNameOrWildcardContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementNameOrWildcardContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterElementNameOrWildcard(s)
	}
}

func (s *ElementNameOrWildcardContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitElementNameOrWildcard(s)
	}
}

func (p *XPath3Parser) ElementNameOrWildcard() (localctx IElementNameOrWildcardContext) {
	localctx = NewElementNameOrWildcardContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, XPath3ParserRULE_elementNameOrWildcard)
	p.SetState(702)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserURIQualifiedName, XPath3ParserQNAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(700)
			p.ElementName()
		}

	case XPath3ParserT__22:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(701)
			p.Match(XPath3ParserT__22)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISchemaElementTestContext is an interface to support dynamic dispatch.
type ISchemaElementTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ElementDeclaration() IElementDeclarationContext

	// IsSchemaElementTestContext differentiates from other interfaces.
	IsSchemaElementTestContext()
}

type SchemaElementTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySchemaElementTestContext() *SchemaElementTestContext {
	var p = new(SchemaElementTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_schemaElementTest
	return p
}

func InitEmptySchemaElementTestContext(p *SchemaElementTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_schemaElementTest
}

func (*SchemaElementTestContext) IsSchemaElementTestContext() {}

func NewSchemaElementTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SchemaElementTestContext {
	var p = new(SchemaElementTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_schemaElementTest

	return p
}

func (s *SchemaElementTestContext) GetParser() antlr.Parser { return s.parser }

func (s *SchemaElementTestContext) ElementDeclaration() IElementDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementDeclarationContext)
}

func (s *SchemaElementTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SchemaElementTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SchemaElementTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterSchemaElementTest(s)
	}
}

func (s *SchemaElementTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitSchemaElementTest(s)
	}
}

func (p *XPath3Parser) SchemaElementTest() (localctx ISchemaElementTestContext) {
	localctx = NewSchemaElementTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, XPath3ParserRULE_schemaElementTest)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(704)
		p.Match(XPath3ParserT__87)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(705)
		p.Match(XPath3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(706)
		p.ElementDeclaration()
	}
	{
		p.SetState(707)
		p.Match(XPath3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementDeclarationContext is an interface to support dynamic dispatch.
type IElementDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ElementName() IElementNameContext

	// IsElementDeclarationContext differentiates from other interfaces.
	IsElementDeclarationContext()
}

type ElementDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementDeclarationContext() *ElementDeclarationContext {
	var p = new(ElementDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_elementDeclaration
	return p
}

func InitEmptyElementDeclarationContext(p *ElementDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_elementDeclaration
}

func (*ElementDeclarationContext) IsElementDeclarationContext() {}

func NewElementDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementDeclarationContext {
	var p = new(ElementDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_elementDeclaration

	return p
}

func (s *ElementDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementDeclarationContext) ElementName() IElementNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementNameContext)
}

func (s *ElementDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterElementDeclaration(s)
	}
}

func (s *ElementDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitElementDeclaration(s)
	}
}

func (p *XPath3Parser) ElementDeclaration() (localctx IElementDeclarationContext) {
	localctx = NewElementDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, XPath3ParserRULE_elementDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(709)
		p.ElementName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeNameContext is an interface to support dynamic dispatch.
type IAttributeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EqName() IEqNameContext

	// IsAttributeNameContext differentiates from other interfaces.
	IsAttributeNameContext()
}

type AttributeNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeNameContext() *AttributeNameContext {
	var p = new(AttributeNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_attributeName
	return p
}

func InitEmptyAttributeNameContext(p *AttributeNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_attributeName
}

func (*AttributeNameContext) IsAttributeNameContext() {}

func NewAttributeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeNameContext {
	var p = new(AttributeNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_attributeName

	return p
}

func (s *AttributeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeNameContext) EqName() IEqNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqNameContext)
}

func (s *AttributeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterAttributeName(s)
	}
}

func (s *AttributeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitAttributeName(s)
	}
}

func (p *XPath3Parser) AttributeName() (localctx IAttributeNameContext) {
	localctx = NewAttributeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, XPath3ParserRULE_attributeName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(711)
		p.EqName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementNameContext is an interface to support dynamic dispatch.
type IElementNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EqName() IEqNameContext

	// IsElementNameContext differentiates from other interfaces.
	IsElementNameContext()
}

type ElementNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementNameContext() *ElementNameContext {
	var p = new(ElementNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_elementName
	return p
}

func InitEmptyElementNameContext(p *ElementNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_elementName
}

func (*ElementNameContext) IsElementNameContext() {}

func NewElementNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementNameContext {
	var p = new(ElementNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_elementName

	return p
}

func (s *ElementNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementNameContext) EqName() IEqNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqNameContext)
}

func (s *ElementNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterElementName(s)
	}
}

func (s *ElementNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitElementName(s)
	}
}

func (p *XPath3Parser) ElementName() (localctx IElementNameContext) {
	localctx = NewElementNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, XPath3ParserRULE_elementName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(713)
		p.EqName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleTypeNameContext is an interface to support dynamic dispatch.
type ISimpleTypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeName() ITypeNameContext

	// IsSimpleTypeNameContext differentiates from other interfaces.
	IsSimpleTypeNameContext()
}

type SimpleTypeNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleTypeNameContext() *SimpleTypeNameContext {
	var p = new(SimpleTypeNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_simpleTypeName
	return p
}

func InitEmptySimpleTypeNameContext(p *SimpleTypeNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_simpleTypeName
}

func (*SimpleTypeNameContext) IsSimpleTypeNameContext() {}

func NewSimpleTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleTypeNameContext {
	var p = new(SimpleTypeNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_simpleTypeName

	return p
}

func (s *SimpleTypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleTypeNameContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *SimpleTypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleTypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleTypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterSimpleTypeName(s)
	}
}

func (s *SimpleTypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitSimpleTypeName(s)
	}
}

func (p *XPath3Parser) SimpleTypeName() (localctx ISimpleTypeNameContext) {
	localctx = NewSimpleTypeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, XPath3ParserRULE_simpleTypeName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(715)
		p.TypeName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeNameContext is an interface to support dynamic dispatch.
type ITypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QNAME() antlr.TerminalNode

	// IsTypeNameContext differentiates from other interfaces.
	IsTypeNameContext()
}

type TypeNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeNameContext() *TypeNameContext {
	var p = new(TypeNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_typeName
	return p
}

func InitEmptyTypeNameContext(p *TypeNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_typeName
}

func (*TypeNameContext) IsTypeNameContext() {}

func NewTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeNameContext {
	var p = new(TypeNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_typeName

	return p
}

func (s *TypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeNameContext) QNAME() antlr.TerminalNode {
	return s.GetToken(XPath3ParserQNAME, 0)
}

func (s *TypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterTypeName(s)
	}
}

func (s *TypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitTypeName(s)
	}
}

func (p *XPath3Parser) TypeName() (localctx ITypeNameContext) {
	localctx = NewTypeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, XPath3ParserRULE_typeName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(717)
		p.Match(XPath3ParserQNAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionTestContext is an interface to support dynamic dispatch.
type IFunctionTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AnyFunctionTest() IAnyFunctionTestContext
	TypedFunctionTest() ITypedFunctionTestContext

	// IsFunctionTestContext differentiates from other interfaces.
	IsFunctionTestContext()
}

type FunctionTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionTestContext() *FunctionTestContext {
	var p = new(FunctionTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_functionTest
	return p
}

func InitEmptyFunctionTestContext(p *FunctionTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_functionTest
}

func (*FunctionTestContext) IsFunctionTestContext() {}

func NewFunctionTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionTestContext {
	var p = new(FunctionTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_functionTest

	return p
}

func (s *FunctionTestContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionTestContext) AnyFunctionTest() IAnyFunctionTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnyFunctionTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnyFunctionTestContext)
}

func (s *FunctionTestContext) TypedFunctionTest() ITypedFunctionTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedFunctionTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedFunctionTestContext)
}

func (s *FunctionTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterFunctionTest(s)
	}
}

func (s *FunctionTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitFunctionTest(s)
	}
}

func (p *XPath3Parser) FunctionTest() (localctx IFunctionTestContext) {
	localctx = NewFunctionTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, XPath3ParserRULE_functionTest)
	p.SetState(721)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 62, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(719)
			p.AnyFunctionTest()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(720)
			p.TypedFunctionTest()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnyFunctionTestContext is an interface to support dynamic dispatch.
type IAnyFunctionTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAnyFunctionTestContext differentiates from other interfaces.
	IsAnyFunctionTestContext()
}

type AnyFunctionTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnyFunctionTestContext() *AnyFunctionTestContext {
	var p = new(AnyFunctionTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_anyFunctionTest
	return p
}

func InitEmptyAnyFunctionTestContext(p *AnyFunctionTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_anyFunctionTest
}

func (*AnyFunctionTestContext) IsAnyFunctionTestContext() {}

func NewAnyFunctionTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnyFunctionTestContext {
	var p = new(AnyFunctionTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_anyFunctionTest

	return p
}

func (s *AnyFunctionTestContext) GetParser() antlr.Parser { return s.parser }
func (s *AnyFunctionTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnyFunctionTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnyFunctionTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterAnyFunctionTest(s)
	}
}

func (s *AnyFunctionTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitAnyFunctionTest(s)
	}
}

func (p *XPath3Parser) AnyFunctionTest() (localctx IAnyFunctionTestContext) {
	localctx = NewAnyFunctionTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, XPath3ParserRULE_anyFunctionTest)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(723)
		p.Match(XPath3ParserT__76)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(724)
		p.Match(XPath3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(725)
		p.Match(XPath3ParserT__22)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(726)
		p.Match(XPath3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypedFunctionTestContext is an interface to support dynamic dispatch.
type ITypedFunctionTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSequenceType() []ISequenceTypeContext
	SequenceType(i int) ISequenceTypeContext

	// IsTypedFunctionTestContext differentiates from other interfaces.
	IsTypedFunctionTestContext()
}

type TypedFunctionTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypedFunctionTestContext() *TypedFunctionTestContext {
	var p = new(TypedFunctionTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_typedFunctionTest
	return p
}

func InitEmptyTypedFunctionTestContext(p *TypedFunctionTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_typedFunctionTest
}

func (*TypedFunctionTestContext) IsTypedFunctionTestContext() {}

func NewTypedFunctionTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypedFunctionTestContext {
	var p = new(TypedFunctionTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_typedFunctionTest

	return p
}

func (s *TypedFunctionTestContext) GetParser() antlr.Parser { return s.parser }

func (s *TypedFunctionTestContext) AllSequenceType() []ISequenceTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISequenceTypeContext); ok {
			len++
		}
	}

	tst := make([]ISequenceTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISequenceTypeContext); ok {
			tst[i] = t.(ISequenceTypeContext)
			i++
		}
	}

	return tst
}

func (s *TypedFunctionTestContext) SequenceType(i int) ISequenceTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISequenceTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISequenceTypeContext)
}

func (s *TypedFunctionTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypedFunctionTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypedFunctionTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterTypedFunctionTest(s)
	}
}

func (s *TypedFunctionTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitTypedFunctionTest(s)
	}
}

func (p *XPath3Parser) TypedFunctionTest() (localctx ITypedFunctionTestContext) {
	localctx = NewTypedFunctionTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, XPath3ParserRULE_typedFunctionTest)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(728)
		p.Match(XPath3ParserT__76)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(729)
		p.Match(XPath3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(738)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == XPath3ParserT__13 || _la == XPath3ParserT__57 || ((int64((_la-77)) & ^0x3f) == 0 && ((int64(1)<<(_la-77))&17829887) != 0) {
		{
			p.SetState(730)
			p.SequenceType()
		}
		p.SetState(735)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == XPath3ParserT__0 {
			{
				p.SetState(731)
				p.Match(XPath3ParserT__0)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(732)
				p.SequenceType()
			}

			p.SetState(737)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(740)
		p.Match(XPath3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(741)
		p.Match(XPath3ParserT__33)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(742)
		p.SequenceType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParenthesizedItemTypeContext is an interface to support dynamic dispatch.
type IParenthesizedItemTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ItemType() IItemTypeContext

	// IsParenthesizedItemTypeContext differentiates from other interfaces.
	IsParenthesizedItemTypeContext()
}

type ParenthesizedItemTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParenthesizedItemTypeContext() *ParenthesizedItemTypeContext {
	var p = new(ParenthesizedItemTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_parenthesizedItemType
	return p
}

func InitEmptyParenthesizedItemTypeContext(p *ParenthesizedItemTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_parenthesizedItemType
}

func (*ParenthesizedItemTypeContext) IsParenthesizedItemTypeContext() {}

func NewParenthesizedItemTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParenthesizedItemTypeContext {
	var p = new(ParenthesizedItemTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_parenthesizedItemType

	return p
}

func (s *ParenthesizedItemTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ParenthesizedItemTypeContext) ItemType() IItemTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IItemTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IItemTypeContext)
}

func (s *ParenthesizedItemTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedItemTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParenthesizedItemTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterParenthesizedItemType(s)
	}
}

func (s *ParenthesizedItemTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitParenthesizedItemType(s)
	}
}

func (p *XPath3Parser) ParenthesizedItemType() (localctx IParenthesizedItemTypeContext) {
	localctx = NewParenthesizedItemTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, XPath3ParserRULE_parenthesizedItemType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(744)
		p.Match(XPath3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(745)
		p.ItemType()
	}
	{
		p.SetState(746)
		p.Match(XPath3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEqNameContext is an interface to support dynamic dispatch.
type IEqNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QNAME() antlr.TerminalNode
	URIQualifiedName() antlr.TerminalNode

	// IsEqNameContext differentiates from other interfaces.
	IsEqNameContext()
}

type EqNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEqNameContext() *EqNameContext {
	var p = new(EqNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_eqName
	return p
}

func InitEmptyEqNameContext(p *EqNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_eqName
}

func (*EqNameContext) IsEqNameContext() {}

func NewEqNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EqNameContext {
	var p = new(EqNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_eqName

	return p
}

func (s *EqNameContext) GetParser() antlr.Parser { return s.parser }

func (s *EqNameContext) QNAME() antlr.TerminalNode {
	return s.GetToken(XPath3ParserQNAME, 0)
}

func (s *EqNameContext) URIQualifiedName() antlr.TerminalNode {
	return s.GetToken(XPath3ParserURIQualifiedName, 0)
}

func (s *EqNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EqNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterEqName(s)
	}
}

func (s *EqNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitEqName(s)
	}
}

func (p *XPath3Parser) EqName() (localctx IEqNameContext) {
	localctx = NewEqNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, XPath3ParserRULE_eqName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(748)
		_la = p.GetTokenStream().LA(1)

		if !(_la == XPath3ParserURIQualifiedName || _la == XPath3ParserQNAME) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringLiteralContext is an interface to support dynamic dispatch.
type IStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllESCAPE_QUOTE() []antlr.TerminalNode
	ESCAPE_QUOTE(i int) antlr.TerminalNode
	AllESCAPE_APOS() []antlr.TerminalNode
	ESCAPE_APOS(i int) antlr.TerminalNode

	// IsStringLiteralContext differentiates from other interfaces.
	IsStringLiteralContext()
}

type StringLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringLiteralContext() *StringLiteralContext {
	var p = new(StringLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_stringLiteral
	return p
}

func InitEmptyStringLiteralContext(p *StringLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_stringLiteral
}

func (*StringLiteralContext) IsStringLiteralContext() {}

func NewStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringLiteralContext {
	var p = new(StringLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_stringLiteral

	return p
}

func (s *StringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *StringLiteralContext) AllESCAPE_QUOTE() []antlr.TerminalNode {
	return s.GetTokens(XPath3ParserESCAPE_QUOTE)
}

func (s *StringLiteralContext) ESCAPE_QUOTE(i int) antlr.TerminalNode {
	return s.GetToken(XPath3ParserESCAPE_QUOTE, i)
}

func (s *StringLiteralContext) AllESCAPE_APOS() []antlr.TerminalNode {
	return s.GetTokens(XPath3ParserESCAPE_APOS)
}

func (s *StringLiteralContext) ESCAPE_APOS(i int) antlr.TerminalNode {
	return s.GetToken(XPath3ParserESCAPE_APOS, i)
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

func (p *XPath3Parser) StringLiteral() (localctx IStringLiteralContext) {
	localctx = NewStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, XPath3ParserRULE_stringLiteral)
	var _alt int

	p.SetState(768)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserT__88:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(750)
			p.Match(XPath3ParserT__88)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(755)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 66, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1+1 {
				p.SetState(753)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 65, p.GetParserRuleContext()) {
				case 1:
					{
						p.SetState(751)
						p.Match(XPath3ParserESCAPE_QUOTE)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case 2:
					p.SetState(752)
					p.MatchWildcard()

				case antlr.ATNInvalidAltNumber:
					goto errorExit
				}

			}
			p.SetState(757)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 66, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		{
			p.SetState(758)
			p.Match(XPath3ParserT__88)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case XPath3ParserT__89:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(759)
			p.Match(XPath3ParserT__89)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(764)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 68, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1+1 {
				p.SetState(762)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 67, p.GetParserRuleContext()) {
				case 1:
					{
						p.SetState(760)
						p.Match(XPath3ParserESCAPE_APOS)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case 2:
					p.SetState(761)
					p.MatchWildcard()

				case antlr.ATNInvalidAltNumber:
					goto errorExit
				}

			}
			p.SetState(766)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 68, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		{
			p.SetState(767)
			p.Match(XPath3ParserT__89)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *XPath3Parser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 9:
		var t *ForBindingListContext = nil
		if localctx != nil {
			t = localctx.(*ForBindingListContext)
		}
		return p.ForBindingList_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *XPath3Parser) ForBindingList_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
