// Code generated from XPath3.g by ANTLR 4.13.0. DO NOT EDIT.

package parser // XPath3

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type XPath3Parser struct {
	*antlr.BaseParser
}

var XPath3ParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func xpath3ParserInit() {
	staticData := &XPath3ParserStaticData
	staticData.LiteralNames = []string{
		"", "','", "'$'", "'{'", "'}'", "'return'", "'for'", "'in'", "'let'",
		"':='", "'some'", "'any'", "'satisfies'", "'if'", "'('", "')'", "'then'",
		"'else'", "'or'", "'and'", "'||'", "'to'", "'+'", "'-'", "'*'", "'div'",
		"'idiv'", "'mod'", "'union'", "'|'", "'intersect'", "'except'", "'instance'",
		"'of'", "'treat'", "'as'", "'castable'", "'cast'", "'='", "'!='", "'<='",
		"'>='", "'<'", "'>'", "'eq'", "'ne'", "'lt'", "'le'", "'gt'", "'ge'",
		"'is'", "'<<'", "'>>'", "'!'", "'/'", "'//'", "'child'", "'::'", "'descendant'",
		"'attribute'", "'self'", "'descendant-or-self'", "'following-sibling'",
		"'following'", "'namespace'", "'@'", "'parent'", "'ancestor'", "'preceding-sibling'",
		"'preceding'", "'ancestor-or-self'", "'..'", "':'", "'['", "']'", "'.'",
		"'?'", "'#'", "'function'", "'empty-sequence'", "'item'", "'node'",
		"'document-node'", "'text'", "'comment'", "'namespace-node'", "'processing-instruction'",
		"'schema-attribute'", "'element'", "'schema-element'", "'\"'", "'''",
		"", "", "", "", "'\\\"'", "'\\''",
	}
	staticData.SymbolicNames = []string{
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "NumericLiteral", "IntegerLiteral", "DecimalLiteral",
		"DoubleLiteral", "ESCAPE_QUOTE", "ESCAPE_APOS", "URIQualifiedName",
		"Comment", "BracedURILiteral", "CommentContents", "QNAME", "PREFIXED_NAME",
		"UNPREFIXED_NAME", "PREFIX", "LOCAL_PART", "NC_NAME", "CHAR", "DIGITS",
	}
	staticData.RuleNames = []string{
		"xPath", "paramList", "param", "functionBody", "enclosedExpr", "expr",
		"exprSingle", "forExpr", "simpleForClause", "forBindingList", "simpleForBinding",
		"letExpr", "simpleLetClause", "letBindingList", "simpleLetBinding",
		"quantifiedExpr", "quantifiedBindingList", "simpleQuantifiedBinding",
		"ifExpr", "orExpr", "andExpr", "comparisonExpr", "stringConcatExpr",
		"rangeExpr", "additiveExpr", "multiplicativeExpr", "unionExpr", "intersectExceptExpr",
		"instanceofExpr", "treatExpr", "castableExpr", "castExpr", "unaryExpr",
		"valueExpr", "generalComp", "valueComp", "nodeComp", "simpleMapExpr",
		"pathExpr", "relativePathExpr", "stepExpr", "axisStep", "forwardStep",
		"forwardAxis", "abbrevForwardStep", "reverseStep", "reverseAxis", "abbrevReverseStep",
		"nodeTest", "nameTest", "wildCard", "postfixExpr", "argumentList", "arguments",
		"predicateList", "predicate", "primaryExpr", "varRef", "varName", "literal",
		"parenthesizedExpr", "contextItemExpr", "functionCall", "argument",
		"argumentPlaceholder", "functionItemExpr", "namedFunctionRef", "inlineFunctionExpr",
		"singleType", "type_declaration", "sequenceType", "occurenceIndicator",
		"itemType", "atomicOrUnionType", "kindTest", "anyKindTest", "documentTest",
		"textTest", "commentTest", "namespaceNodeTest", "piTest", "attributeTest",
		"attribNameOrWildcard", "schemaAttributeTest", "attributeDeclaration",
		"elementTest", "elementNameOrWildcard", "schemaElementTest", "elementDeclaration",
		"attributeName", "elementName", "simpleTypeName", "typeName", "functionTest",
		"anyFunctionTest", "typedFunctionTest", "parenthesizedItemType", "eqName",
		"stringLiteral",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 109, 846, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7,
		4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7,
		10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15,
		2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2,
		21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26,
		7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7,
		31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36,
		2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 2,
		42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 47,
		7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7,
		52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 57,
		2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62, 2,
		63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2, 68,
		7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73, 7,
		73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7, 78,
		2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83, 2,
		84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2, 89,
		7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94, 7,
		94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 1, 0, 1, 0,
		1, 0, 1, 1, 1, 1, 1, 1, 5, 1, 205, 8, 1, 10, 1, 12, 1, 208, 9, 1, 1, 2,
		1, 2, 1, 2, 3, 2, 213, 8, 2, 1, 3, 1, 3, 1, 4, 1, 4, 1, 4, 1, 4, 1, 5,
		1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 5, 5, 227, 8, 5, 10, 5, 12, 5, 230, 9, 5,
		1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 3, 6, 237, 8, 6, 1, 7, 1, 7, 1, 7, 1, 7,
		1, 8, 1, 8, 1, 8, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 5, 9, 252, 8, 9,
		10, 9, 12, 9, 255, 9, 9, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 11, 1, 11,
		1, 11, 1, 11, 1, 12, 1, 12, 1, 12, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1,
		13, 5, 13, 275, 8, 13, 10, 13, 12, 13, 278, 9, 13, 1, 14, 1, 14, 1, 14,
		1, 14, 1, 14, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 16, 1, 16, 1, 16, 1,
		16, 1, 16, 1, 16, 5, 16, 296, 8, 16, 10, 16, 12, 16, 299, 9, 16, 1, 17,
		1, 17, 1, 17, 1, 17, 1, 17, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1,
		18, 1, 18, 1, 18, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 5, 19, 321,
		8, 19, 10, 19, 12, 19, 324, 9, 19, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1,
		20, 5, 20, 332, 8, 20, 10, 20, 12, 20, 335, 9, 20, 1, 21, 1, 21, 1, 21,
		1, 21, 1, 21, 3, 21, 342, 8, 21, 1, 21, 1, 21, 3, 21, 346, 8, 21, 1, 22,
		1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 5, 22, 354, 8, 22, 10, 22, 12, 22, 357,
		9, 22, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 5, 23, 365, 8, 23, 10,
		23, 12, 23, 368, 9, 23, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 5, 24,
		376, 8, 24, 10, 24, 12, 24, 379, 9, 24, 1, 25, 1, 25, 1, 25, 1, 25, 1,
		25, 1, 25, 5, 25, 387, 8, 25, 10, 25, 12, 25, 390, 9, 25, 1, 26, 1, 26,
		1, 26, 1, 26, 1, 26, 1, 26, 5, 26, 398, 8, 26, 10, 26, 12, 26, 401, 9,
		26, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 5, 27, 409, 8, 27, 10, 27,
		12, 27, 412, 9, 27, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 3, 28, 420,
		8, 28, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 3, 29, 428, 8, 29, 1,
		30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 436, 8, 30, 1, 31, 1, 31,
		1, 31, 1, 31, 1, 31, 1, 31, 3, 31, 444, 8, 31, 1, 32, 1, 32, 1, 32, 1,
		32, 1, 32, 3, 32, 451, 8, 32, 1, 33, 1, 33, 1, 34, 1, 34, 1, 35, 1, 35,
		1, 36, 1, 36, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 5, 37, 467, 8,
		37, 10, 37, 12, 37, 470, 9, 37, 1, 38, 1, 38, 3, 38, 474, 8, 38, 1, 38,
		1, 38, 1, 38, 3, 38, 479, 8, 38, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1,
		39, 5, 39, 487, 8, 39, 10, 39, 12, 39, 490, 9, 39, 1, 40, 1, 40, 3, 40,
		494, 8, 40, 1, 41, 1, 41, 3, 41, 498, 8, 41, 1, 41, 1, 41, 1, 42, 1, 42,
		1, 42, 1, 42, 3, 42, 506, 8, 42, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1,
		43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43,
		3, 43, 524, 8, 43, 1, 44, 3, 44, 527, 8, 44, 1, 44, 1, 44, 1, 45, 1, 45,
		1, 45, 1, 45, 3, 45, 535, 8, 45, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1,
		46, 1, 46, 1, 46, 1, 46, 1, 46, 3, 46, 547, 8, 46, 1, 47, 1, 47, 1, 48,
		1, 48, 3, 48, 553, 8, 48, 1, 49, 1, 49, 3, 49, 557, 8, 49, 1, 50, 1, 50,
		1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 3, 50, 568, 8, 50, 1,
		51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 5, 51, 577, 8, 51, 10, 51,
		12, 51, 580, 9, 51, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 3, 52, 588,
		8, 52, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 5, 53, 596, 8, 53, 10,
		53, 12, 53, 599, 9, 53, 1, 54, 5, 54, 602, 8, 54, 10, 54, 12, 54, 605,
		9, 54, 1, 55, 1, 55, 1, 55, 1, 55, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1,
		56, 3, 56, 617, 8, 56, 1, 57, 1, 57, 1, 57, 1, 58, 1, 58, 1, 59, 1, 59,
		3, 59, 626, 8, 59, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 3, 60, 634,
		8, 60, 1, 61, 1, 61, 1, 62, 1, 62, 1, 62, 1, 63, 1, 63, 3, 63, 643, 8,
		63, 1, 64, 1, 64, 1, 65, 1, 65, 3, 65, 649, 8, 65, 1, 66, 1, 66, 1, 66,
		1, 66, 1, 67, 1, 67, 1, 67, 3, 67, 658, 8, 67, 1, 67, 1, 67, 1, 67, 3,
		67, 663, 8, 67, 1, 67, 1, 67, 1, 68, 1, 68, 3, 68, 669, 8, 68, 1, 69, 1,
		69, 1, 69, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 3, 70, 679, 8, 70, 3, 70,
		681, 8, 70, 1, 71, 1, 71, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1,
		72, 3, 72, 692, 8, 72, 1, 73, 1, 73, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74,
		1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 3, 74, 706, 8, 74, 1, 75, 1, 75, 1,
		75, 1, 75, 1, 76, 1, 76, 1, 76, 1, 76, 3, 76, 716, 8, 76, 1, 76, 1, 76,
		1, 77, 1, 77, 1, 77, 1, 77, 1, 78, 1, 78, 1, 78, 1, 78, 1, 79, 1, 79, 1,
		79, 1, 79, 1, 80, 1, 80, 1, 80, 1, 80, 3, 80, 736, 8, 80, 1, 80, 1, 80,
		1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 3, 81, 745, 8, 81, 3, 81, 747, 8, 81,
		1, 81, 1, 81, 1, 82, 1, 82, 3, 82, 753, 8, 82, 1, 83, 1, 83, 1, 83, 1,
		83, 1, 83, 1, 84, 1, 84, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 3, 85,
		768, 8, 85, 3, 85, 770, 8, 85, 3, 85, 772, 8, 85, 1, 85, 1, 85, 1, 86,
		1, 86, 3, 86, 778, 8, 86, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 88, 1,
		88, 1, 89, 1, 89, 1, 90, 1, 90, 1, 91, 1, 91, 1, 92, 1, 92, 1, 93, 1, 93,
		3, 93, 797, 8, 93, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 95, 1, 95, 1,
		95, 1, 95, 1, 95, 5, 95, 809, 8, 95, 10, 95, 12, 95, 812, 9, 95, 3, 95,
		814, 8, 95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 96, 1, 96, 1, 96, 1, 96, 1,
		97, 1, 97, 1, 98, 1, 98, 1, 98, 5, 98, 829, 8, 98, 10, 98, 12, 98, 832,
		9, 98, 1, 98, 1, 98, 1, 98, 1, 98, 5, 98, 838, 8, 98, 10, 98, 12, 98, 841,
		9, 98, 1, 98, 3, 98, 844, 8, 98, 1, 98, 2, 830, 839, 16, 10, 18, 26, 32,
		38, 40, 44, 46, 48, 50, 52, 54, 74, 78, 102, 106, 99, 0, 2, 4, 6, 8, 10,
		12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46,
		48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82,
		84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114,
		116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144,
		146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174,
		176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 0, 11, 1, 0, 10,
		11, 1, 0, 22, 23, 1, 0, 24, 27, 1, 0, 28, 29, 1, 0, 30, 31, 1, 0, 38, 43,
		1, 0, 44, 49, 1, 0, 50, 52, 1, 0, 54, 55, 3, 0, 22, 22, 24, 24, 76, 76,
		2, 0, 98, 98, 102, 102, 850, 0, 198, 1, 0, 0, 0, 2, 201, 1, 0, 0, 0, 4,
		209, 1, 0, 0, 0, 6, 214, 1, 0, 0, 0, 8, 216, 1, 0, 0, 0, 10, 220, 1, 0,
		0, 0, 12, 236, 1, 0, 0, 0, 14, 238, 1, 0, 0, 0, 16, 242, 1, 0, 0, 0, 18,
		245, 1, 0, 0, 0, 20, 256, 1, 0, 0, 0, 22, 261, 1, 0, 0, 0, 24, 265, 1,
		0, 0, 0, 26, 268, 1, 0, 0, 0, 28, 279, 1, 0, 0, 0, 30, 284, 1, 0, 0, 0,
		32, 289, 1, 0, 0, 0, 34, 300, 1, 0, 0, 0, 36, 305, 1, 0, 0, 0, 38, 314,
		1, 0, 0, 0, 40, 325, 1, 0, 0, 0, 42, 345, 1, 0, 0, 0, 44, 347, 1, 0, 0,
		0, 46, 358, 1, 0, 0, 0, 48, 369, 1, 0, 0, 0, 50, 380, 1, 0, 0, 0, 52, 391,
		1, 0, 0, 0, 54, 402, 1, 0, 0, 0, 56, 419, 1, 0, 0, 0, 58, 427, 1, 0, 0,
		0, 60, 435, 1, 0, 0, 0, 62, 443, 1, 0, 0, 0, 64, 450, 1, 0, 0, 0, 66, 452,
		1, 0, 0, 0, 68, 454, 1, 0, 0, 0, 70, 456, 1, 0, 0, 0, 72, 458, 1, 0, 0,
		0, 74, 460, 1, 0, 0, 0, 76, 478, 1, 0, 0, 0, 78, 480, 1, 0, 0, 0, 80, 493,
		1, 0, 0, 0, 82, 497, 1, 0, 0, 0, 84, 505, 1, 0, 0, 0, 86, 523, 1, 0, 0,
		0, 88, 526, 1, 0, 0, 0, 90, 534, 1, 0, 0, 0, 92, 546, 1, 0, 0, 0, 94, 548,
		1, 0, 0, 0, 96, 552, 1, 0, 0, 0, 98, 556, 1, 0, 0, 0, 100, 567, 1, 0, 0,
		0, 102, 569, 1, 0, 0, 0, 104, 587, 1, 0, 0, 0, 106, 589, 1, 0, 0, 0, 108,
		603, 1, 0, 0, 0, 110, 606, 1, 0, 0, 0, 112, 616, 1, 0, 0, 0, 114, 618,
		1, 0, 0, 0, 116, 621, 1, 0, 0, 0, 118, 625, 1, 0, 0, 0, 120, 633, 1, 0,
		0, 0, 122, 635, 1, 0, 0, 0, 124, 637, 1, 0, 0, 0, 126, 642, 1, 0, 0, 0,
		128, 644, 1, 0, 0, 0, 130, 648, 1, 0, 0, 0, 132, 650, 1, 0, 0, 0, 134,
		654, 1, 0, 0, 0, 136, 666, 1, 0, 0, 0, 138, 670, 1, 0, 0, 0, 140, 680,
		1, 0, 0, 0, 142, 682, 1, 0, 0, 0, 144, 691, 1, 0, 0, 0, 146, 693, 1, 0,
		0, 0, 148, 705, 1, 0, 0, 0, 150, 707, 1, 0, 0, 0, 152, 711, 1, 0, 0, 0,
		154, 719, 1, 0, 0, 0, 156, 723, 1, 0, 0, 0, 158, 727, 1, 0, 0, 0, 160,
		731, 1, 0, 0, 0, 162, 739, 1, 0, 0, 0, 164, 752, 1, 0, 0, 0, 166, 754,
		1, 0, 0, 0, 168, 759, 1, 0, 0, 0, 170, 761, 1, 0, 0, 0, 172, 777, 1, 0,
		0, 0, 174, 779, 1, 0, 0, 0, 176, 784, 1, 0, 0, 0, 178, 786, 1, 0, 0, 0,
		180, 788, 1, 0, 0, 0, 182, 790, 1, 0, 0, 0, 184, 792, 1, 0, 0, 0, 186,
		796, 1, 0, 0, 0, 188, 798, 1, 0, 0, 0, 190, 803, 1, 0, 0, 0, 192, 819,
		1, 0, 0, 0, 194, 823, 1, 0, 0, 0, 196, 843, 1, 0, 0, 0, 198, 199, 3, 10,
		5, 0, 199, 200, 5, 0, 0, 1, 200, 1, 1, 0, 0, 0, 201, 206, 3, 4, 2, 0, 202,
		203, 5, 1, 0, 0, 203, 205, 3, 4, 2, 0, 204, 202, 1, 0, 0, 0, 205, 208,
		1, 0, 0, 0, 206, 204, 1, 0, 0, 0, 206, 207, 1, 0, 0, 0, 207, 3, 1, 0, 0,
		0, 208, 206, 1, 0, 0, 0, 209, 210, 5, 2, 0, 0, 210, 212, 3, 194, 97, 0,
		211, 213, 3, 138, 69, 0, 212, 211, 1, 0, 0, 0, 212, 213, 1, 0, 0, 0, 213,
		5, 1, 0, 0, 0, 214, 215, 3, 8, 4, 0, 215, 7, 1, 0, 0, 0, 216, 217, 5, 3,
		0, 0, 217, 218, 3, 10, 5, 0, 218, 219, 5, 4, 0, 0, 219, 9, 1, 0, 0, 0,
		220, 221, 6, 5, -1, 0, 221, 222, 3, 12, 6, 0, 222, 228, 1, 0, 0, 0, 223,
		224, 10, 1, 0, 0, 224, 225, 5, 1, 0, 0, 225, 227, 3, 12, 6, 0, 226, 223,
		1, 0, 0, 0, 227, 230, 1, 0, 0, 0, 228, 226, 1, 0, 0, 0, 228, 229, 1, 0,
		0, 0, 229, 11, 1, 0, 0, 0, 230, 228, 1, 0, 0, 0, 231, 237, 3, 14, 7, 0,
		232, 237, 3, 22, 11, 0, 233, 237, 3, 30, 15, 0, 234, 237, 3, 36, 18, 0,
		235, 237, 3, 38, 19, 0, 236, 231, 1, 0, 0, 0, 236, 232, 1, 0, 0, 0, 236,
		233, 1, 0, 0, 0, 236, 234, 1, 0, 0, 0, 236, 235, 1, 0, 0, 0, 237, 13, 1,
		0, 0, 0, 238, 239, 3, 16, 8, 0, 239, 240, 5, 5, 0, 0, 240, 241, 3, 12,
		6, 0, 241, 15, 1, 0, 0, 0, 242, 243, 5, 6, 0, 0, 243, 244, 3, 18, 9, 0,
		244, 17, 1, 0, 0, 0, 245, 246, 6, 9, -1, 0, 246, 247, 3, 20, 10, 0, 247,
		253, 1, 0, 0, 0, 248, 249, 10, 1, 0, 0, 249, 250, 5, 1, 0, 0, 250, 252,
		3, 20, 10, 0, 251, 248, 1, 0, 0, 0, 252, 255, 1, 0, 0, 0, 253, 251, 1,
		0, 0, 0, 253, 254, 1, 0, 0, 0, 254, 19, 1, 0, 0, 0, 255, 253, 1, 0, 0,
		0, 256, 257, 5, 2, 0, 0, 257, 258, 3, 116, 58, 0, 258, 259, 5, 7, 0, 0,
		259, 260, 3, 12, 6, 0, 260, 21, 1, 0, 0, 0, 261, 262, 3, 24, 12, 0, 262,
		263, 5, 5, 0, 0, 263, 264, 3, 12, 6, 0, 264, 23, 1, 0, 0, 0, 265, 266,
		5, 8, 0, 0, 266, 267, 3, 26, 13, 0, 267, 25, 1, 0, 0, 0, 268, 269, 6, 13,
		-1, 0, 269, 270, 3, 24, 12, 0, 270, 276, 1, 0, 0, 0, 271, 272, 10, 1, 0,
		0, 272, 273, 5, 1, 0, 0, 273, 275, 3, 28, 14, 0, 274, 271, 1, 0, 0, 0,
		275, 278, 1, 0, 0, 0, 276, 274, 1, 0, 0, 0, 276, 277, 1, 0, 0, 0, 277,
		27, 1, 0, 0, 0, 278, 276, 1, 0, 0, 0, 279, 280, 5, 2, 0, 0, 280, 281, 3,
		116, 58, 0, 281, 282, 5, 9, 0, 0, 282, 283, 3, 12, 6, 0, 283, 29, 1, 0,
		0, 0, 284, 285, 7, 0, 0, 0, 285, 286, 3, 32, 16, 0, 286, 287, 5, 12, 0,
		0, 287, 288, 3, 12, 6, 0, 288, 31, 1, 0, 0, 0, 289, 290, 6, 16, -1, 0,
		290, 291, 3, 34, 17, 0, 291, 297, 1, 0, 0, 0, 292, 293, 10, 1, 0, 0, 293,
		294, 5, 1, 0, 0, 294, 296, 3, 34, 17, 0, 295, 292, 1, 0, 0, 0, 296, 299,
		1, 0, 0, 0, 297, 295, 1, 0, 0, 0, 297, 298, 1, 0, 0, 0, 298, 33, 1, 0,
		0, 0, 299, 297, 1, 0, 0, 0, 300, 301, 5, 2, 0, 0, 301, 302, 3, 116, 58,
		0, 302, 303, 5, 7, 0, 0, 303, 304, 3, 12, 6, 0, 304, 35, 1, 0, 0, 0, 305,
		306, 5, 13, 0, 0, 306, 307, 5, 14, 0, 0, 307, 308, 3, 10, 5, 0, 308, 309,
		5, 15, 0, 0, 309, 310, 5, 16, 0, 0, 310, 311, 3, 12, 6, 0, 311, 312, 5,
		17, 0, 0, 312, 313, 3, 12, 6, 0, 313, 37, 1, 0, 0, 0, 314, 315, 6, 19,
		-1, 0, 315, 316, 3, 40, 20, 0, 316, 322, 1, 0, 0, 0, 317, 318, 10, 1, 0,
		0, 318, 319, 5, 18, 0, 0, 319, 321, 3, 40, 20, 0, 320, 317, 1, 0, 0, 0,
		321, 324, 1, 0, 0, 0, 322, 320, 1, 0, 0, 0, 322, 323, 1, 0, 0, 0, 323,
		39, 1, 0, 0, 0, 324, 322, 1, 0, 0, 0, 325, 326, 6, 20, -1, 0, 326, 327,
		3, 42, 21, 0, 327, 333, 1, 0, 0, 0, 328, 329, 10, 1, 0, 0, 329, 330, 5,
		19, 0, 0, 330, 332, 3, 42, 21, 0, 331, 328, 1, 0, 0, 0, 332, 335, 1, 0,
		0, 0, 333, 331, 1, 0, 0, 0, 333, 334, 1, 0, 0, 0, 334, 41, 1, 0, 0, 0,
		335, 333, 1, 0, 0, 0, 336, 346, 3, 44, 22, 0, 337, 341, 3, 44, 22, 0, 338,
		342, 3, 70, 35, 0, 339, 342, 3, 68, 34, 0, 340, 342, 3, 72, 36, 0, 341,
		338, 1, 0, 0, 0, 341, 339, 1, 0, 0, 0, 341, 340, 1, 0, 0, 0, 342, 343,
		1, 0, 0, 0, 343, 344, 3, 44, 22, 0, 344, 346, 1, 0, 0, 0, 345, 336, 1,
		0, 0, 0, 345, 337, 1, 0, 0, 0, 346, 43, 1, 0, 0, 0, 347, 348, 6, 22, -1,
		0, 348, 349, 3, 46, 23, 0, 349, 355, 1, 0, 0, 0, 350, 351, 10, 1, 0, 0,
		351, 352, 5, 20, 0, 0, 352, 354, 3, 46, 23, 0, 353, 350, 1, 0, 0, 0, 354,
		357, 1, 0, 0, 0, 355, 353, 1, 0, 0, 0, 355, 356, 1, 0, 0, 0, 356, 45, 1,
		0, 0, 0, 357, 355, 1, 0, 0, 0, 358, 359, 6, 23, -1, 0, 359, 360, 3, 48,
		24, 0, 360, 366, 1, 0, 0, 0, 361, 362, 10, 1, 0, 0, 362, 363, 5, 21, 0,
		0, 363, 365, 3, 48, 24, 0, 364, 361, 1, 0, 0, 0, 365, 368, 1, 0, 0, 0,
		366, 364, 1, 0, 0, 0, 366, 367, 1, 0, 0, 0, 367, 47, 1, 0, 0, 0, 368, 366,
		1, 0, 0, 0, 369, 370, 6, 24, -1, 0, 370, 371, 3, 50, 25, 0, 371, 377, 1,
		0, 0, 0, 372, 373, 10, 1, 0, 0, 373, 374, 7, 1, 0, 0, 374, 376, 3, 50,
		25, 0, 375, 372, 1, 0, 0, 0, 376, 379, 1, 0, 0, 0, 377, 375, 1, 0, 0, 0,
		377, 378, 1, 0, 0, 0, 378, 49, 1, 0, 0, 0, 379, 377, 1, 0, 0, 0, 380, 381,
		6, 25, -1, 0, 381, 382, 3, 52, 26, 0, 382, 388, 1, 0, 0, 0, 383, 384, 10,
		1, 0, 0, 384, 385, 7, 2, 0, 0, 385, 387, 3, 52, 26, 0, 386, 383, 1, 0,
		0, 0, 387, 390, 1, 0, 0, 0, 388, 386, 1, 0, 0, 0, 388, 389, 1, 0, 0, 0,
		389, 51, 1, 0, 0, 0, 390, 388, 1, 0, 0, 0, 391, 392, 6, 26, -1, 0, 392,
		393, 3, 54, 27, 0, 393, 399, 1, 0, 0, 0, 394, 395, 10, 1, 0, 0, 395, 396,
		7, 3, 0, 0, 396, 398, 3, 54, 27, 0, 397, 394, 1, 0, 0, 0, 398, 401, 1,
		0, 0, 0, 399, 397, 1, 0, 0, 0, 399, 400, 1, 0, 0, 0, 400, 53, 1, 0, 0,
		0, 401, 399, 1, 0, 0, 0, 402, 403, 6, 27, -1, 0, 403, 404, 3, 56, 28, 0,
		404, 410, 1, 0, 0, 0, 405, 406, 10, 1, 0, 0, 406, 407, 7, 4, 0, 0, 407,
		409, 3, 56, 28, 0, 408, 405, 1, 0, 0, 0, 409, 412, 1, 0, 0, 0, 410, 408,
		1, 0, 0, 0, 410, 411, 1, 0, 0, 0, 411, 55, 1, 0, 0, 0, 412, 410, 1, 0,
		0, 0, 413, 420, 3, 58, 29, 0, 414, 415, 3, 58, 29, 0, 415, 416, 5, 32,
		0, 0, 416, 417, 5, 33, 0, 0, 417, 418, 3, 140, 70, 0, 418, 420, 1, 0, 0,
		0, 419, 413, 1, 0, 0, 0, 419, 414, 1, 0, 0, 0, 420, 57, 1, 0, 0, 0, 421,
		428, 3, 60, 30, 0, 422, 423, 3, 60, 30, 0, 423, 424, 5, 34, 0, 0, 424,
		425, 5, 35, 0, 0, 425, 426, 3, 140, 70, 0, 426, 428, 1, 0, 0, 0, 427, 421,
		1, 0, 0, 0, 427, 422, 1, 0, 0, 0, 428, 59, 1, 0, 0, 0, 429, 436, 3, 62,
		31, 0, 430, 431, 3, 62, 31, 0, 431, 432, 5, 36, 0, 0, 432, 433, 5, 35,
		0, 0, 433, 434, 3, 136, 68, 0, 434, 436, 1, 0, 0, 0, 435, 429, 1, 0, 0,
		0, 435, 430, 1, 0, 0, 0, 436, 61, 1, 0, 0, 0, 437, 444, 3, 64, 32, 0, 438,
		439, 3, 64, 32, 0, 439, 440, 5, 37, 0, 0, 440, 441, 5, 35, 0, 0, 441, 442,
		3, 136, 68, 0, 442, 444, 1, 0, 0, 0, 443, 437, 1, 0, 0, 0, 443, 438, 1,
		0, 0, 0, 444, 63, 1, 0, 0, 0, 445, 451, 3, 66, 33, 0, 446, 447, 5, 23,
		0, 0, 447, 451, 3, 64, 32, 0, 448, 449, 5, 22, 0, 0, 449, 451, 3, 64, 32,
		0, 450, 445, 1, 0, 0, 0, 450, 446, 1, 0, 0, 0, 450, 448, 1, 0, 0, 0, 451,
		65, 1, 0, 0, 0, 452, 453, 3, 74, 37, 0, 453, 67, 1, 0, 0, 0, 454, 455,
		7, 5, 0, 0, 455, 69, 1, 0, 0, 0, 456, 457, 7, 6, 0, 0, 457, 71, 1, 0, 0,
		0, 458, 459, 7, 7, 0, 0, 459, 73, 1, 0, 0, 0, 460, 461, 6, 37, -1, 0, 461,
		462, 3, 76, 38, 0, 462, 468, 1, 0, 0, 0, 463, 464, 10, 1, 0, 0, 464, 465,
		5, 53, 0, 0, 465, 467, 3, 76, 38, 0, 466, 463, 1, 0, 0, 0, 467, 470, 1,
		0, 0, 0, 468, 466, 1, 0, 0, 0, 468, 469, 1, 0, 0, 0, 469, 75, 1, 0, 0,
		0, 470, 468, 1, 0, 0, 0, 471, 473, 5, 54, 0, 0, 472, 474, 3, 78, 39, 0,
		473, 472, 1, 0, 0, 0, 473, 474, 1, 0, 0, 0, 474, 479, 1, 0, 0, 0, 475,
		476, 5, 55, 0, 0, 476, 479, 3, 78, 39, 0, 477, 479, 3, 78, 39, 0, 478,
		471, 1, 0, 0, 0, 478, 475, 1, 0, 0, 0, 478, 477, 1, 0, 0, 0, 479, 77, 1,
		0, 0, 0, 480, 481, 6, 39, -1, 0, 481, 482, 3, 80, 40, 0, 482, 488, 1, 0,
		0, 0, 483, 484, 10, 1, 0, 0, 484, 485, 7, 8, 0, 0, 485, 487, 3, 80, 40,
		0, 486, 483, 1, 0, 0, 0, 487, 490, 1, 0, 0, 0, 488, 486, 1, 0, 0, 0, 488,
		489, 1, 0, 0, 0, 489, 79, 1, 0, 0, 0, 490, 488, 1, 0, 0, 0, 491, 494, 3,
		102, 51, 0, 492, 494, 3, 82, 41, 0, 493, 491, 1, 0, 0, 0, 493, 492, 1,
		0, 0, 0, 494, 81, 1, 0, 0, 0, 495, 498, 3, 90, 45, 0, 496, 498, 3, 84,
		42, 0, 497, 495, 1, 0, 0, 0, 497, 496, 1, 0, 0, 0, 498, 499, 1, 0, 0, 0,
		499, 500, 3, 108, 54, 0, 500, 83, 1, 0, 0, 0, 501, 502, 3, 86, 43, 0, 502,
		503, 3, 96, 48, 0, 503, 506, 1, 0, 0, 0, 504, 506, 3, 88, 44, 0, 505, 501,
		1, 0, 0, 0, 505, 504, 1, 0, 0, 0, 506, 85, 1, 0, 0, 0, 507, 508, 5, 56,
		0, 0, 508, 524, 5, 57, 0, 0, 509, 510, 5, 58, 0, 0, 510, 524, 5, 57, 0,
		0, 511, 512, 5, 59, 0, 0, 512, 524, 5, 57, 0, 0, 513, 514, 5, 60, 0, 0,
		514, 524, 5, 57, 0, 0, 515, 516, 5, 61, 0, 0, 516, 524, 5, 57, 0, 0, 517,
		518, 5, 62, 0, 0, 518, 524, 5, 57, 0, 0, 519, 520, 5, 63, 0, 0, 520, 524,
		5, 57, 0, 0, 521, 522, 5, 64, 0, 0, 522, 524, 5, 57, 0, 0, 523, 507, 1,
		0, 0, 0, 523, 509, 1, 0, 0, 0, 523, 511, 1, 0, 0, 0, 523, 513, 1, 0, 0,
		0, 523, 515, 1, 0, 0, 0, 523, 517, 1, 0, 0, 0, 523, 519, 1, 0, 0, 0, 523,
		521, 1, 0, 0, 0, 524, 87, 1, 0, 0, 0, 525, 527, 5, 65, 0, 0, 526, 525,
		1, 0, 0, 0, 526, 527, 1, 0, 0, 0, 527, 528, 1, 0, 0, 0, 528, 529, 3, 96,
		48, 0, 529, 89, 1, 0, 0, 0, 530, 531, 3, 92, 46, 0, 531, 532, 3, 96, 48,
		0, 532, 535, 1, 0, 0, 0, 533, 535, 3, 94, 47, 0, 534, 530, 1, 0, 0, 0,
		534, 533, 1, 0, 0, 0, 535, 91, 1, 0, 0, 0, 536, 537, 5, 66, 0, 0, 537,
		547, 5, 57, 0, 0, 538, 539, 5, 67, 0, 0, 539, 547, 5, 57, 0, 0, 540, 541,
		5, 68, 0, 0, 541, 547, 5, 57, 0, 0, 542, 543, 5, 69, 0, 0, 543, 547, 5,
		57, 0, 0, 544, 545, 5, 70, 0, 0, 545, 547, 5, 57, 0, 0, 546, 536, 1, 0,
		0, 0, 546, 538, 1, 0, 0, 0, 546, 540, 1, 0, 0, 0, 546, 542, 1, 0, 0, 0,
		546, 544, 1, 0, 0, 0, 547, 93, 1, 0, 0, 0, 548, 549, 5, 71, 0, 0, 549,
		95, 1, 0, 0, 0, 550, 553, 3, 148, 74, 0, 551, 553, 3, 98, 49, 0, 552, 550,
		1, 0, 0, 0, 552, 551, 1, 0, 0, 0, 553, 97, 1, 0, 0, 0, 554, 557, 3, 194,
		97, 0, 555, 557, 3, 100, 50, 0, 556, 554, 1, 0, 0, 0, 556, 555, 1, 0, 0,
		0, 557, 99, 1, 0, 0, 0, 558, 568, 5, 24, 0, 0, 559, 560, 5, 107, 0, 0,
		560, 561, 5, 72, 0, 0, 561, 568, 5, 24, 0, 0, 562, 563, 5, 24, 0, 0, 563,
		564, 5, 72, 0, 0, 564, 568, 5, 107, 0, 0, 565, 566, 5, 100, 0, 0, 566,
		568, 5, 24, 0, 0, 567, 558, 1, 0, 0, 0, 567, 559, 1, 0, 0, 0, 567, 562,
		1, 0, 0, 0, 567, 565, 1, 0, 0, 0, 568, 101, 1, 0, 0, 0, 569, 570, 6, 51,
		-1, 0, 570, 571, 3, 112, 56, 0, 571, 578, 1, 0, 0, 0, 572, 573, 10, 2,
		0, 0, 573, 577, 3, 110, 55, 0, 574, 575, 10, 1, 0, 0, 575, 577, 3, 104,
		52, 0, 576, 572, 1, 0, 0, 0, 576, 574, 1, 0, 0, 0, 577, 580, 1, 0, 0, 0,
		578, 576, 1, 0, 0, 0, 578, 579, 1, 0, 0, 0, 579, 103, 1, 0, 0, 0, 580,
		578, 1, 0, 0, 0, 581, 582, 5, 14, 0, 0, 582, 583, 3, 106, 53, 0, 583, 584,
		5, 15, 0, 0, 584, 588, 1, 0, 0, 0, 585, 586, 5, 14, 0, 0, 586, 588, 5,
		15, 0, 0, 587, 581, 1, 0, 0, 0, 587, 585, 1, 0, 0, 0, 588, 105, 1, 0, 0,
		0, 589, 590, 6, 53, -1, 0, 590, 591, 3, 126, 63, 0, 591, 597, 1, 0, 0,
		0, 592, 593, 10, 1, 0, 0, 593, 594, 5, 1, 0, 0, 594, 596, 3, 126, 63, 0,
		595, 592, 1, 0, 0, 0, 596, 599, 1, 0, 0, 0, 597, 595, 1, 0, 0, 0, 597,
		598, 1, 0, 0, 0, 598, 107, 1, 0, 0, 0, 599, 597, 1, 0, 0, 0, 600, 602,
		3, 110, 55, 0, 601, 600, 1, 0, 0, 0, 602, 605, 1, 0, 0, 0, 603, 601, 1,
		0, 0, 0, 603, 604, 1, 0, 0, 0, 604, 109, 1, 0, 0, 0, 605, 603, 1, 0, 0,
		0, 606, 607, 5, 73, 0, 0, 607, 608, 3, 10, 5, 0, 608, 609, 5, 74, 0, 0,
		609, 111, 1, 0, 0, 0, 610, 617, 3, 118, 59, 0, 611, 617, 3, 114, 57, 0,
		612, 617, 3, 120, 60, 0, 613, 617, 3, 122, 61, 0, 614, 617, 3, 124, 62,
		0, 615, 617, 3, 130, 65, 0, 616, 610, 1, 0, 0, 0, 616, 611, 1, 0, 0, 0,
		616, 612, 1, 0, 0, 0, 616, 613, 1, 0, 0, 0, 616, 614, 1, 0, 0, 0, 616,
		615, 1, 0, 0, 0, 617, 113, 1, 0, 0, 0, 618, 619, 5, 2, 0, 0, 619, 620,
		3, 116, 58, 0, 620, 115, 1, 0, 0, 0, 621, 622, 3, 194, 97, 0, 622, 117,
		1, 0, 0, 0, 623, 626, 5, 92, 0, 0, 624, 626, 3, 196, 98, 0, 625, 623, 1,
		0, 0, 0, 625, 624, 1, 0, 0, 0, 626, 119, 1, 0, 0, 0, 627, 628, 5, 14, 0,
		0, 628, 634, 5, 15, 0, 0, 629, 630, 5, 14, 0, 0, 630, 631, 3, 10, 5, 0,
		631, 632, 5, 15, 0, 0, 632, 634, 1, 0, 0, 0, 633, 627, 1, 0, 0, 0, 633,
		629, 1, 0, 0, 0, 634, 121, 1, 0, 0, 0, 635, 636, 5, 75, 0, 0, 636, 123,
		1, 0, 0, 0, 637, 638, 3, 194, 97, 0, 638, 639, 3, 104, 52, 0, 639, 125,
		1, 0, 0, 0, 640, 643, 3, 12, 6, 0, 641, 643, 3, 128, 64, 0, 642, 640, 1,
		0, 0, 0, 642, 641, 1, 0, 0, 0, 643, 127, 1, 0, 0, 0, 644, 645, 5, 76, 0,
		0, 645, 129, 1, 0, 0, 0, 646, 649, 3, 132, 66, 0, 647, 649, 3, 134, 67,
		0, 648, 646, 1, 0, 0, 0, 648, 647, 1, 0, 0, 0, 649, 131, 1, 0, 0, 0, 650,
		651, 3, 194, 97, 0, 651, 652, 5, 77, 0, 0, 652, 653, 5, 93, 0, 0, 653,
		133, 1, 0, 0, 0, 654, 655, 5, 78, 0, 0, 655, 657, 5, 14, 0, 0, 656, 658,
		3, 2, 1, 0, 657, 656, 1, 0, 0, 0, 657, 658, 1, 0, 0, 0, 658, 659, 1, 0,
		0, 0, 659, 662, 5, 15, 0, 0, 660, 661, 5, 35, 0, 0, 661, 663, 3, 140, 70,
		0, 662, 660, 1, 0, 0, 0, 662, 663, 1, 0, 0, 0, 663, 664, 1, 0, 0, 0, 664,
		665, 3, 6, 3, 0, 665, 135, 1, 0, 0, 0, 666, 668, 3, 182, 91, 0, 667, 669,
		5, 76, 0, 0, 668, 667, 1, 0, 0, 0, 668, 669, 1, 0, 0, 0, 669, 137, 1, 0,
		0, 0, 670, 671, 5, 35, 0, 0, 671, 672, 3, 140, 70, 0, 672, 139, 1, 0, 0,
		0, 673, 674, 5, 79, 0, 0, 674, 675, 5, 14, 0, 0, 675, 681, 5, 15, 0, 0,
		676, 678, 3, 144, 72, 0, 677, 679, 3, 142, 71, 0, 678, 677, 1, 0, 0, 0,
		678, 679, 1, 0, 0, 0, 679, 681, 1, 0, 0, 0, 680, 673, 1, 0, 0, 0, 680,
		676, 1, 0, 0, 0, 681, 141, 1, 0, 0, 0, 682, 683, 7, 9, 0, 0, 683, 143,
		1, 0, 0, 0, 684, 692, 3, 148, 74, 0, 685, 686, 5, 80, 0, 0, 686, 687, 5,
		14, 0, 0, 687, 692, 5, 15, 0, 0, 688, 692, 3, 186, 93, 0, 689, 692, 3,
		146, 73, 0, 690, 692, 3, 192, 96, 0, 691, 684, 1, 0, 0, 0, 691, 685, 1,
		0, 0, 0, 691, 688, 1, 0, 0, 0, 691, 689, 1, 0, 0, 0, 691, 690, 1, 0, 0,
		0, 692, 145, 1, 0, 0, 0, 693, 694, 3, 194, 97, 0, 694, 147, 1, 0, 0, 0,
		695, 706, 3, 152, 76, 0, 696, 706, 3, 170, 85, 0, 697, 706, 3, 162, 81,
		0, 698, 706, 3, 174, 87, 0, 699, 706, 3, 166, 83, 0, 700, 706, 3, 160,
		80, 0, 701, 706, 3, 156, 78, 0, 702, 706, 3, 154, 77, 0, 703, 706, 3, 158,
		79, 0, 704, 706, 3, 150, 75, 0, 705, 695, 1, 0, 0, 0, 705, 696, 1, 0, 0,
		0, 705, 697, 1, 0, 0, 0, 705, 698, 1, 0, 0, 0, 705, 699, 1, 0, 0, 0, 705,
		700, 1, 0, 0, 0, 705, 701, 1, 0, 0, 0, 705, 702, 1, 0, 0, 0, 705, 703,
		1, 0, 0, 0, 705, 704, 1, 0, 0, 0, 706, 149, 1, 0, 0, 0, 707, 708, 5, 81,
		0, 0, 708, 709, 5, 14, 0, 0, 709, 710, 5, 15, 0, 0, 710, 151, 1, 0, 0,
		0, 711, 712, 5, 82, 0, 0, 712, 715, 5, 14, 0, 0, 713, 716, 3, 170, 85,
		0, 714, 716, 3, 174, 87, 0, 715, 713, 1, 0, 0, 0, 715, 714, 1, 0, 0, 0,
		715, 716, 1, 0, 0, 0, 716, 717, 1, 0, 0, 0, 717, 718, 5, 15, 0, 0, 718,
		153, 1, 0, 0, 0, 719, 720, 5, 83, 0, 0, 720, 721, 5, 14, 0, 0, 721, 722,
		5, 15, 0, 0, 722, 155, 1, 0, 0, 0, 723, 724, 5, 84, 0, 0, 724, 725, 5,
		14, 0, 0, 725, 726, 5, 15, 0, 0, 726, 157, 1, 0, 0, 0, 727, 728, 5, 85,
		0, 0, 728, 729, 5, 14, 0, 0, 729, 730, 5, 15, 0, 0, 730, 159, 1, 0, 0,
		0, 731, 732, 5, 86, 0, 0, 732, 735, 5, 14, 0, 0, 733, 736, 5, 107, 0, 0,
		734, 736, 3, 196, 98, 0, 735, 733, 1, 0, 0, 0, 735, 734, 1, 0, 0, 0, 735,
		736, 1, 0, 0, 0, 736, 737, 1, 0, 0, 0, 737, 738, 5, 15, 0, 0, 738, 161,
		1, 0, 0, 0, 739, 740, 5, 59, 0, 0, 740, 746, 5, 14, 0, 0, 741, 744, 3,
		164, 82, 0, 742, 743, 5, 1, 0, 0, 743, 745, 3, 184, 92, 0, 744, 742, 1,
		0, 0, 0, 744, 745, 1, 0, 0, 0, 745, 747, 1, 0, 0, 0, 746, 741, 1, 0, 0,
		0, 746, 747, 1, 0, 0, 0, 747, 748, 1, 0, 0, 0, 748, 749, 5, 15, 0, 0, 749,
		163, 1, 0, 0, 0, 750, 753, 3, 178, 89, 0, 751, 753, 5, 24, 0, 0, 752, 750,
		1, 0, 0, 0, 752, 751, 1, 0, 0, 0, 753, 165, 1, 0, 0, 0, 754, 755, 5, 87,
		0, 0, 755, 756, 5, 14, 0, 0, 756, 757, 3, 168, 84, 0, 757, 758, 5, 15,
		0, 0, 758, 167, 1, 0, 0, 0, 759, 760, 3, 178, 89, 0, 760, 169, 1, 0, 0,
		0, 761, 762, 5, 88, 0, 0, 762, 771, 5, 14, 0, 0, 763, 769, 3, 172, 86,
		0, 764, 765, 5, 1, 0, 0, 765, 767, 3, 184, 92, 0, 766, 768, 5, 76, 0, 0,
		767, 766, 1, 0, 0, 0, 767, 768, 1, 0, 0, 0, 768, 770, 1, 0, 0, 0, 769,
		764, 1, 0, 0, 0, 769, 770, 1, 0, 0, 0, 770, 772, 1, 0, 0, 0, 771, 763,
		1, 0, 0, 0, 771, 772, 1, 0, 0, 0, 772, 773, 1, 0, 0, 0, 773, 774, 5, 15,
		0, 0, 774, 171, 1, 0, 0, 0, 775, 778, 3, 180, 90, 0, 776, 778, 5, 24, 0,
		0, 777, 775, 1, 0, 0, 0, 777, 776, 1, 0, 0, 0, 778, 173, 1, 0, 0, 0, 779,
		780, 5, 89, 0, 0, 780, 781, 5, 14, 0, 0, 781, 782, 3, 176, 88, 0, 782,
		783, 5, 15, 0, 0, 783, 175, 1, 0, 0, 0, 784, 785, 3, 180, 90, 0, 785, 177,
		1, 0, 0, 0, 786, 787, 3, 194, 97, 0, 787, 179, 1, 0, 0, 0, 788, 789, 3,
		194, 97, 0, 789, 181, 1, 0, 0, 0, 790, 791, 3, 184, 92, 0, 791, 183, 1,
		0, 0, 0, 792, 793, 5, 102, 0, 0, 793, 185, 1, 0, 0, 0, 794, 797, 3, 188,
		94, 0, 795, 797, 3, 190, 95, 0, 796, 794, 1, 0, 0, 0, 796, 795, 1, 0, 0,
		0, 797, 187, 1, 0, 0, 0, 798, 799, 5, 78, 0, 0, 799, 800, 5, 14, 0, 0,
		800, 801, 5, 24, 0, 0, 801, 802, 5, 15, 0, 0, 802, 189, 1, 0, 0, 0, 803,
		804, 5, 78, 0, 0, 804, 813, 5, 14, 0, 0, 805, 810, 3, 140, 70, 0, 806,
		807, 5, 1, 0, 0, 807, 809, 3, 140, 70, 0, 808, 806, 1, 0, 0, 0, 809, 812,
		1, 0, 0, 0, 810, 808, 1, 0, 0, 0, 810, 811, 1, 0, 0, 0, 811, 814, 1, 0,
		0, 0, 812, 810, 1, 0, 0, 0, 813, 805, 1, 0, 0, 0, 813, 814, 1, 0, 0, 0,
		814, 815, 1, 0, 0, 0, 815, 816, 5, 15, 0, 0, 816, 817, 5, 35, 0, 0, 817,
		818, 3, 140, 70, 0, 818, 191, 1, 0, 0, 0, 819, 820, 5, 14, 0, 0, 820, 821,
		3, 144, 72, 0, 821, 822, 5, 15, 0, 0, 822, 193, 1, 0, 0, 0, 823, 824, 7,
		10, 0, 0, 824, 195, 1, 0, 0, 0, 825, 830, 5, 90, 0, 0, 826, 829, 5, 96,
		0, 0, 827, 829, 9, 0, 0, 0, 828, 826, 1, 0, 0, 0, 828, 827, 1, 0, 0, 0,
		829, 832, 1, 0, 0, 0, 830, 831, 1, 0, 0, 0, 830, 828, 1, 0, 0, 0, 831,
		833, 1, 0, 0, 0, 832, 830, 1, 0, 0, 0, 833, 844, 5, 90, 0, 0, 834, 839,
		5, 91, 0, 0, 835, 838, 5, 97, 0, 0, 836, 838, 9, 0, 0, 0, 837, 835, 1,
		0, 0, 0, 837, 836, 1, 0, 0, 0, 838, 841, 1, 0, 0, 0, 839, 840, 1, 0, 0,
		0, 839, 837, 1, 0, 0, 0, 840, 842, 1, 0, 0, 0, 841, 839, 1, 0, 0, 0, 842,
		844, 5, 91, 0, 0, 843, 825, 1, 0, 0, 0, 843, 834, 1, 0, 0, 0, 844, 197,
		1, 0, 0, 0, 70, 206, 212, 228, 236, 253, 276, 297, 322, 333, 341, 345,
		355, 366, 377, 388, 399, 410, 419, 427, 435, 443, 450, 468, 473, 478, 488,
		493, 497, 505, 523, 526, 534, 546, 552, 556, 567, 576, 578, 587, 597, 603,
		616, 625, 633, 642, 648, 657, 662, 668, 678, 680, 691, 705, 715, 735, 744,
		746, 752, 767, 769, 771, 777, 796, 810, 813, 828, 830, 837, 839, 843,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// XPath3ParserInit initializes any static state used to implement XPath3Parser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewXPath3Parser(). You can call this function if you wish to initialize the static state ahead
// of time.
func XPath3ParserInit() {
	staticData := &XPath3ParserStaticData
	staticData.once.Do(xpath3ParserInit)
}

// NewXPath3Parser produces a new parser instance for the optional input antlr.TokenStream.
func NewXPath3Parser(input antlr.TokenStream) *XPath3Parser {
	XPath3ParserInit()
	this := new(XPath3Parser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &XPath3ParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "XPath3.g"

	return this
}

// XPath3Parser tokens.
const (
	XPath3ParserEOF              = antlr.TokenEOF
	XPath3ParserT__0             = 1
	XPath3ParserT__1             = 2
	XPath3ParserT__2             = 3
	XPath3ParserT__3             = 4
	XPath3ParserT__4             = 5
	XPath3ParserT__5             = 6
	XPath3ParserT__6             = 7
	XPath3ParserT__7             = 8
	XPath3ParserT__8             = 9
	XPath3ParserT__9             = 10
	XPath3ParserT__10            = 11
	XPath3ParserT__11            = 12
	XPath3ParserT__12            = 13
	XPath3ParserT__13            = 14
	XPath3ParserT__14            = 15
	XPath3ParserT__15            = 16
	XPath3ParserT__16            = 17
	XPath3ParserT__17            = 18
	XPath3ParserT__18            = 19
	XPath3ParserT__19            = 20
	XPath3ParserT__20            = 21
	XPath3ParserT__21            = 22
	XPath3ParserT__22            = 23
	XPath3ParserT__23            = 24
	XPath3ParserT__24            = 25
	XPath3ParserT__25            = 26
	XPath3ParserT__26            = 27
	XPath3ParserT__27            = 28
	XPath3ParserT__28            = 29
	XPath3ParserT__29            = 30
	XPath3ParserT__30            = 31
	XPath3ParserT__31            = 32
	XPath3ParserT__32            = 33
	XPath3ParserT__33            = 34
	XPath3ParserT__34            = 35
	XPath3ParserT__35            = 36
	XPath3ParserT__36            = 37
	XPath3ParserT__37            = 38
	XPath3ParserT__38            = 39
	XPath3ParserT__39            = 40
	XPath3ParserT__40            = 41
	XPath3ParserT__41            = 42
	XPath3ParserT__42            = 43
	XPath3ParserT__43            = 44
	XPath3ParserT__44            = 45
	XPath3ParserT__45            = 46
	XPath3ParserT__46            = 47
	XPath3ParserT__47            = 48
	XPath3ParserT__48            = 49
	XPath3ParserT__49            = 50
	XPath3ParserT__50            = 51
	XPath3ParserT__51            = 52
	XPath3ParserT__52            = 53
	XPath3ParserT__53            = 54
	XPath3ParserT__54            = 55
	XPath3ParserT__55            = 56
	XPath3ParserT__56            = 57
	XPath3ParserT__57            = 58
	XPath3ParserT__58            = 59
	XPath3ParserT__59            = 60
	XPath3ParserT__60            = 61
	XPath3ParserT__61            = 62
	XPath3ParserT__62            = 63
	XPath3ParserT__63            = 64
	XPath3ParserT__64            = 65
	XPath3ParserT__65            = 66
	XPath3ParserT__66            = 67
	XPath3ParserT__67            = 68
	XPath3ParserT__68            = 69
	XPath3ParserT__69            = 70
	XPath3ParserT__70            = 71
	XPath3ParserT__71            = 72
	XPath3ParserT__72            = 73
	XPath3ParserT__73            = 74
	XPath3ParserT__74            = 75
	XPath3ParserT__75            = 76
	XPath3ParserT__76            = 77
	XPath3ParserT__77            = 78
	XPath3ParserT__78            = 79
	XPath3ParserT__79            = 80
	XPath3ParserT__80            = 81
	XPath3ParserT__81            = 82
	XPath3ParserT__82            = 83
	XPath3ParserT__83            = 84
	XPath3ParserT__84            = 85
	XPath3ParserT__85            = 86
	XPath3ParserT__86            = 87
	XPath3ParserT__87            = 88
	XPath3ParserT__88            = 89
	XPath3ParserT__89            = 90
	XPath3ParserT__90            = 91
	XPath3ParserNumericLiteral   = 92
	XPath3ParserIntegerLiteral   = 93
	XPath3ParserDecimalLiteral   = 94
	XPath3ParserDoubleLiteral    = 95
	XPath3ParserESCAPE_QUOTE     = 96
	XPath3ParserESCAPE_APOS      = 97
	XPath3ParserURIQualifiedName = 98
	XPath3ParserComment          = 99
	XPath3ParserBracedURILiteral = 100
	XPath3ParserCommentContents  = 101
	XPath3ParserQNAME            = 102
	XPath3ParserPREFIXED_NAME    = 103
	XPath3ParserUNPREFIXED_NAME  = 104
	XPath3ParserPREFIX           = 105
	XPath3ParserLOCAL_PART       = 106
	XPath3ParserNC_NAME          = 107
	XPath3ParserCHAR             = 108
	XPath3ParserDIGITS           = 109
)

// XPath3Parser rules.
const (
	XPath3ParserRULE_xPath                   = 0
	XPath3ParserRULE_paramList               = 1
	XPath3ParserRULE_param                   = 2
	XPath3ParserRULE_functionBody            = 3
	XPath3ParserRULE_enclosedExpr            = 4
	XPath3ParserRULE_expr                    = 5
	XPath3ParserRULE_exprSingle              = 6
	XPath3ParserRULE_forExpr                 = 7
	XPath3ParserRULE_simpleForClause         = 8
	XPath3ParserRULE_forBindingList          = 9
	XPath3ParserRULE_simpleForBinding        = 10
	XPath3ParserRULE_letExpr                 = 11
	XPath3ParserRULE_simpleLetClause         = 12
	XPath3ParserRULE_letBindingList          = 13
	XPath3ParserRULE_simpleLetBinding        = 14
	XPath3ParserRULE_quantifiedExpr          = 15
	XPath3ParserRULE_quantifiedBindingList   = 16
	XPath3ParserRULE_simpleQuantifiedBinding = 17
	XPath3ParserRULE_ifExpr                  = 18
	XPath3ParserRULE_orExpr                  = 19
	XPath3ParserRULE_andExpr                 = 20
	XPath3ParserRULE_comparisonExpr          = 21
	XPath3ParserRULE_stringConcatExpr        = 22
	XPath3ParserRULE_rangeExpr               = 23
	XPath3ParserRULE_additiveExpr            = 24
	XPath3ParserRULE_multiplicativeExpr      = 25
	XPath3ParserRULE_unionExpr               = 26
	XPath3ParserRULE_intersectExceptExpr     = 27
	XPath3ParserRULE_instanceofExpr          = 28
	XPath3ParserRULE_treatExpr               = 29
	XPath3ParserRULE_castableExpr            = 30
	XPath3ParserRULE_castExpr                = 31
	XPath3ParserRULE_unaryExpr               = 32
	XPath3ParserRULE_valueExpr               = 33
	XPath3ParserRULE_generalComp             = 34
	XPath3ParserRULE_valueComp               = 35
	XPath3ParserRULE_nodeComp                = 36
	XPath3ParserRULE_simpleMapExpr           = 37
	XPath3ParserRULE_pathExpr                = 38
	XPath3ParserRULE_relativePathExpr        = 39
	XPath3ParserRULE_stepExpr                = 40
	XPath3ParserRULE_axisStep                = 41
	XPath3ParserRULE_forwardStep             = 42
	XPath3ParserRULE_forwardAxis             = 43
	XPath3ParserRULE_abbrevForwardStep       = 44
	XPath3ParserRULE_reverseStep             = 45
	XPath3ParserRULE_reverseAxis             = 46
	XPath3ParserRULE_abbrevReverseStep       = 47
	XPath3ParserRULE_nodeTest                = 48
	XPath3ParserRULE_nameTest                = 49
	XPath3ParserRULE_wildCard                = 50
	XPath3ParserRULE_postfixExpr             = 51
	XPath3ParserRULE_argumentList            = 52
	XPath3ParserRULE_arguments               = 53
	XPath3ParserRULE_predicateList           = 54
	XPath3ParserRULE_predicate               = 55
	XPath3ParserRULE_primaryExpr             = 56
	XPath3ParserRULE_varRef                  = 57
	XPath3ParserRULE_varName                 = 58
	XPath3ParserRULE_literal                 = 59
	XPath3ParserRULE_parenthesizedExpr       = 60
	XPath3ParserRULE_contextItemExpr         = 61
	XPath3ParserRULE_functionCall            = 62
	XPath3ParserRULE_argument                = 63
	XPath3ParserRULE_argumentPlaceholder     = 64
	XPath3ParserRULE_functionItemExpr        = 65
	XPath3ParserRULE_namedFunctionRef        = 66
	XPath3ParserRULE_inlineFunctionExpr      = 67
	XPath3ParserRULE_singleType              = 68
	XPath3ParserRULE_type_declaration        = 69
	XPath3ParserRULE_sequenceType            = 70
	XPath3ParserRULE_occurenceIndicator      = 71
	XPath3ParserRULE_itemType                = 72
	XPath3ParserRULE_atomicOrUnionType       = 73
	XPath3ParserRULE_kindTest                = 74
	XPath3ParserRULE_anyKindTest             = 75
	XPath3ParserRULE_documentTest            = 76
	XPath3ParserRULE_textTest                = 77
	XPath3ParserRULE_commentTest             = 78
	XPath3ParserRULE_namespaceNodeTest       = 79
	XPath3ParserRULE_piTest                  = 80
	XPath3ParserRULE_attributeTest           = 81
	XPath3ParserRULE_attribNameOrWildcard    = 82
	XPath3ParserRULE_schemaAttributeTest     = 83
	XPath3ParserRULE_attributeDeclaration    = 84
	XPath3ParserRULE_elementTest             = 85
	XPath3ParserRULE_elementNameOrWildcard   = 86
	XPath3ParserRULE_schemaElementTest       = 87
	XPath3ParserRULE_elementDeclaration      = 88
	XPath3ParserRULE_attributeName           = 89
	XPath3ParserRULE_elementName             = 90
	XPath3ParserRULE_simpleTypeName          = 91
	XPath3ParserRULE_typeName                = 92
	XPath3ParserRULE_functionTest            = 93
	XPath3ParserRULE_anyFunctionTest         = 94
	XPath3ParserRULE_typedFunctionTest       = 95
	XPath3ParserRULE_parenthesizedItemType   = 96
	XPath3ParserRULE_eqName                  = 97
	XPath3ParserRULE_stringLiteral           = 98
)

// IXPathContext is an interface to support dynamic dispatch.
type IXPathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	EOF() antlr.TerminalNode

	// IsXPathContext differentiates from other interfaces.
	IsXPathContext()
}

type XPathContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXPathContext() *XPathContext {
	var p = new(XPathContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_xPath
	return p
}

func InitEmptyXPathContext(p *XPathContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_xPath
}

func (*XPathContext) IsXPathContext() {}

func NewXPathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XPathContext {
	var p = new(XPathContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_xPath

	return p
}

func (s *XPathContext) GetParser() antlr.Parser { return s.parser }

func (s *XPathContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *XPathContext) EOF() antlr.TerminalNode {
	return s.GetToken(XPath3ParserEOF, 0)
}

func (s *XPathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XPathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *XPathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterXPath(s)
	}
}

func (s *XPathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitXPath(s)
	}
}

func (p *XPath3Parser) XPath() (localctx IXPathContext) {
	localctx = NewXPathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, XPath3ParserRULE_xPath)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(198)
		p.expr(0)
	}
	{
		p.SetState(199)
		p.Match(XPath3ParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParamListContext is an interface to support dynamic dispatch.
type IParamListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllParam() []IParamContext
	Param(i int) IParamContext

	// IsParamListContext differentiates from other interfaces.
	IsParamListContext()
}

type ParamListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParamListContext() *ParamListContext {
	var p = new(ParamListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_paramList
	return p
}

func InitEmptyParamListContext(p *ParamListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_paramList
}

func (*ParamListContext) IsParamListContext() {}

func NewParamListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamListContext {
	var p = new(ParamListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_paramList

	return p
}

func (s *ParamListContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamListContext) AllParam() []IParamContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParamContext); ok {
			len++
		}
	}

	tst := make([]IParamContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParamContext); ok {
			tst[i] = t.(IParamContext)
			i++
		}
	}

	return tst
}

func (s *ParamListContext) Param(i int) IParamContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParamContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParamContext)
}

func (s *ParamListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParamListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterParamList(s)
	}
}

func (s *ParamListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitParamList(s)
	}
}

func (p *XPath3Parser) ParamList() (localctx IParamListContext) {
	localctx = NewParamListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, XPath3ParserRULE_paramList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(201)
		p.Param()
	}
	p.SetState(206)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == XPath3ParserT__0 {
		{
			p.SetState(202)
			p.Match(XPath3ParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(203)
			p.Param()
		}

		p.SetState(208)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParamContext is an interface to support dynamic dispatch.
type IParamContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EqName() IEqNameContext
	Type_declaration() IType_declarationContext

	// IsParamContext differentiates from other interfaces.
	IsParamContext()
}

type ParamContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParamContext() *ParamContext {
	var p = new(ParamContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_param
	return p
}

func InitEmptyParamContext(p *ParamContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_param
}

func (*ParamContext) IsParamContext() {}

func NewParamContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamContext {
	var p = new(ParamContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_param

	return p
}

func (s *ParamContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamContext) EqName() IEqNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqNameContext)
}

func (s *ParamContext) Type_declaration() IType_declarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_declarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_declarationContext)
}

func (s *ParamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterParam(s)
	}
}

func (s *ParamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitParam(s)
	}
}

func (p *XPath3Parser) Param() (localctx IParamContext) {
	localctx = NewParamContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, XPath3ParserRULE_param)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(209)
		p.Match(XPath3ParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(210)
		p.EqName()
	}
	p.SetState(212)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == XPath3ParserT__34 {
		{
			p.SetState(211)
			p.Type_declaration()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionBodyContext is an interface to support dynamic dispatch.
type IFunctionBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EnclosedExpr() IEnclosedExprContext

	// IsFunctionBodyContext differentiates from other interfaces.
	IsFunctionBodyContext()
}

type FunctionBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionBodyContext() *FunctionBodyContext {
	var p = new(FunctionBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_functionBody
	return p
}

func InitEmptyFunctionBodyContext(p *FunctionBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_functionBody
}

func (*FunctionBodyContext) IsFunctionBodyContext() {}

func NewFunctionBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionBodyContext {
	var p = new(FunctionBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_functionBody

	return p
}

func (s *FunctionBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionBodyContext) EnclosedExpr() IEnclosedExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnclosedExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnclosedExprContext)
}

func (s *FunctionBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterFunctionBody(s)
	}
}

func (s *FunctionBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitFunctionBody(s)
	}
}

func (p *XPath3Parser) FunctionBody() (localctx IFunctionBodyContext) {
	localctx = NewFunctionBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, XPath3ParserRULE_functionBody)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(214)
		p.EnclosedExpr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnclosedExprContext is an interface to support dynamic dispatch.
type IEnclosedExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext

	// IsEnclosedExprContext differentiates from other interfaces.
	IsEnclosedExprContext()
}

type EnclosedExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnclosedExprContext() *EnclosedExprContext {
	var p = new(EnclosedExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_enclosedExpr
	return p
}

func InitEmptyEnclosedExprContext(p *EnclosedExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_enclosedExpr
}

func (*EnclosedExprContext) IsEnclosedExprContext() {}

func NewEnclosedExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnclosedExprContext {
	var p = new(EnclosedExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_enclosedExpr

	return p
}

func (s *EnclosedExprContext) GetParser() antlr.Parser { return s.parser }

func (s *EnclosedExprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *EnclosedExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnclosedExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnclosedExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterEnclosedExpr(s)
	}
}

func (s *EnclosedExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitEnclosedExpr(s)
	}
}

func (p *XPath3Parser) EnclosedExpr() (localctx IEnclosedExprContext) {
	localctx = NewEnclosedExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, XPath3ParserRULE_enclosedExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(216)
		p.Match(XPath3ParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(217)
		p.expr(0)
	}
	{
		p.SetState(218)
		p.Match(XPath3ParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExprSingle() IExprSingleContext
	Expr() IExprContext

	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_expr
	return p
}

func InitEmptyExprContext(p *ExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_expr
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) ExprSingle() IExprSingleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprSingleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprSingleContext)
}

func (s *ExprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterExpr(s)
	}
}

func (s *ExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitExpr(s)
	}
}

func (p *XPath3Parser) Expr() (localctx IExprContext) {
	return p.expr(0)
}

func (p *XPath3Parser) expr(_p int) (localctx IExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 10
	p.EnterRecursionRule(localctx, 10, XPath3ParserRULE_expr, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(221)
		p.ExprSingle()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(228)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 2, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewExprContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, XPath3ParserRULE_expr)
			p.SetState(223)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(224)
				p.Match(XPath3ParserT__0)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(225)
				p.ExprSingle()
			}

		}
		p.SetState(230)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 2, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprSingleContext is an interface to support dynamic dispatch.
type IExprSingleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ForExpr() IForExprContext
	LetExpr() ILetExprContext
	QuantifiedExpr() IQuantifiedExprContext
	IfExpr() IIfExprContext
	OrExpr() IOrExprContext

	// IsExprSingleContext differentiates from other interfaces.
	IsExprSingleContext()
}

type ExprSingleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprSingleContext() *ExprSingleContext {
	var p = new(ExprSingleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_exprSingle
	return p
}

func InitEmptyExprSingleContext(p *ExprSingleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_exprSingle
}

func (*ExprSingleContext) IsExprSingleContext() {}

func NewExprSingleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprSingleContext {
	var p = new(ExprSingleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_exprSingle

	return p
}

func (s *ExprSingleContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprSingleContext) ForExpr() IForExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForExprContext)
}

func (s *ExprSingleContext) LetExpr() ILetExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetExprContext)
}

func (s *ExprSingleContext) QuantifiedExpr() IQuantifiedExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuantifiedExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuantifiedExprContext)
}

func (s *ExprSingleContext) IfExpr() IIfExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExprContext)
}

func (s *ExprSingleContext) OrExpr() IOrExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrExprContext)
}

func (s *ExprSingleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprSingleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprSingleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterExprSingle(s)
	}
}

func (s *ExprSingleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitExprSingle(s)
	}
}

func (p *XPath3Parser) ExprSingle() (localctx IExprSingleContext) {
	localctx = NewExprSingleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, XPath3ParserRULE_exprSingle)
	p.SetState(236)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserT__5:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(231)
			p.ForExpr()
		}

	case XPath3ParserT__7:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(232)
			p.LetExpr()
		}

	case XPath3ParserT__9, XPath3ParserT__10:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(233)
			p.QuantifiedExpr()
		}

	case XPath3ParserT__12:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(234)
			p.IfExpr()
		}

	case XPath3ParserT__1, XPath3ParserT__13, XPath3ParserT__21, XPath3ParserT__22, XPath3ParserT__23, XPath3ParserT__53, XPath3ParserT__54, XPath3ParserT__55, XPath3ParserT__57, XPath3ParserT__58, XPath3ParserT__59, XPath3ParserT__60, XPath3ParserT__61, XPath3ParserT__62, XPath3ParserT__63, XPath3ParserT__64, XPath3ParserT__65, XPath3ParserT__66, XPath3ParserT__67, XPath3ParserT__68, XPath3ParserT__69, XPath3ParserT__70, XPath3ParserT__74, XPath3ParserT__77, XPath3ParserT__80, XPath3ParserT__81, XPath3ParserT__82, XPath3ParserT__83, XPath3ParserT__84, XPath3ParserT__85, XPath3ParserT__86, XPath3ParserT__87, XPath3ParserT__88, XPath3ParserT__89, XPath3ParserT__90, XPath3ParserNumericLiteral, XPath3ParserURIQualifiedName, XPath3ParserBracedURILiteral, XPath3ParserQNAME, XPath3ParserNC_NAME:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(235)
			p.orExpr(0)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForExprContext is an interface to support dynamic dispatch.
type IForExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleForClause() ISimpleForClauseContext
	ExprSingle() IExprSingleContext

	// IsForExprContext differentiates from other interfaces.
	IsForExprContext()
}

type ForExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForExprContext() *ForExprContext {
	var p = new(ForExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_forExpr
	return p
}

func InitEmptyForExprContext(p *ForExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_forExpr
}

func (*ForExprContext) IsForExprContext() {}

func NewForExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForExprContext {
	var p = new(ForExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_forExpr

	return p
}

func (s *ForExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ForExprContext) SimpleForClause() ISimpleForClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleForClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleForClauseContext)
}

func (s *ForExprContext) ExprSingle() IExprSingleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprSingleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprSingleContext)
}

func (s *ForExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterForExpr(s)
	}
}

func (s *ForExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitForExpr(s)
	}
}

func (p *XPath3Parser) ForExpr() (localctx IForExprContext) {
	localctx = NewForExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, XPath3ParserRULE_forExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(238)
		p.SimpleForClause()
	}
	{
		p.SetState(239)
		p.Match(XPath3ParserT__4)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(240)
		p.ExprSingle()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleForClauseContext is an interface to support dynamic dispatch.
type ISimpleForClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ForBindingList() IForBindingListContext

	// IsSimpleForClauseContext differentiates from other interfaces.
	IsSimpleForClauseContext()
}

type SimpleForClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleForClauseContext() *SimpleForClauseContext {
	var p = new(SimpleForClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_simpleForClause
	return p
}

func InitEmptySimpleForClauseContext(p *SimpleForClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_simpleForClause
}

func (*SimpleForClauseContext) IsSimpleForClauseContext() {}

func NewSimpleForClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleForClauseContext {
	var p = new(SimpleForClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_simpleForClause

	return p
}

func (s *SimpleForClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleForClauseContext) ForBindingList() IForBindingListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForBindingListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForBindingListContext)
}

func (s *SimpleForClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleForClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleForClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterSimpleForClause(s)
	}
}

func (s *SimpleForClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitSimpleForClause(s)
	}
}

func (p *XPath3Parser) SimpleForClause() (localctx ISimpleForClauseContext) {
	localctx = NewSimpleForClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, XPath3ParserRULE_simpleForClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(242)
		p.Match(XPath3ParserT__5)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(243)
		p.forBindingList(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForBindingListContext is an interface to support dynamic dispatch.
type IForBindingListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleForBinding() ISimpleForBindingContext
	ForBindingList() IForBindingListContext

	// IsForBindingListContext differentiates from other interfaces.
	IsForBindingListContext()
}

type ForBindingListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForBindingListContext() *ForBindingListContext {
	var p = new(ForBindingListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_forBindingList
	return p
}

func InitEmptyForBindingListContext(p *ForBindingListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_forBindingList
}

func (*ForBindingListContext) IsForBindingListContext() {}

func NewForBindingListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForBindingListContext {
	var p = new(ForBindingListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_forBindingList

	return p
}

func (s *ForBindingListContext) GetParser() antlr.Parser { return s.parser }

func (s *ForBindingListContext) SimpleForBinding() ISimpleForBindingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleForBindingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleForBindingContext)
}

func (s *ForBindingListContext) ForBindingList() IForBindingListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForBindingListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForBindingListContext)
}

func (s *ForBindingListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForBindingListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForBindingListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterForBindingList(s)
	}
}

func (s *ForBindingListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitForBindingList(s)
	}
}

func (p *XPath3Parser) ForBindingList() (localctx IForBindingListContext) {
	return p.forBindingList(0)
}

func (p *XPath3Parser) forBindingList(_p int) (localctx IForBindingListContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewForBindingListContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IForBindingListContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 18
	p.EnterRecursionRule(localctx, 18, XPath3ParserRULE_forBindingList, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(246)
		p.SimpleForBinding()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(253)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 4, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewForBindingListContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, XPath3ParserRULE_forBindingList)
			p.SetState(248)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(249)
				p.Match(XPath3ParserT__0)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(250)
				p.SimpleForBinding()
			}

		}
		p.SetState(255)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 4, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleForBindingContext is an interface to support dynamic dispatch.
type ISimpleForBindingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VarName() IVarNameContext
	ExprSingle() IExprSingleContext

	// IsSimpleForBindingContext differentiates from other interfaces.
	IsSimpleForBindingContext()
}

type SimpleForBindingContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleForBindingContext() *SimpleForBindingContext {
	var p = new(SimpleForBindingContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_simpleForBinding
	return p
}

func InitEmptySimpleForBindingContext(p *SimpleForBindingContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_simpleForBinding
}

func (*SimpleForBindingContext) IsSimpleForBindingContext() {}

func NewSimpleForBindingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleForBindingContext {
	var p = new(SimpleForBindingContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_simpleForBinding

	return p
}

func (s *SimpleForBindingContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleForBindingContext) VarName() IVarNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarNameContext)
}

func (s *SimpleForBindingContext) ExprSingle() IExprSingleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprSingleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprSingleContext)
}

func (s *SimpleForBindingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleForBindingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleForBindingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterSimpleForBinding(s)
	}
}

func (s *SimpleForBindingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitSimpleForBinding(s)
	}
}

func (p *XPath3Parser) SimpleForBinding() (localctx ISimpleForBindingContext) {
	localctx = NewSimpleForBindingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, XPath3ParserRULE_simpleForBinding)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(256)
		p.Match(XPath3ParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(257)
		p.VarName()
	}
	{
		p.SetState(258)
		p.Match(XPath3ParserT__6)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(259)
		p.ExprSingle()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetExprContext is an interface to support dynamic dispatch.
type ILetExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleLetClause() ISimpleLetClauseContext
	ExprSingle() IExprSingleContext

	// IsLetExprContext differentiates from other interfaces.
	IsLetExprContext()
}

type LetExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetExprContext() *LetExprContext {
	var p = new(LetExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_letExpr
	return p
}

func InitEmptyLetExprContext(p *LetExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_letExpr
}

func (*LetExprContext) IsLetExprContext() {}

func NewLetExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetExprContext {
	var p = new(LetExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_letExpr

	return p
}

func (s *LetExprContext) GetParser() antlr.Parser { return s.parser }

func (s *LetExprContext) SimpleLetClause() ISimpleLetClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleLetClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleLetClauseContext)
}

func (s *LetExprContext) ExprSingle() IExprSingleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprSingleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprSingleContext)
}

func (s *LetExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterLetExpr(s)
	}
}

func (s *LetExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitLetExpr(s)
	}
}

func (p *XPath3Parser) LetExpr() (localctx ILetExprContext) {
	localctx = NewLetExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, XPath3ParserRULE_letExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(261)
		p.SimpleLetClause()
	}
	{
		p.SetState(262)
		p.Match(XPath3ParserT__4)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(263)
		p.ExprSingle()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleLetClauseContext is an interface to support dynamic dispatch.
type ISimpleLetClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LetBindingList() ILetBindingListContext

	// IsSimpleLetClauseContext differentiates from other interfaces.
	IsSimpleLetClauseContext()
}

type SimpleLetClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleLetClauseContext() *SimpleLetClauseContext {
	var p = new(SimpleLetClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_simpleLetClause
	return p
}

func InitEmptySimpleLetClauseContext(p *SimpleLetClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_simpleLetClause
}

func (*SimpleLetClauseContext) IsSimpleLetClauseContext() {}

func NewSimpleLetClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleLetClauseContext {
	var p = new(SimpleLetClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_simpleLetClause

	return p
}

func (s *SimpleLetClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleLetClauseContext) LetBindingList() ILetBindingListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetBindingListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetBindingListContext)
}

func (s *SimpleLetClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleLetClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleLetClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterSimpleLetClause(s)
	}
}

func (s *SimpleLetClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitSimpleLetClause(s)
	}
}

func (p *XPath3Parser) SimpleLetClause() (localctx ISimpleLetClauseContext) {
	localctx = NewSimpleLetClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, XPath3ParserRULE_simpleLetClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(265)
		p.Match(XPath3ParserT__7)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(266)
		p.letBindingList(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetBindingListContext is an interface to support dynamic dispatch.
type ILetBindingListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleLetClause() ISimpleLetClauseContext
	LetBindingList() ILetBindingListContext
	SimpleLetBinding() ISimpleLetBindingContext

	// IsLetBindingListContext differentiates from other interfaces.
	IsLetBindingListContext()
}

type LetBindingListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetBindingListContext() *LetBindingListContext {
	var p = new(LetBindingListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_letBindingList
	return p
}

func InitEmptyLetBindingListContext(p *LetBindingListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_letBindingList
}

func (*LetBindingListContext) IsLetBindingListContext() {}

func NewLetBindingListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetBindingListContext {
	var p = new(LetBindingListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_letBindingList

	return p
}

func (s *LetBindingListContext) GetParser() antlr.Parser { return s.parser }

func (s *LetBindingListContext) SimpleLetClause() ISimpleLetClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleLetClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleLetClauseContext)
}

func (s *LetBindingListContext) LetBindingList() ILetBindingListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetBindingListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetBindingListContext)
}

func (s *LetBindingListContext) SimpleLetBinding() ISimpleLetBindingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleLetBindingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleLetBindingContext)
}

func (s *LetBindingListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetBindingListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetBindingListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterLetBindingList(s)
	}
}

func (s *LetBindingListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitLetBindingList(s)
	}
}

func (p *XPath3Parser) LetBindingList() (localctx ILetBindingListContext) {
	return p.letBindingList(0)
}

func (p *XPath3Parser) letBindingList(_p int) (localctx ILetBindingListContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewLetBindingListContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ILetBindingListContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 26
	p.EnterRecursionRule(localctx, 26, XPath3ParserRULE_letBindingList, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(269)
		p.SimpleLetClause()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(276)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewLetBindingListContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, XPath3ParserRULE_letBindingList)
			p.SetState(271)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(272)
				p.Match(XPath3ParserT__0)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(273)
				p.SimpleLetBinding()
			}

		}
		p.SetState(278)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleLetBindingContext is an interface to support dynamic dispatch.
type ISimpleLetBindingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VarName() IVarNameContext
	ExprSingle() IExprSingleContext

	// IsSimpleLetBindingContext differentiates from other interfaces.
	IsSimpleLetBindingContext()
}

type SimpleLetBindingContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleLetBindingContext() *SimpleLetBindingContext {
	var p = new(SimpleLetBindingContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_simpleLetBinding
	return p
}

func InitEmptySimpleLetBindingContext(p *SimpleLetBindingContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_simpleLetBinding
}

func (*SimpleLetBindingContext) IsSimpleLetBindingContext() {}

func NewSimpleLetBindingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleLetBindingContext {
	var p = new(SimpleLetBindingContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_simpleLetBinding

	return p
}

func (s *SimpleLetBindingContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleLetBindingContext) VarName() IVarNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarNameContext)
}

func (s *SimpleLetBindingContext) ExprSingle() IExprSingleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprSingleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprSingleContext)
}

func (s *SimpleLetBindingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleLetBindingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleLetBindingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterSimpleLetBinding(s)
	}
}

func (s *SimpleLetBindingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitSimpleLetBinding(s)
	}
}

func (p *XPath3Parser) SimpleLetBinding() (localctx ISimpleLetBindingContext) {
	localctx = NewSimpleLetBindingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, XPath3ParserRULE_simpleLetBinding)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(279)
		p.Match(XPath3ParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(280)
		p.VarName()
	}
	{
		p.SetState(281)
		p.Match(XPath3ParserT__8)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(282)
		p.ExprSingle()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQuantifiedExprContext is an interface to support dynamic dispatch.
type IQuantifiedExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetQuantifiedOp returns the quantifiedOp token.
	GetQuantifiedOp() antlr.Token

	// SetQuantifiedOp sets the quantifiedOp token.
	SetQuantifiedOp(antlr.Token)

	// Getter signatures
	QuantifiedBindingList() IQuantifiedBindingListContext
	ExprSingle() IExprSingleContext

	// IsQuantifiedExprContext differentiates from other interfaces.
	IsQuantifiedExprContext()
}

type QuantifiedExprContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	quantifiedOp antlr.Token
}

func NewEmptyQuantifiedExprContext() *QuantifiedExprContext {
	var p = new(QuantifiedExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_quantifiedExpr
	return p
}

func InitEmptyQuantifiedExprContext(p *QuantifiedExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_quantifiedExpr
}

func (*QuantifiedExprContext) IsQuantifiedExprContext() {}

func NewQuantifiedExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuantifiedExprContext {
	var p = new(QuantifiedExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_quantifiedExpr

	return p
}

func (s *QuantifiedExprContext) GetParser() antlr.Parser { return s.parser }

func (s *QuantifiedExprContext) GetQuantifiedOp() antlr.Token { return s.quantifiedOp }

func (s *QuantifiedExprContext) SetQuantifiedOp(v antlr.Token) { s.quantifiedOp = v }

func (s *QuantifiedExprContext) QuantifiedBindingList() IQuantifiedBindingListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuantifiedBindingListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuantifiedBindingListContext)
}

func (s *QuantifiedExprContext) ExprSingle() IExprSingleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprSingleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprSingleContext)
}

func (s *QuantifiedExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuantifiedExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuantifiedExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterQuantifiedExpr(s)
	}
}

func (s *QuantifiedExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitQuantifiedExpr(s)
	}
}

func (p *XPath3Parser) QuantifiedExpr() (localctx IQuantifiedExprContext) {
	localctx = NewQuantifiedExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, XPath3ParserRULE_quantifiedExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(284)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*QuantifiedExprContext).quantifiedOp = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == XPath3ParserT__9 || _la == XPath3ParserT__10) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*QuantifiedExprContext).quantifiedOp = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(285)
		p.quantifiedBindingList(0)
	}
	{
		p.SetState(286)
		p.Match(XPath3ParserT__11)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(287)
		p.ExprSingle()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQuantifiedBindingListContext is an interface to support dynamic dispatch.
type IQuantifiedBindingListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleQuantifiedBinding() ISimpleQuantifiedBindingContext
	QuantifiedBindingList() IQuantifiedBindingListContext

	// IsQuantifiedBindingListContext differentiates from other interfaces.
	IsQuantifiedBindingListContext()
}

type QuantifiedBindingListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuantifiedBindingListContext() *QuantifiedBindingListContext {
	var p = new(QuantifiedBindingListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_quantifiedBindingList
	return p
}

func InitEmptyQuantifiedBindingListContext(p *QuantifiedBindingListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_quantifiedBindingList
}

func (*QuantifiedBindingListContext) IsQuantifiedBindingListContext() {}

func NewQuantifiedBindingListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuantifiedBindingListContext {
	var p = new(QuantifiedBindingListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_quantifiedBindingList

	return p
}

func (s *QuantifiedBindingListContext) GetParser() antlr.Parser { return s.parser }

func (s *QuantifiedBindingListContext) SimpleQuantifiedBinding() ISimpleQuantifiedBindingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleQuantifiedBindingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleQuantifiedBindingContext)
}

func (s *QuantifiedBindingListContext) QuantifiedBindingList() IQuantifiedBindingListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuantifiedBindingListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuantifiedBindingListContext)
}

func (s *QuantifiedBindingListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuantifiedBindingListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuantifiedBindingListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterQuantifiedBindingList(s)
	}
}

func (s *QuantifiedBindingListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitQuantifiedBindingList(s)
	}
}

func (p *XPath3Parser) QuantifiedBindingList() (localctx IQuantifiedBindingListContext) {
	return p.quantifiedBindingList(0)
}

func (p *XPath3Parser) quantifiedBindingList(_p int) (localctx IQuantifiedBindingListContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewQuantifiedBindingListContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IQuantifiedBindingListContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 32
	p.EnterRecursionRule(localctx, 32, XPath3ParserRULE_quantifiedBindingList, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(290)
		p.SimpleQuantifiedBinding()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(297)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 6, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewQuantifiedBindingListContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, XPath3ParserRULE_quantifiedBindingList)
			p.SetState(292)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(293)
				p.Match(XPath3ParserT__0)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(294)
				p.SimpleQuantifiedBinding()
			}

		}
		p.SetState(299)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 6, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleQuantifiedBindingContext is an interface to support dynamic dispatch.
type ISimpleQuantifiedBindingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VarName() IVarNameContext
	ExprSingle() IExprSingleContext

	// IsSimpleQuantifiedBindingContext differentiates from other interfaces.
	IsSimpleQuantifiedBindingContext()
}

type SimpleQuantifiedBindingContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleQuantifiedBindingContext() *SimpleQuantifiedBindingContext {
	var p = new(SimpleQuantifiedBindingContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_simpleQuantifiedBinding
	return p
}

func InitEmptySimpleQuantifiedBindingContext(p *SimpleQuantifiedBindingContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_simpleQuantifiedBinding
}

func (*SimpleQuantifiedBindingContext) IsSimpleQuantifiedBindingContext() {}

func NewSimpleQuantifiedBindingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleQuantifiedBindingContext {
	var p = new(SimpleQuantifiedBindingContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_simpleQuantifiedBinding

	return p
}

func (s *SimpleQuantifiedBindingContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleQuantifiedBindingContext) VarName() IVarNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarNameContext)
}

func (s *SimpleQuantifiedBindingContext) ExprSingle() IExprSingleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprSingleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprSingleContext)
}

func (s *SimpleQuantifiedBindingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleQuantifiedBindingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleQuantifiedBindingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterSimpleQuantifiedBinding(s)
	}
}

func (s *SimpleQuantifiedBindingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitSimpleQuantifiedBinding(s)
	}
}

func (p *XPath3Parser) SimpleQuantifiedBinding() (localctx ISimpleQuantifiedBindingContext) {
	localctx = NewSimpleQuantifiedBindingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, XPath3ParserRULE_simpleQuantifiedBinding)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(300)
		p.Match(XPath3ParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(301)
		p.VarName()
	}
	{
		p.SetState(302)
		p.Match(XPath3ParserT__6)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(303)
		p.ExprSingle()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfExprContext is an interface to support dynamic dispatch.
type IIfExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	AllExprSingle() []IExprSingleContext
	ExprSingle(i int) IExprSingleContext

	// IsIfExprContext differentiates from other interfaces.
	IsIfExprContext()
}

type IfExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfExprContext() *IfExprContext {
	var p = new(IfExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_ifExpr
	return p
}

func InitEmptyIfExprContext(p *IfExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_ifExpr
}

func (*IfExprContext) IsIfExprContext() {}

func NewIfExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfExprContext {
	var p = new(IfExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_ifExpr

	return p
}

func (s *IfExprContext) GetParser() antlr.Parser { return s.parser }

func (s *IfExprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *IfExprContext) AllExprSingle() []IExprSingleContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprSingleContext); ok {
			len++
		}
	}

	tst := make([]IExprSingleContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprSingleContext); ok {
			tst[i] = t.(IExprSingleContext)
			i++
		}
	}

	return tst
}

func (s *IfExprContext) ExprSingle(i int) IExprSingleContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprSingleContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprSingleContext)
}

func (s *IfExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterIfExpr(s)
	}
}

func (s *IfExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitIfExpr(s)
	}
}

func (p *XPath3Parser) IfExpr() (localctx IIfExprContext) {
	localctx = NewIfExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, XPath3ParserRULE_ifExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(305)
		p.Match(XPath3ParserT__12)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(306)
		p.Match(XPath3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(307)
		p.expr(0)
	}
	{
		p.SetState(308)
		p.Match(XPath3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(309)
		p.Match(XPath3ParserT__15)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(310)
		p.ExprSingle()
	}
	{
		p.SetState(311)
		p.Match(XPath3ParserT__16)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(312)
		p.ExprSingle()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrExprContext is an interface to support dynamic dispatch.
type IOrExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AndExpr() IAndExprContext
	OrExpr() IOrExprContext

	// IsOrExprContext differentiates from other interfaces.
	IsOrExprContext()
}

type OrExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrExprContext() *OrExprContext {
	var p = new(OrExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_orExpr
	return p
}

func InitEmptyOrExprContext(p *OrExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_orExpr
}

func (*OrExprContext) IsOrExprContext() {}

func NewOrExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrExprContext {
	var p = new(OrExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_orExpr

	return p
}

func (s *OrExprContext) GetParser() antlr.Parser { return s.parser }

func (s *OrExprContext) AndExpr() IAndExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAndExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAndExprContext)
}

func (s *OrExprContext) OrExpr() IOrExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrExprContext)
}

func (s *OrExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterOrExpr(s)
	}
}

func (s *OrExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitOrExpr(s)
	}
}

func (p *XPath3Parser) OrExpr() (localctx IOrExprContext) {
	return p.orExpr(0)
}

func (p *XPath3Parser) orExpr(_p int) (localctx IOrExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewOrExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IOrExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 38
	p.EnterRecursionRule(localctx, 38, XPath3ParserRULE_orExpr, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(315)
		p.andExpr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(322)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 7, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewOrExprContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, XPath3ParserRULE_orExpr)
			p.SetState(317)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(318)
				p.Match(XPath3ParserT__17)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(319)
				p.andExpr(0)
			}

		}
		p.SetState(324)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 7, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAndExprContext is an interface to support dynamic dispatch.
type IAndExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ComparisonExpr() IComparisonExprContext
	AndExpr() IAndExprContext

	// IsAndExprContext differentiates from other interfaces.
	IsAndExprContext()
}

type AndExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAndExprContext() *AndExprContext {
	var p = new(AndExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_andExpr
	return p
}

func InitEmptyAndExprContext(p *AndExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_andExpr
}

func (*AndExprContext) IsAndExprContext() {}

func NewAndExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AndExprContext {
	var p = new(AndExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_andExpr

	return p
}

func (s *AndExprContext) GetParser() antlr.Parser { return s.parser }

func (s *AndExprContext) ComparisonExpr() IComparisonExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonExprContext)
}

func (s *AndExprContext) AndExpr() IAndExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAndExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAndExprContext)
}

func (s *AndExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AndExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AndExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterAndExpr(s)
	}
}

func (s *AndExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitAndExpr(s)
	}
}

func (p *XPath3Parser) AndExpr() (localctx IAndExprContext) {
	return p.andExpr(0)
}

func (p *XPath3Parser) andExpr(_p int) (localctx IAndExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewAndExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IAndExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 40
	p.EnterRecursionRule(localctx, 40, XPath3ParserRULE_andExpr, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(326)
		p.ComparisonExpr()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(333)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 8, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewAndExprContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, XPath3ParserRULE_andExpr)
			p.SetState(328)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(329)
				p.Match(XPath3ParserT__18)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(330)
				p.ComparisonExpr()
			}

		}
		p.SetState(335)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 8, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparisonExprContext is an interface to support dynamic dispatch.
type IComparisonExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllStringConcatExpr() []IStringConcatExprContext
	StringConcatExpr(i int) IStringConcatExprContext
	ValueComp() IValueCompContext
	GeneralComp() IGeneralCompContext
	NodeComp() INodeCompContext

	// IsComparisonExprContext differentiates from other interfaces.
	IsComparisonExprContext()
}

type ComparisonExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonExprContext() *ComparisonExprContext {
	var p = new(ComparisonExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_comparisonExpr
	return p
}

func InitEmptyComparisonExprContext(p *ComparisonExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_comparisonExpr
}

func (*ComparisonExprContext) IsComparisonExprContext() {}

func NewComparisonExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonExprContext {
	var p = new(ComparisonExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_comparisonExpr

	return p
}

func (s *ComparisonExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonExprContext) AllStringConcatExpr() []IStringConcatExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringConcatExprContext); ok {
			len++
		}
	}

	tst := make([]IStringConcatExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringConcatExprContext); ok {
			tst[i] = t.(IStringConcatExprContext)
			i++
		}
	}

	return tst
}

func (s *ComparisonExprContext) StringConcatExpr(i int) IStringConcatExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringConcatExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringConcatExprContext)
}

func (s *ComparisonExprContext) ValueComp() IValueCompContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueCompContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueCompContext)
}

func (s *ComparisonExprContext) GeneralComp() IGeneralCompContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGeneralCompContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGeneralCompContext)
}

func (s *ComparisonExprContext) NodeComp() INodeCompContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeCompContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeCompContext)
}

func (s *ComparisonExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterComparisonExpr(s)
	}
}

func (s *ComparisonExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitComparisonExpr(s)
	}
}

func (p *XPath3Parser) ComparisonExpr() (localctx IComparisonExprContext) {
	localctx = NewComparisonExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, XPath3ParserRULE_comparisonExpr)
	p.SetState(345)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(336)
			p.stringConcatExpr(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(337)
			p.stringConcatExpr(0)
		}
		p.SetState(341)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case XPath3ParserT__43, XPath3ParserT__44, XPath3ParserT__45, XPath3ParserT__46, XPath3ParserT__47, XPath3ParserT__48:
			{
				p.SetState(338)
				p.ValueComp()
			}

		case XPath3ParserT__37, XPath3ParserT__38, XPath3ParserT__39, XPath3ParserT__40, XPath3ParserT__41, XPath3ParserT__42:
			{
				p.SetState(339)
				p.GeneralComp()
			}

		case XPath3ParserT__49, XPath3ParserT__50, XPath3ParserT__51:
			{
				p.SetState(340)
				p.NodeComp()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(343)
			p.stringConcatExpr(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringConcatExprContext is an interface to support dynamic dispatch.
type IStringConcatExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RangeExpr() IRangeExprContext
	StringConcatExpr() IStringConcatExprContext

	// IsStringConcatExprContext differentiates from other interfaces.
	IsStringConcatExprContext()
}

type StringConcatExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringConcatExprContext() *StringConcatExprContext {
	var p = new(StringConcatExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_stringConcatExpr
	return p
}

func InitEmptyStringConcatExprContext(p *StringConcatExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_stringConcatExpr
}

func (*StringConcatExprContext) IsStringConcatExprContext() {}

func NewStringConcatExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringConcatExprContext {
	var p = new(StringConcatExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_stringConcatExpr

	return p
}

func (s *StringConcatExprContext) GetParser() antlr.Parser { return s.parser }

func (s *StringConcatExprContext) RangeExpr() IRangeExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRangeExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRangeExprContext)
}

func (s *StringConcatExprContext) StringConcatExpr() IStringConcatExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringConcatExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringConcatExprContext)
}

func (s *StringConcatExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringConcatExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringConcatExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterStringConcatExpr(s)
	}
}

func (s *StringConcatExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitStringConcatExpr(s)
	}
}

func (p *XPath3Parser) StringConcatExpr() (localctx IStringConcatExprContext) {
	return p.stringConcatExpr(0)
}

func (p *XPath3Parser) stringConcatExpr(_p int) (localctx IStringConcatExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewStringConcatExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IStringConcatExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 44
	p.EnterRecursionRule(localctx, 44, XPath3ParserRULE_stringConcatExpr, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(348)
		p.rangeExpr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(355)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 11, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewStringConcatExprContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, XPath3ParserRULE_stringConcatExpr)
			p.SetState(350)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(351)
				p.Match(XPath3ParserT__19)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(352)
				p.rangeExpr(0)
			}

		}
		p.SetState(357)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 11, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRangeExprContext is an interface to support dynamic dispatch.
type IRangeExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AdditiveExpr() IAdditiveExprContext
	RangeExpr() IRangeExprContext

	// IsRangeExprContext differentiates from other interfaces.
	IsRangeExprContext()
}

type RangeExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRangeExprContext() *RangeExprContext {
	var p = new(RangeExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_rangeExpr
	return p
}

func InitEmptyRangeExprContext(p *RangeExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_rangeExpr
}

func (*RangeExprContext) IsRangeExprContext() {}

func NewRangeExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RangeExprContext {
	var p = new(RangeExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_rangeExpr

	return p
}

func (s *RangeExprContext) GetParser() antlr.Parser { return s.parser }

func (s *RangeExprContext) AdditiveExpr() IAdditiveExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdditiveExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdditiveExprContext)
}

func (s *RangeExprContext) RangeExpr() IRangeExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRangeExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRangeExprContext)
}

func (s *RangeExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RangeExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RangeExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterRangeExpr(s)
	}
}

func (s *RangeExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitRangeExpr(s)
	}
}

func (p *XPath3Parser) RangeExpr() (localctx IRangeExprContext) {
	return p.rangeExpr(0)
}

func (p *XPath3Parser) rangeExpr(_p int) (localctx IRangeExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewRangeExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRangeExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 46
	p.EnterRecursionRule(localctx, 46, XPath3ParserRULE_rangeExpr, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(359)
		p.additiveExpr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(366)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewRangeExprContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, XPath3ParserRULE_rangeExpr)
			p.SetState(361)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(362)
				p.Match(XPath3ParserT__20)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(363)
				p.additiveExpr(0)
			}

		}
		p.SetState(368)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdditiveExprContext is an interface to support dynamic dispatch.
type IAdditiveExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAdditiveOp returns the additiveOp token.
	GetAdditiveOp() antlr.Token

	// SetAdditiveOp sets the additiveOp token.
	SetAdditiveOp(antlr.Token)

	// Getter signatures
	MultiplicativeExpr() IMultiplicativeExprContext
	AdditiveExpr() IAdditiveExprContext

	// IsAdditiveExprContext differentiates from other interfaces.
	IsAdditiveExprContext()
}

type AdditiveExprContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	additiveOp antlr.Token
}

func NewEmptyAdditiveExprContext() *AdditiveExprContext {
	var p = new(AdditiveExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_additiveExpr
	return p
}

func InitEmptyAdditiveExprContext(p *AdditiveExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_additiveExpr
}

func (*AdditiveExprContext) IsAdditiveExprContext() {}

func NewAdditiveExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdditiveExprContext {
	var p = new(AdditiveExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_additiveExpr

	return p
}

func (s *AdditiveExprContext) GetParser() antlr.Parser { return s.parser }

func (s *AdditiveExprContext) GetAdditiveOp() antlr.Token { return s.additiveOp }

func (s *AdditiveExprContext) SetAdditiveOp(v antlr.Token) { s.additiveOp = v }

func (s *AdditiveExprContext) MultiplicativeExpr() IMultiplicativeExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiplicativeExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiplicativeExprContext)
}

func (s *AdditiveExprContext) AdditiveExpr() IAdditiveExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdditiveExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdditiveExprContext)
}

func (s *AdditiveExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditiveExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdditiveExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterAdditiveExpr(s)
	}
}

func (s *AdditiveExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitAdditiveExpr(s)
	}
}

func (p *XPath3Parser) AdditiveExpr() (localctx IAdditiveExprContext) {
	return p.additiveExpr(0)
}

func (p *XPath3Parser) additiveExpr(_p int) (localctx IAdditiveExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewAdditiveExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IAdditiveExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 48
	p.EnterRecursionRule(localctx, 48, XPath3ParserRULE_additiveExpr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(370)
		p.multiplicativeExpr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(377)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewAdditiveExprContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, XPath3ParserRULE_additiveExpr)
			p.SetState(372)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(373)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*AdditiveExprContext).additiveOp = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == XPath3ParserT__21 || _la == XPath3ParserT__22) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*AdditiveExprContext).additiveOp = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(374)
				p.multiplicativeExpr(0)
			}

		}
		p.SetState(379)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiplicativeExprContext is an interface to support dynamic dispatch.
type IMultiplicativeExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMultiplicativeOp returns the multiplicativeOp token.
	GetMultiplicativeOp() antlr.Token

	// SetMultiplicativeOp sets the multiplicativeOp token.
	SetMultiplicativeOp(antlr.Token)

	// Getter signatures
	UnionExpr() IUnionExprContext
	MultiplicativeExpr() IMultiplicativeExprContext

	// IsMultiplicativeExprContext differentiates from other interfaces.
	IsMultiplicativeExprContext()
}

type MultiplicativeExprContext struct {
	antlr.BaseParserRuleContext
	parser           antlr.Parser
	multiplicativeOp antlr.Token
}

func NewEmptyMultiplicativeExprContext() *MultiplicativeExprContext {
	var p = new(MultiplicativeExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_multiplicativeExpr
	return p
}

func InitEmptyMultiplicativeExprContext(p *MultiplicativeExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_multiplicativeExpr
}

func (*MultiplicativeExprContext) IsMultiplicativeExprContext() {}

func NewMultiplicativeExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplicativeExprContext {
	var p = new(MultiplicativeExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_multiplicativeExpr

	return p
}

func (s *MultiplicativeExprContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplicativeExprContext) GetMultiplicativeOp() antlr.Token { return s.multiplicativeOp }

func (s *MultiplicativeExprContext) SetMultiplicativeOp(v antlr.Token) { s.multiplicativeOp = v }

func (s *MultiplicativeExprContext) UnionExpr() IUnionExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnionExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnionExprContext)
}

func (s *MultiplicativeExprContext) MultiplicativeExpr() IMultiplicativeExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiplicativeExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiplicativeExprContext)
}

func (s *MultiplicativeExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplicativeExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplicativeExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterMultiplicativeExpr(s)
	}
}

func (s *MultiplicativeExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitMultiplicativeExpr(s)
	}
}

func (p *XPath3Parser) MultiplicativeExpr() (localctx IMultiplicativeExprContext) {
	return p.multiplicativeExpr(0)
}

func (p *XPath3Parser) multiplicativeExpr(_p int) (localctx IMultiplicativeExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewMultiplicativeExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IMultiplicativeExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 50
	p.EnterRecursionRule(localctx, 50, XPath3ParserRULE_multiplicativeExpr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(381)
		p.unionExpr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(388)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 14, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewMultiplicativeExprContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, XPath3ParserRULE_multiplicativeExpr)
			p.SetState(383)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(384)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*MultiplicativeExprContext).multiplicativeOp = _lt

				_la = p.GetTokenStream().LA(1)

				if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&251658240) != 0) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*MultiplicativeExprContext).multiplicativeOp = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(385)
				p.unionExpr(0)
			}

		}
		p.SetState(390)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 14, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnionExprContext is an interface to support dynamic dispatch.
type IUnionExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetUnionOp returns the unionOp token.
	GetUnionOp() antlr.Token

	// SetUnionOp sets the unionOp token.
	SetUnionOp(antlr.Token)

	// Getter signatures
	IntersectExceptExpr() IIntersectExceptExprContext
	UnionExpr() IUnionExprContext

	// IsUnionExprContext differentiates from other interfaces.
	IsUnionExprContext()
}

type UnionExprContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	unionOp antlr.Token
}

func NewEmptyUnionExprContext() *UnionExprContext {
	var p = new(UnionExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_unionExpr
	return p
}

func InitEmptyUnionExprContext(p *UnionExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_unionExpr
}

func (*UnionExprContext) IsUnionExprContext() {}

func NewUnionExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionExprContext {
	var p = new(UnionExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_unionExpr

	return p
}

func (s *UnionExprContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionExprContext) GetUnionOp() antlr.Token { return s.unionOp }

func (s *UnionExprContext) SetUnionOp(v antlr.Token) { s.unionOp = v }

func (s *UnionExprContext) IntersectExceptExpr() IIntersectExceptExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntersectExceptExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntersectExceptExprContext)
}

func (s *UnionExprContext) UnionExpr() IUnionExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnionExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnionExprContext)
}

func (s *UnionExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnionExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterUnionExpr(s)
	}
}

func (s *UnionExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitUnionExpr(s)
	}
}

func (p *XPath3Parser) UnionExpr() (localctx IUnionExprContext) {
	return p.unionExpr(0)
}

func (p *XPath3Parser) unionExpr(_p int) (localctx IUnionExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewUnionExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IUnionExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 52
	p.EnterRecursionRule(localctx, 52, XPath3ParserRULE_unionExpr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(392)
		p.intersectExceptExpr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(399)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 15, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewUnionExprContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, XPath3ParserRULE_unionExpr)
			p.SetState(394)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(395)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*UnionExprContext).unionOp = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == XPath3ParserT__27 || _la == XPath3ParserT__28) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*UnionExprContext).unionOp = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(396)
				p.intersectExceptExpr(0)
			}

		}
		p.SetState(401)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 15, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntersectExceptExprContext is an interface to support dynamic dispatch.
type IIntersectExceptExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIntersectExceptOp returns the intersectExceptOp token.
	GetIntersectExceptOp() antlr.Token

	// SetIntersectExceptOp sets the intersectExceptOp token.
	SetIntersectExceptOp(antlr.Token)

	// Getter signatures
	InstanceofExpr() IInstanceofExprContext
	IntersectExceptExpr() IIntersectExceptExprContext

	// IsIntersectExceptExprContext differentiates from other interfaces.
	IsIntersectExceptExprContext()
}

type IntersectExceptExprContext struct {
	antlr.BaseParserRuleContext
	parser            antlr.Parser
	intersectExceptOp antlr.Token
}

func NewEmptyIntersectExceptExprContext() *IntersectExceptExprContext {
	var p = new(IntersectExceptExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_intersectExceptExpr
	return p
}

func InitEmptyIntersectExceptExprContext(p *IntersectExceptExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_intersectExceptExpr
}

func (*IntersectExceptExprContext) IsIntersectExceptExprContext() {}

func NewIntersectExceptExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntersectExceptExprContext {
	var p = new(IntersectExceptExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_intersectExceptExpr

	return p
}

func (s *IntersectExceptExprContext) GetParser() antlr.Parser { return s.parser }

func (s *IntersectExceptExprContext) GetIntersectExceptOp() antlr.Token { return s.intersectExceptOp }

func (s *IntersectExceptExprContext) SetIntersectExceptOp(v antlr.Token) { s.intersectExceptOp = v }

func (s *IntersectExceptExprContext) InstanceofExpr() IInstanceofExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInstanceofExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInstanceofExprContext)
}

func (s *IntersectExceptExprContext) IntersectExceptExpr() IIntersectExceptExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntersectExceptExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntersectExceptExprContext)
}

func (s *IntersectExceptExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntersectExceptExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntersectExceptExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterIntersectExceptExpr(s)
	}
}

func (s *IntersectExceptExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitIntersectExceptExpr(s)
	}
}

func (p *XPath3Parser) IntersectExceptExpr() (localctx IIntersectExceptExprContext) {
	return p.intersectExceptExpr(0)
}

func (p *XPath3Parser) intersectExceptExpr(_p int) (localctx IIntersectExceptExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewIntersectExceptExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IIntersectExceptExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 54
	p.EnterRecursionRule(localctx, 54, XPath3ParserRULE_intersectExceptExpr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(403)
		p.InstanceofExpr()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(410)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 16, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewIntersectExceptExprContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, XPath3ParserRULE_intersectExceptExpr)
			p.SetState(405)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(406)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*IntersectExceptExprContext).intersectExceptOp = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == XPath3ParserT__29 || _la == XPath3ParserT__30) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*IntersectExceptExprContext).intersectExceptOp = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(407)
				p.InstanceofExpr()
			}

		}
		p.SetState(412)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 16, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInstanceofExprContext is an interface to support dynamic dispatch.
type IInstanceofExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TreatExpr() ITreatExprContext
	SequenceType() ISequenceTypeContext

	// IsInstanceofExprContext differentiates from other interfaces.
	IsInstanceofExprContext()
}

type InstanceofExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInstanceofExprContext() *InstanceofExprContext {
	var p = new(InstanceofExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_instanceofExpr
	return p
}

func InitEmptyInstanceofExprContext(p *InstanceofExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_instanceofExpr
}

func (*InstanceofExprContext) IsInstanceofExprContext() {}

func NewInstanceofExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InstanceofExprContext {
	var p = new(InstanceofExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_instanceofExpr

	return p
}

func (s *InstanceofExprContext) GetParser() antlr.Parser { return s.parser }

func (s *InstanceofExprContext) TreatExpr() ITreatExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITreatExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITreatExprContext)
}

func (s *InstanceofExprContext) SequenceType() ISequenceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISequenceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISequenceTypeContext)
}

func (s *InstanceofExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstanceofExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InstanceofExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterInstanceofExpr(s)
	}
}

func (s *InstanceofExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitInstanceofExpr(s)
	}
}

func (p *XPath3Parser) InstanceofExpr() (localctx IInstanceofExprContext) {
	localctx = NewInstanceofExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, XPath3ParserRULE_instanceofExpr)
	p.SetState(419)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(413)
			p.TreatExpr()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(414)
			p.TreatExpr()
		}
		{
			p.SetState(415)
			p.Match(XPath3ParserT__31)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(416)
			p.Match(XPath3ParserT__32)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(417)
			p.SequenceType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITreatExprContext is an interface to support dynamic dispatch.
type ITreatExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CastableExpr() ICastableExprContext
	SequenceType() ISequenceTypeContext

	// IsTreatExprContext differentiates from other interfaces.
	IsTreatExprContext()
}

type TreatExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTreatExprContext() *TreatExprContext {
	var p = new(TreatExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_treatExpr
	return p
}

func InitEmptyTreatExprContext(p *TreatExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_treatExpr
}

func (*TreatExprContext) IsTreatExprContext() {}

func NewTreatExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TreatExprContext {
	var p = new(TreatExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_treatExpr

	return p
}

func (s *TreatExprContext) GetParser() antlr.Parser { return s.parser }

func (s *TreatExprContext) CastableExpr() ICastableExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastableExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastableExprContext)
}

func (s *TreatExprContext) SequenceType() ISequenceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISequenceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISequenceTypeContext)
}

func (s *TreatExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TreatExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TreatExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterTreatExpr(s)
	}
}

func (s *TreatExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitTreatExpr(s)
	}
}

func (p *XPath3Parser) TreatExpr() (localctx ITreatExprContext) {
	localctx = NewTreatExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, XPath3ParserRULE_treatExpr)
	p.SetState(427)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 18, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(421)
			p.CastableExpr()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(422)
			p.CastableExpr()
		}
		{
			p.SetState(423)
			p.Match(XPath3ParserT__33)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(424)
			p.Match(XPath3ParserT__34)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(425)
			p.SequenceType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICastableExprContext is an interface to support dynamic dispatch.
type ICastableExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CastExpr() ICastExprContext
	SingleType() ISingleTypeContext

	// IsCastableExprContext differentiates from other interfaces.
	IsCastableExprContext()
}

type CastableExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCastableExprContext() *CastableExprContext {
	var p = new(CastableExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_castableExpr
	return p
}

func InitEmptyCastableExprContext(p *CastableExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_castableExpr
}

func (*CastableExprContext) IsCastableExprContext() {}

func NewCastableExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CastableExprContext {
	var p = new(CastableExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_castableExpr

	return p
}

func (s *CastableExprContext) GetParser() antlr.Parser { return s.parser }

func (s *CastableExprContext) CastExpr() ICastExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastExprContext)
}

func (s *CastableExprContext) SingleType() ISingleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleTypeContext)
}

func (s *CastableExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastableExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CastableExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterCastableExpr(s)
	}
}

func (s *CastableExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitCastableExpr(s)
	}
}

func (p *XPath3Parser) CastableExpr() (localctx ICastableExprContext) {
	localctx = NewCastableExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, XPath3ParserRULE_castableExpr)
	p.SetState(435)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 19, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(429)
			p.CastExpr()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(430)
			p.CastExpr()
		}
		{
			p.SetState(431)
			p.Match(XPath3ParserT__35)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(432)
			p.Match(XPath3ParserT__34)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(433)
			p.SingleType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICastExprContext is an interface to support dynamic dispatch.
type ICastExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnaryExpr() IUnaryExprContext
	SingleType() ISingleTypeContext

	// IsCastExprContext differentiates from other interfaces.
	IsCastExprContext()
}

type CastExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCastExprContext() *CastExprContext {
	var p = new(CastExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_castExpr
	return p
}

func InitEmptyCastExprContext(p *CastExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_castExpr
}

func (*CastExprContext) IsCastExprContext() {}

func NewCastExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CastExprContext {
	var p = new(CastExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_castExpr

	return p
}

func (s *CastExprContext) GetParser() antlr.Parser { return s.parser }

func (s *CastExprContext) UnaryExpr() IUnaryExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryExprContext)
}

func (s *CastExprContext) SingleType() ISingleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleTypeContext)
}

func (s *CastExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CastExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterCastExpr(s)
	}
}

func (s *CastExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitCastExpr(s)
	}
}

func (p *XPath3Parser) CastExpr() (localctx ICastExprContext) {
	localctx = NewCastExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, XPath3ParserRULE_castExpr)
	p.SetState(443)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 20, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(437)
			p.UnaryExpr()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(438)
			p.UnaryExpr()
		}
		{
			p.SetState(439)
			p.Match(XPath3ParserT__36)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(440)
			p.Match(XPath3ParserT__34)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(441)
			p.SingleType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnaryExprContext is an interface to support dynamic dispatch.
type IUnaryExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ValueExpr() IValueExprContext
	UnaryExpr() IUnaryExprContext

	// IsUnaryExprContext differentiates from other interfaces.
	IsUnaryExprContext()
}

type UnaryExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnaryExprContext() *UnaryExprContext {
	var p = new(UnaryExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_unaryExpr
	return p
}

func InitEmptyUnaryExprContext(p *UnaryExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_unaryExpr
}

func (*UnaryExprContext) IsUnaryExprContext() {}

func NewUnaryExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryExprContext {
	var p = new(UnaryExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_unaryExpr

	return p
}

func (s *UnaryExprContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryExprContext) ValueExpr() IValueExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExprContext)
}

func (s *UnaryExprContext) UnaryExpr() IUnaryExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryExprContext)
}

func (s *UnaryExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnaryExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterUnaryExpr(s)
	}
}

func (s *UnaryExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitUnaryExpr(s)
	}
}

func (p *XPath3Parser) UnaryExpr() (localctx IUnaryExprContext) {
	localctx = NewUnaryExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, XPath3ParserRULE_unaryExpr)
	p.SetState(450)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserT__1, XPath3ParserT__13, XPath3ParserT__23, XPath3ParserT__53, XPath3ParserT__54, XPath3ParserT__55, XPath3ParserT__57, XPath3ParserT__58, XPath3ParserT__59, XPath3ParserT__60, XPath3ParserT__61, XPath3ParserT__62, XPath3ParserT__63, XPath3ParserT__64, XPath3ParserT__65, XPath3ParserT__66, XPath3ParserT__67, XPath3ParserT__68, XPath3ParserT__69, XPath3ParserT__70, XPath3ParserT__74, XPath3ParserT__77, XPath3ParserT__80, XPath3ParserT__81, XPath3ParserT__82, XPath3ParserT__83, XPath3ParserT__84, XPath3ParserT__85, XPath3ParserT__86, XPath3ParserT__87, XPath3ParserT__88, XPath3ParserT__89, XPath3ParserT__90, XPath3ParserNumericLiteral, XPath3ParserURIQualifiedName, XPath3ParserBracedURILiteral, XPath3ParserQNAME, XPath3ParserNC_NAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(445)
			p.ValueExpr()
		}

	case XPath3ParserT__22:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(446)
			p.Match(XPath3ParserT__22)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(447)
			p.UnaryExpr()
		}

	case XPath3ParserT__21:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(448)
			p.Match(XPath3ParserT__21)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(449)
			p.UnaryExpr()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValueExprContext is an interface to support dynamic dispatch.
type IValueExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleMapExpr() ISimpleMapExprContext

	// IsValueExprContext differentiates from other interfaces.
	IsValueExprContext()
}

type ValueExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueExprContext() *ValueExprContext {
	var p = new(ValueExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_valueExpr
	return p
}

func InitEmptyValueExprContext(p *ValueExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_valueExpr
}

func (*ValueExprContext) IsValueExprContext() {}

func NewValueExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueExprContext {
	var p = new(ValueExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_valueExpr

	return p
}

func (s *ValueExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueExprContext) SimpleMapExpr() ISimpleMapExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleMapExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleMapExprContext)
}

func (s *ValueExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterValueExpr(s)
	}
}

func (s *ValueExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitValueExpr(s)
	}
}

func (p *XPath3Parser) ValueExpr() (localctx IValueExprContext) {
	localctx = NewValueExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, XPath3ParserRULE_valueExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(452)
		p.simpleMapExpr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGeneralCompContext is an interface to support dynamic dispatch.
type IGeneralCompContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsGeneralCompContext differentiates from other interfaces.
	IsGeneralCompContext()
}

type GeneralCompContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneralCompContext() *GeneralCompContext {
	var p = new(GeneralCompContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_generalComp
	return p
}

func InitEmptyGeneralCompContext(p *GeneralCompContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_generalComp
}

func (*GeneralCompContext) IsGeneralCompContext() {}

func NewGeneralCompContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GeneralCompContext {
	var p = new(GeneralCompContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_generalComp

	return p
}

func (s *GeneralCompContext) GetParser() antlr.Parser { return s.parser }
func (s *GeneralCompContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneralCompContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GeneralCompContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterGeneralComp(s)
	}
}

func (s *GeneralCompContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitGeneralComp(s)
	}
}

func (p *XPath3Parser) GeneralComp() (localctx IGeneralCompContext) {
	localctx = NewGeneralCompContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, XPath3ParserRULE_generalComp)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(454)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&17317308137472) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValueCompContext is an interface to support dynamic dispatch.
type IValueCompContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsValueCompContext differentiates from other interfaces.
	IsValueCompContext()
}

type ValueCompContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueCompContext() *ValueCompContext {
	var p = new(ValueCompContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_valueComp
	return p
}

func InitEmptyValueCompContext(p *ValueCompContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_valueComp
}

func (*ValueCompContext) IsValueCompContext() {}

func NewValueCompContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueCompContext {
	var p = new(ValueCompContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_valueComp

	return p
}

func (s *ValueCompContext) GetParser() antlr.Parser { return s.parser }
func (s *ValueCompContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueCompContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueCompContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterValueComp(s)
	}
}

func (s *ValueCompContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitValueComp(s)
	}
}

func (p *XPath3Parser) ValueComp() (localctx IValueCompContext) {
	localctx = NewValueCompContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, XPath3ParserRULE_valueComp)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(456)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1108307720798208) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INodeCompContext is an interface to support dynamic dispatch.
type INodeCompContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsNodeCompContext differentiates from other interfaces.
	IsNodeCompContext()
}

type NodeCompContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNodeCompContext() *NodeCompContext {
	var p = new(NodeCompContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_nodeComp
	return p
}

func InitEmptyNodeCompContext(p *NodeCompContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_nodeComp
}

func (*NodeCompContext) IsNodeCompContext() {}

func NewNodeCompContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NodeCompContext {
	var p = new(NodeCompContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_nodeComp

	return p
}

func (s *NodeCompContext) GetParser() antlr.Parser { return s.parser }
func (s *NodeCompContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NodeCompContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NodeCompContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterNodeComp(s)
	}
}

func (s *NodeCompContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitNodeComp(s)
	}
}

func (p *XPath3Parser) NodeComp() (localctx INodeCompContext) {
	localctx = NewNodeCompContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, XPath3ParserRULE_nodeComp)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(458)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&7881299347898368) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleMapExprContext is an interface to support dynamic dispatch.
type ISimpleMapExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSimpleMapOp returns the simpleMapOp token.
	GetSimpleMapOp() antlr.Token

	// SetSimpleMapOp sets the simpleMapOp token.
	SetSimpleMapOp(antlr.Token)

	// Getter signatures
	PathExpr() IPathExprContext
	SimpleMapExpr() ISimpleMapExprContext

	// IsSimpleMapExprContext differentiates from other interfaces.
	IsSimpleMapExprContext()
}

type SimpleMapExprContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	simpleMapOp antlr.Token
}

func NewEmptySimpleMapExprContext() *SimpleMapExprContext {
	var p = new(SimpleMapExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_simpleMapExpr
	return p
}

func InitEmptySimpleMapExprContext(p *SimpleMapExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_simpleMapExpr
}

func (*SimpleMapExprContext) IsSimpleMapExprContext() {}

func NewSimpleMapExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleMapExprContext {
	var p = new(SimpleMapExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_simpleMapExpr

	return p
}

func (s *SimpleMapExprContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleMapExprContext) GetSimpleMapOp() antlr.Token { return s.simpleMapOp }

func (s *SimpleMapExprContext) SetSimpleMapOp(v antlr.Token) { s.simpleMapOp = v }

func (s *SimpleMapExprContext) PathExpr() IPathExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathExprContext)
}

func (s *SimpleMapExprContext) SimpleMapExpr() ISimpleMapExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleMapExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleMapExprContext)
}

func (s *SimpleMapExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleMapExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleMapExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterSimpleMapExpr(s)
	}
}

func (s *SimpleMapExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitSimpleMapExpr(s)
	}
}

func (p *XPath3Parser) SimpleMapExpr() (localctx ISimpleMapExprContext) {
	return p.simpleMapExpr(0)
}

func (p *XPath3Parser) simpleMapExpr(_p int) (localctx ISimpleMapExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewSimpleMapExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ISimpleMapExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 74
	p.EnterRecursionRule(localctx, 74, XPath3ParserRULE_simpleMapExpr, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(461)
		p.PathExpr()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(468)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 22, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewSimpleMapExprContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, XPath3ParserRULE_simpleMapExpr)
			p.SetState(463)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(464)

				var _m = p.Match(XPath3ParserT__52)

				localctx.(*SimpleMapExprContext).simpleMapOp = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(465)
				p.PathExpr()
			}

		}
		p.SetState(470)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 22, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPathExprContext is an interface to support dynamic dispatch.
type IPathExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAbbvStep returns the abbvStep token.
	GetAbbvStep() antlr.Token

	// SetAbbvStep sets the abbvStep token.
	SetAbbvStep(antlr.Token)

	// Getter signatures
	RelativePathExpr() IRelativePathExprContext

	// IsPathExprContext differentiates from other interfaces.
	IsPathExprContext()
}

type PathExprContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	abbvStep antlr.Token
}

func NewEmptyPathExprContext() *PathExprContext {
	var p = new(PathExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_pathExpr
	return p
}

func InitEmptyPathExprContext(p *PathExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_pathExpr
}

func (*PathExprContext) IsPathExprContext() {}

func NewPathExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PathExprContext {
	var p = new(PathExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_pathExpr

	return p
}

func (s *PathExprContext) GetParser() antlr.Parser { return s.parser }

func (s *PathExprContext) GetAbbvStep() antlr.Token { return s.abbvStep }

func (s *PathExprContext) SetAbbvStep(v antlr.Token) { s.abbvStep = v }

func (s *PathExprContext) RelativePathExpr() IRelativePathExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelativePathExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelativePathExprContext)
}

func (s *PathExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PathExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PathExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterPathExpr(s)
	}
}

func (s *PathExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitPathExpr(s)
	}
}

func (p *XPath3Parser) PathExpr() (localctx IPathExprContext) {
	localctx = NewPathExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, XPath3ParserRULE_pathExpr)
	p.SetState(478)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserT__53:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(471)

			var _m = p.Match(XPath3ParserT__53)

			localctx.(*PathExprContext).abbvStep = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(473)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 23, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(472)
				p.relativePathExpr(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case XPath3ParserT__54:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(475)

			var _m = p.Match(XPath3ParserT__54)

			localctx.(*PathExprContext).abbvStep = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(476)
			p.relativePathExpr(0)
		}

	case XPath3ParserT__1, XPath3ParserT__13, XPath3ParserT__23, XPath3ParserT__55, XPath3ParserT__57, XPath3ParserT__58, XPath3ParserT__59, XPath3ParserT__60, XPath3ParserT__61, XPath3ParserT__62, XPath3ParserT__63, XPath3ParserT__64, XPath3ParserT__65, XPath3ParserT__66, XPath3ParserT__67, XPath3ParserT__68, XPath3ParserT__69, XPath3ParserT__70, XPath3ParserT__74, XPath3ParserT__77, XPath3ParserT__80, XPath3ParserT__81, XPath3ParserT__82, XPath3ParserT__83, XPath3ParserT__84, XPath3ParserT__85, XPath3ParserT__86, XPath3ParserT__87, XPath3ParserT__88, XPath3ParserT__89, XPath3ParserT__90, XPath3ParserNumericLiteral, XPath3ParserURIQualifiedName, XPath3ParserBracedURILiteral, XPath3ParserQNAME, XPath3ParserNC_NAME:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(477)
			p.relativePathExpr(0)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelativePathExprContext is an interface to support dynamic dispatch.
type IRelativePathExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetStepOp returns the stepOp token.
	GetStepOp() antlr.Token

	// SetStepOp sets the stepOp token.
	SetStepOp(antlr.Token)

	// Getter signatures
	StepExpr() IStepExprContext
	RelativePathExpr() IRelativePathExprContext

	// IsRelativePathExprContext differentiates from other interfaces.
	IsRelativePathExprContext()
}

type RelativePathExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	stepOp antlr.Token
}

func NewEmptyRelativePathExprContext() *RelativePathExprContext {
	var p = new(RelativePathExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_relativePathExpr
	return p
}

func InitEmptyRelativePathExprContext(p *RelativePathExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_relativePathExpr
}

func (*RelativePathExprContext) IsRelativePathExprContext() {}

func NewRelativePathExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelativePathExprContext {
	var p = new(RelativePathExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_relativePathExpr

	return p
}

func (s *RelativePathExprContext) GetParser() antlr.Parser { return s.parser }

func (s *RelativePathExprContext) GetStepOp() antlr.Token { return s.stepOp }

func (s *RelativePathExprContext) SetStepOp(v antlr.Token) { s.stepOp = v }

func (s *RelativePathExprContext) StepExpr() IStepExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStepExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStepExprContext)
}

func (s *RelativePathExprContext) RelativePathExpr() IRelativePathExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelativePathExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelativePathExprContext)
}

func (s *RelativePathExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelativePathExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelativePathExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterRelativePathExpr(s)
	}
}

func (s *RelativePathExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitRelativePathExpr(s)
	}
}

func (p *XPath3Parser) RelativePathExpr() (localctx IRelativePathExprContext) {
	return p.relativePathExpr(0)
}

func (p *XPath3Parser) relativePathExpr(_p int) (localctx IRelativePathExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewRelativePathExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRelativePathExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 78
	p.EnterRecursionRule(localctx, 78, XPath3ParserRULE_relativePathExpr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(481)
		p.StepExpr()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(488)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewRelativePathExprContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, XPath3ParserRULE_relativePathExpr)
			p.SetState(483)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(484)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*RelativePathExprContext).stepOp = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == XPath3ParserT__53 || _la == XPath3ParserT__54) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*RelativePathExprContext).stepOp = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(485)
				p.StepExpr()
			}

		}
		p.SetState(490)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStepExprContext is an interface to support dynamic dispatch.
type IStepExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PostfixExpr() IPostfixExprContext
	AxisStep() IAxisStepContext

	// IsStepExprContext differentiates from other interfaces.
	IsStepExprContext()
}

type StepExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStepExprContext() *StepExprContext {
	var p = new(StepExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_stepExpr
	return p
}

func InitEmptyStepExprContext(p *StepExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_stepExpr
}

func (*StepExprContext) IsStepExprContext() {}

func NewStepExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StepExprContext {
	var p = new(StepExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_stepExpr

	return p
}

func (s *StepExprContext) GetParser() antlr.Parser { return s.parser }

func (s *StepExprContext) PostfixExpr() IPostfixExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixExprContext)
}

func (s *StepExprContext) AxisStep() IAxisStepContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAxisStepContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAxisStepContext)
}

func (s *StepExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StepExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StepExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterStepExpr(s)
	}
}

func (s *StepExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitStepExpr(s)
	}
}

func (p *XPath3Parser) StepExpr() (localctx IStepExprContext) {
	localctx = NewStepExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, XPath3ParserRULE_stepExpr)
	p.SetState(493)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 26, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(491)
			p.postfixExpr(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(492)
			p.AxisStep()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAxisStepContext is an interface to support dynamic dispatch.
type IAxisStepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PredicateList() IPredicateListContext
	ReverseStep() IReverseStepContext
	ForwardStep() IForwardStepContext

	// IsAxisStepContext differentiates from other interfaces.
	IsAxisStepContext()
}

type AxisStepContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAxisStepContext() *AxisStepContext {
	var p = new(AxisStepContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_axisStep
	return p
}

func InitEmptyAxisStepContext(p *AxisStepContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_axisStep
}

func (*AxisStepContext) IsAxisStepContext() {}

func NewAxisStepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AxisStepContext {
	var p = new(AxisStepContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_axisStep

	return p
}

func (s *AxisStepContext) GetParser() antlr.Parser { return s.parser }

func (s *AxisStepContext) PredicateList() IPredicateListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateListContext)
}

func (s *AxisStepContext) ReverseStep() IReverseStepContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReverseStepContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReverseStepContext)
}

func (s *AxisStepContext) ForwardStep() IForwardStepContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForwardStepContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForwardStepContext)
}

func (s *AxisStepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AxisStepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AxisStepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterAxisStep(s)
	}
}

func (s *AxisStepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitAxisStep(s)
	}
}

func (p *XPath3Parser) AxisStep() (localctx IAxisStepContext) {
	localctx = NewAxisStepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, XPath3ParserRULE_axisStep)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(497)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserT__65, XPath3ParserT__66, XPath3ParserT__67, XPath3ParserT__68, XPath3ParserT__69, XPath3ParserT__70:
		{
			p.SetState(495)
			p.ReverseStep()
		}

	case XPath3ParserT__23, XPath3ParserT__55, XPath3ParserT__57, XPath3ParserT__58, XPath3ParserT__59, XPath3ParserT__60, XPath3ParserT__61, XPath3ParserT__62, XPath3ParserT__63, XPath3ParserT__64, XPath3ParserT__80, XPath3ParserT__81, XPath3ParserT__82, XPath3ParserT__83, XPath3ParserT__84, XPath3ParserT__85, XPath3ParserT__86, XPath3ParserT__87, XPath3ParserT__88, XPath3ParserURIQualifiedName, XPath3ParserBracedURILiteral, XPath3ParserQNAME, XPath3ParserNC_NAME:
		{
			p.SetState(496)
			p.ForwardStep()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(499)
		p.PredicateList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForwardStepContext is an interface to support dynamic dispatch.
type IForwardStepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ForwardAxis() IForwardAxisContext
	NodeTest() INodeTestContext
	AbbrevForwardStep() IAbbrevForwardStepContext

	// IsForwardStepContext differentiates from other interfaces.
	IsForwardStepContext()
}

type ForwardStepContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForwardStepContext() *ForwardStepContext {
	var p = new(ForwardStepContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_forwardStep
	return p
}

func InitEmptyForwardStepContext(p *ForwardStepContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_forwardStep
}

func (*ForwardStepContext) IsForwardStepContext() {}

func NewForwardStepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForwardStepContext {
	var p = new(ForwardStepContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_forwardStep

	return p
}

func (s *ForwardStepContext) GetParser() antlr.Parser { return s.parser }

func (s *ForwardStepContext) ForwardAxis() IForwardAxisContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForwardAxisContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForwardAxisContext)
}

func (s *ForwardStepContext) NodeTest() INodeTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeTestContext)
}

func (s *ForwardStepContext) AbbrevForwardStep() IAbbrevForwardStepContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAbbrevForwardStepContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAbbrevForwardStepContext)
}

func (s *ForwardStepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForwardStepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForwardStepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterForwardStep(s)
	}
}

func (s *ForwardStepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitForwardStep(s)
	}
}

func (p *XPath3Parser) ForwardStep() (localctx IForwardStepContext) {
	localctx = NewForwardStepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, XPath3ParserRULE_forwardStep)
	p.SetState(505)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 28, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(501)
			p.ForwardAxis()
		}
		{
			p.SetState(502)
			p.NodeTest()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(504)
			p.AbbrevForwardStep()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForwardAxisContext is an interface to support dynamic dispatch.
type IForwardAxisContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsForwardAxisContext differentiates from other interfaces.
	IsForwardAxisContext()
}

type ForwardAxisContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForwardAxisContext() *ForwardAxisContext {
	var p = new(ForwardAxisContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_forwardAxis
	return p
}

func InitEmptyForwardAxisContext(p *ForwardAxisContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_forwardAxis
}

func (*ForwardAxisContext) IsForwardAxisContext() {}

func NewForwardAxisContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForwardAxisContext {
	var p = new(ForwardAxisContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_forwardAxis

	return p
}

func (s *ForwardAxisContext) GetParser() antlr.Parser { return s.parser }
func (s *ForwardAxisContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForwardAxisContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForwardAxisContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterForwardAxis(s)
	}
}

func (s *ForwardAxisContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitForwardAxis(s)
	}
}

func (p *XPath3Parser) ForwardAxis() (localctx IForwardAxisContext) {
	localctx = NewForwardAxisContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, XPath3ParserRULE_forwardAxis)
	p.SetState(523)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserT__55:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(507)
			p.Match(XPath3ParserT__55)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(508)
			p.Match(XPath3ParserT__56)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case XPath3ParserT__57:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(509)
			p.Match(XPath3ParserT__57)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(510)
			p.Match(XPath3ParserT__56)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case XPath3ParserT__58:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(511)
			p.Match(XPath3ParserT__58)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(512)
			p.Match(XPath3ParserT__56)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case XPath3ParserT__59:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(513)
			p.Match(XPath3ParserT__59)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(514)
			p.Match(XPath3ParserT__56)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case XPath3ParserT__60:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(515)
			p.Match(XPath3ParserT__60)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(516)
			p.Match(XPath3ParserT__56)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case XPath3ParserT__61:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(517)
			p.Match(XPath3ParserT__61)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(518)
			p.Match(XPath3ParserT__56)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case XPath3ParserT__62:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(519)
			p.Match(XPath3ParserT__62)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(520)
			p.Match(XPath3ParserT__56)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case XPath3ParserT__63:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(521)
			p.Match(XPath3ParserT__63)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(522)
			p.Match(XPath3ParserT__56)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAbbrevForwardStepContext is an interface to support dynamic dispatch.
type IAbbrevForwardStepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAbbvOp returns the abbvOp token.
	GetAbbvOp() antlr.Token

	// SetAbbvOp sets the abbvOp token.
	SetAbbvOp(antlr.Token)

	// Getter signatures
	NodeTest() INodeTestContext

	// IsAbbrevForwardStepContext differentiates from other interfaces.
	IsAbbrevForwardStepContext()
}

type AbbrevForwardStepContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	abbvOp antlr.Token
}

func NewEmptyAbbrevForwardStepContext() *AbbrevForwardStepContext {
	var p = new(AbbrevForwardStepContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_abbrevForwardStep
	return p
}

func InitEmptyAbbrevForwardStepContext(p *AbbrevForwardStepContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_abbrevForwardStep
}

func (*AbbrevForwardStepContext) IsAbbrevForwardStepContext() {}

func NewAbbrevForwardStepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AbbrevForwardStepContext {
	var p = new(AbbrevForwardStepContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_abbrevForwardStep

	return p
}

func (s *AbbrevForwardStepContext) GetParser() antlr.Parser { return s.parser }

func (s *AbbrevForwardStepContext) GetAbbvOp() antlr.Token { return s.abbvOp }

func (s *AbbrevForwardStepContext) SetAbbvOp(v antlr.Token) { s.abbvOp = v }

func (s *AbbrevForwardStepContext) NodeTest() INodeTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeTestContext)
}

func (s *AbbrevForwardStepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AbbrevForwardStepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AbbrevForwardStepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterAbbrevForwardStep(s)
	}
}

func (s *AbbrevForwardStepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitAbbrevForwardStep(s)
	}
}

func (p *XPath3Parser) AbbrevForwardStep() (localctx IAbbrevForwardStepContext) {
	localctx = NewAbbrevForwardStepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, XPath3ParserRULE_abbrevForwardStep)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(526)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == XPath3ParserT__64 {
		{
			p.SetState(525)

			var _m = p.Match(XPath3ParserT__64)

			localctx.(*AbbrevForwardStepContext).abbvOp = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(528)
		p.NodeTest()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReverseStepContext is an interface to support dynamic dispatch.
type IReverseStepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ReverseAxis() IReverseAxisContext
	NodeTest() INodeTestContext
	AbbrevReverseStep() IAbbrevReverseStepContext

	// IsReverseStepContext differentiates from other interfaces.
	IsReverseStepContext()
}

type ReverseStepContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReverseStepContext() *ReverseStepContext {
	var p = new(ReverseStepContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_reverseStep
	return p
}

func InitEmptyReverseStepContext(p *ReverseStepContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_reverseStep
}

func (*ReverseStepContext) IsReverseStepContext() {}

func NewReverseStepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReverseStepContext {
	var p = new(ReverseStepContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_reverseStep

	return p
}

func (s *ReverseStepContext) GetParser() antlr.Parser { return s.parser }

func (s *ReverseStepContext) ReverseAxis() IReverseAxisContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReverseAxisContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReverseAxisContext)
}

func (s *ReverseStepContext) NodeTest() INodeTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeTestContext)
}

func (s *ReverseStepContext) AbbrevReverseStep() IAbbrevReverseStepContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAbbrevReverseStepContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAbbrevReverseStepContext)
}

func (s *ReverseStepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReverseStepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReverseStepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterReverseStep(s)
	}
}

func (s *ReverseStepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitReverseStep(s)
	}
}

func (p *XPath3Parser) ReverseStep() (localctx IReverseStepContext) {
	localctx = NewReverseStepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, XPath3ParserRULE_reverseStep)
	p.SetState(534)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserT__65, XPath3ParserT__66, XPath3ParserT__67, XPath3ParserT__68, XPath3ParserT__69:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(530)
			p.ReverseAxis()
		}
		{
			p.SetState(531)
			p.NodeTest()
		}

	case XPath3ParserT__70:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(533)
			p.AbbrevReverseStep()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReverseAxisContext is an interface to support dynamic dispatch.
type IReverseAxisContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsReverseAxisContext differentiates from other interfaces.
	IsReverseAxisContext()
}

type ReverseAxisContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReverseAxisContext() *ReverseAxisContext {
	var p = new(ReverseAxisContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_reverseAxis
	return p
}

func InitEmptyReverseAxisContext(p *ReverseAxisContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_reverseAxis
}

func (*ReverseAxisContext) IsReverseAxisContext() {}

func NewReverseAxisContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReverseAxisContext {
	var p = new(ReverseAxisContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_reverseAxis

	return p
}

func (s *ReverseAxisContext) GetParser() antlr.Parser { return s.parser }
func (s *ReverseAxisContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReverseAxisContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReverseAxisContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterReverseAxis(s)
	}
}

func (s *ReverseAxisContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitReverseAxis(s)
	}
}

func (p *XPath3Parser) ReverseAxis() (localctx IReverseAxisContext) {
	localctx = NewReverseAxisContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, XPath3ParserRULE_reverseAxis)
	p.SetState(546)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserT__65:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(536)
			p.Match(XPath3ParserT__65)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(537)
			p.Match(XPath3ParserT__56)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case XPath3ParserT__66:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(538)
			p.Match(XPath3ParserT__66)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(539)
			p.Match(XPath3ParserT__56)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case XPath3ParserT__67:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(540)
			p.Match(XPath3ParserT__67)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(541)
			p.Match(XPath3ParserT__56)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case XPath3ParserT__68:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(542)
			p.Match(XPath3ParserT__68)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(543)
			p.Match(XPath3ParserT__56)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case XPath3ParserT__69:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(544)
			p.Match(XPath3ParserT__69)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(545)
			p.Match(XPath3ParserT__56)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAbbrevReverseStepContext is an interface to support dynamic dispatch.
type IAbbrevReverseStepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAbbrevReverseStepContext differentiates from other interfaces.
	IsAbbrevReverseStepContext()
}

type AbbrevReverseStepContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAbbrevReverseStepContext() *AbbrevReverseStepContext {
	var p = new(AbbrevReverseStepContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_abbrevReverseStep
	return p
}

func InitEmptyAbbrevReverseStepContext(p *AbbrevReverseStepContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_abbrevReverseStep
}

func (*AbbrevReverseStepContext) IsAbbrevReverseStepContext() {}

func NewAbbrevReverseStepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AbbrevReverseStepContext {
	var p = new(AbbrevReverseStepContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_abbrevReverseStep

	return p
}

func (s *AbbrevReverseStepContext) GetParser() antlr.Parser { return s.parser }
func (s *AbbrevReverseStepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AbbrevReverseStepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AbbrevReverseStepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterAbbrevReverseStep(s)
	}
}

func (s *AbbrevReverseStepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitAbbrevReverseStep(s)
	}
}

func (p *XPath3Parser) AbbrevReverseStep() (localctx IAbbrevReverseStepContext) {
	localctx = NewAbbrevReverseStepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, XPath3ParserRULE_abbrevReverseStep)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(548)
		p.Match(XPath3ParserT__70)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INodeTestContext is an interface to support dynamic dispatch.
type INodeTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KindTest() IKindTestContext
	NameTest() INameTestContext

	// IsNodeTestContext differentiates from other interfaces.
	IsNodeTestContext()
}

type NodeTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNodeTestContext() *NodeTestContext {
	var p = new(NodeTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_nodeTest
	return p
}

func InitEmptyNodeTestContext(p *NodeTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_nodeTest
}

func (*NodeTestContext) IsNodeTestContext() {}

func NewNodeTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NodeTestContext {
	var p = new(NodeTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_nodeTest

	return p
}

func (s *NodeTestContext) GetParser() antlr.Parser { return s.parser }

func (s *NodeTestContext) KindTest() IKindTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKindTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKindTestContext)
}

func (s *NodeTestContext) NameTest() INameTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameTestContext)
}

func (s *NodeTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NodeTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NodeTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterNodeTest(s)
	}
}

func (s *NodeTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitNodeTest(s)
	}
}

func (p *XPath3Parser) NodeTest() (localctx INodeTestContext) {
	localctx = NewNodeTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, XPath3ParserRULE_nodeTest)
	p.SetState(552)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserT__58, XPath3ParserT__80, XPath3ParserT__81, XPath3ParserT__82, XPath3ParserT__83, XPath3ParserT__84, XPath3ParserT__85, XPath3ParserT__86, XPath3ParserT__87, XPath3ParserT__88:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(550)
			p.KindTest()
		}

	case XPath3ParserT__23, XPath3ParserURIQualifiedName, XPath3ParserBracedURILiteral, XPath3ParserQNAME, XPath3ParserNC_NAME:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(551)
			p.NameTest()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INameTestContext is an interface to support dynamic dispatch.
type INameTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EqName() IEqNameContext
	WildCard() IWildCardContext

	// IsNameTestContext differentiates from other interfaces.
	IsNameTestContext()
}

type NameTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNameTestContext() *NameTestContext {
	var p = new(NameTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_nameTest
	return p
}

func InitEmptyNameTestContext(p *NameTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_nameTest
}

func (*NameTestContext) IsNameTestContext() {}

func NewNameTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NameTestContext {
	var p = new(NameTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_nameTest

	return p
}

func (s *NameTestContext) GetParser() antlr.Parser { return s.parser }

func (s *NameTestContext) EqName() IEqNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqNameContext)
}

func (s *NameTestContext) WildCard() IWildCardContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildCardContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildCardContext)
}

func (s *NameTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NameTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NameTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterNameTest(s)
	}
}

func (s *NameTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitNameTest(s)
	}
}

func (p *XPath3Parser) NameTest() (localctx INameTestContext) {
	localctx = NewNameTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, XPath3ParserRULE_nameTest)
	p.SetState(556)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserURIQualifiedName, XPath3ParserQNAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(554)
			p.EqName()
		}

	case XPath3ParserT__23, XPath3ParserBracedURILiteral, XPath3ParserNC_NAME:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(555)
			p.WildCard()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWildCardContext is an interface to support dynamic dispatch.
type IWildCardContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NC_NAME() antlr.TerminalNode
	BracedURILiteral() antlr.TerminalNode

	// IsWildCardContext differentiates from other interfaces.
	IsWildCardContext()
}

type WildCardContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWildCardContext() *WildCardContext {
	var p = new(WildCardContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_wildCard
	return p
}

func InitEmptyWildCardContext(p *WildCardContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_wildCard
}

func (*WildCardContext) IsWildCardContext() {}

func NewWildCardContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WildCardContext {
	var p = new(WildCardContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_wildCard

	return p
}

func (s *WildCardContext) GetParser() antlr.Parser { return s.parser }

func (s *WildCardContext) NC_NAME() antlr.TerminalNode {
	return s.GetToken(XPath3ParserNC_NAME, 0)
}

func (s *WildCardContext) BracedURILiteral() antlr.TerminalNode {
	return s.GetToken(XPath3ParserBracedURILiteral, 0)
}

func (s *WildCardContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WildCardContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WildCardContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterWildCard(s)
	}
}

func (s *WildCardContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitWildCard(s)
	}
}

func (p *XPath3Parser) WildCard() (localctx IWildCardContext) {
	localctx = NewWildCardContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, XPath3ParserRULE_wildCard)
	p.SetState(567)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 35, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(558)
			p.Match(XPath3ParserT__23)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(559)
			p.Match(XPath3ParserNC_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(560)
			p.Match(XPath3ParserT__71)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(561)
			p.Match(XPath3ParserT__23)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(562)
			p.Match(XPath3ParserT__23)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(563)
			p.Match(XPath3ParserT__71)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(564)
			p.Match(XPath3ParserNC_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(565)
			p.Match(XPath3ParserBracedURILiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(566)
			p.Match(XPath3ParserT__23)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPostfixExprContext is an interface to support dynamic dispatch.
type IPostfixExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrimaryExpr() IPrimaryExprContext
	PostfixExpr() IPostfixExprContext
	Predicate() IPredicateContext
	ArgumentList() IArgumentListContext

	// IsPostfixExprContext differentiates from other interfaces.
	IsPostfixExprContext()
}

type PostfixExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostfixExprContext() *PostfixExprContext {
	var p = new(PostfixExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_postfixExpr
	return p
}

func InitEmptyPostfixExprContext(p *PostfixExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_postfixExpr
}

func (*PostfixExprContext) IsPostfixExprContext() {}

func NewPostfixExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixExprContext {
	var p = new(PostfixExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_postfixExpr

	return p
}

func (s *PostfixExprContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixExprContext) PrimaryExpr() IPrimaryExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExprContext)
}

func (s *PostfixExprContext) PostfixExpr() IPostfixExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixExprContext)
}

func (s *PostfixExprContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *PostfixExprContext) ArgumentList() IArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *PostfixExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostfixExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterPostfixExpr(s)
	}
}

func (s *PostfixExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitPostfixExpr(s)
	}
}

func (p *XPath3Parser) PostfixExpr() (localctx IPostfixExprContext) {
	return p.postfixExpr(0)
}

func (p *XPath3Parser) postfixExpr(_p int) (localctx IPostfixExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewPostfixExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPostfixExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 102
	p.EnterRecursionRule(localctx, 102, XPath3ParserRULE_postfixExpr, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(570)
		p.PrimaryExpr()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(578)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 37, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(576)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 36, p.GetParserRuleContext()) {
			case 1:
				localctx = NewPostfixExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, XPath3ParserRULE_postfixExpr)
				p.SetState(572)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(573)
					p.Predicate()
				}

			case 2:
				localctx = NewPostfixExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, XPath3ParserRULE_postfixExpr)
				p.SetState(574)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(575)
					p.ArgumentList()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(580)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 37, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgumentListContext is an interface to support dynamic dispatch.
type IArgumentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Arguments() IArgumentsContext

	// IsArgumentListContext differentiates from other interfaces.
	IsArgumentListContext()
}

type ArgumentListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentListContext() *ArgumentListContext {
	var p = new(ArgumentListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_argumentList
	return p
}

func InitEmptyArgumentListContext(p *ArgumentListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_argumentList
}

func (*ArgumentListContext) IsArgumentListContext() {}

func NewArgumentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentListContext {
	var p = new(ArgumentListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_argumentList

	return p
}

func (s *ArgumentListContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentListContext) Arguments() IArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *ArgumentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterArgumentList(s)
	}
}

func (s *ArgumentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitArgumentList(s)
	}
}

func (p *XPath3Parser) ArgumentList() (localctx IArgumentListContext) {
	localctx = NewArgumentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, XPath3ParserRULE_argumentList)
	p.SetState(587)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 38, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(581)
			p.Match(XPath3ParserT__13)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(582)
			p.arguments(0)
		}
		{
			p.SetState(583)
			p.Match(XPath3ParserT__14)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(585)
			p.Match(XPath3ParserT__13)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(586)
			p.Match(XPath3ParserT__14)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgumentsContext is an interface to support dynamic dispatch.
type IArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Argument() IArgumentContext
	Arguments() IArgumentsContext

	// IsArgumentsContext differentiates from other interfaces.
	IsArgumentsContext()
}

type ArgumentsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentsContext() *ArgumentsContext {
	var p = new(ArgumentsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_arguments
	return p
}

func InitEmptyArgumentsContext(p *ArgumentsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_arguments
}

func (*ArgumentsContext) IsArgumentsContext() {}

func NewArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentsContext {
	var p = new(ArgumentsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_arguments

	return p
}

func (s *ArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentsContext) Argument() IArgumentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentContext)
}

func (s *ArgumentsContext) Arguments() IArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *ArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterArguments(s)
	}
}

func (s *ArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitArguments(s)
	}
}

func (p *XPath3Parser) Arguments() (localctx IArgumentsContext) {
	return p.arguments(0)
}

func (p *XPath3Parser) arguments(_p int) (localctx IArgumentsContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewArgumentsContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IArgumentsContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 106
	p.EnterRecursionRule(localctx, 106, XPath3ParserRULE_arguments, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(590)
		p.Argument()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(597)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 39, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewArgumentsContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, XPath3ParserRULE_arguments)
			p.SetState(592)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(593)
				p.Match(XPath3ParserT__0)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(594)
				p.Argument()
			}

		}
		p.SetState(599)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 39, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPredicateListContext is an interface to support dynamic dispatch.
type IPredicateListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPredicate() []IPredicateContext
	Predicate(i int) IPredicateContext

	// IsPredicateListContext differentiates from other interfaces.
	IsPredicateListContext()
}

type PredicateListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPredicateListContext() *PredicateListContext {
	var p = new(PredicateListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_predicateList
	return p
}

func InitEmptyPredicateListContext(p *PredicateListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_predicateList
}

func (*PredicateListContext) IsPredicateListContext() {}

func NewPredicateListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredicateListContext {
	var p = new(PredicateListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_predicateList

	return p
}

func (s *PredicateListContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateListContext) AllPredicate() []IPredicateContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPredicateContext); ok {
			len++
		}
	}

	tst := make([]IPredicateContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPredicateContext); ok {
			tst[i] = t.(IPredicateContext)
			i++
		}
	}

	return tst
}

func (s *PredicateListContext) Predicate(i int) IPredicateContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *PredicateListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PredicateListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterPredicateList(s)
	}
}

func (s *PredicateListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitPredicateList(s)
	}
}

func (p *XPath3Parser) PredicateList() (localctx IPredicateListContext) {
	localctx = NewPredicateListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, XPath3ParserRULE_predicateList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(603)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 40, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(600)
				p.Predicate()
			}

		}
		p.SetState(605)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 40, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPredicateContext is an interface to support dynamic dispatch.
type IPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext

	// IsPredicateContext differentiates from other interfaces.
	IsPredicateContext()
}

type PredicateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPredicateContext() *PredicateContext {
	var p = new(PredicateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_predicate
	return p
}

func InitEmptyPredicateContext(p *PredicateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_predicate
}

func (*PredicateContext) IsPredicateContext() {}

func NewPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredicateContext {
	var p = new(PredicateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_predicate

	return p
}

func (s *PredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *PredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterPredicate(s)
	}
}

func (s *PredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitPredicate(s)
	}
}

func (p *XPath3Parser) Predicate() (localctx IPredicateContext) {
	localctx = NewPredicateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, XPath3ParserRULE_predicate)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(606)
		p.Match(XPath3ParserT__72)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(607)
		p.expr(0)
	}
	{
		p.SetState(608)
		p.Match(XPath3ParserT__73)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimaryExprContext is an interface to support dynamic dispatch.
type IPrimaryExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Literal() ILiteralContext
	VarRef() IVarRefContext
	ParenthesizedExpr() IParenthesizedExprContext
	ContextItemExpr() IContextItemExprContext
	FunctionCall() IFunctionCallContext
	FunctionItemExpr() IFunctionItemExprContext

	// IsPrimaryExprContext differentiates from other interfaces.
	IsPrimaryExprContext()
}

type PrimaryExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryExprContext() *PrimaryExprContext {
	var p = new(PrimaryExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_primaryExpr
	return p
}

func InitEmptyPrimaryExprContext(p *PrimaryExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_primaryExpr
}

func (*PrimaryExprContext) IsPrimaryExprContext() {}

func NewPrimaryExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExprContext {
	var p = new(PrimaryExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_primaryExpr

	return p
}

func (s *PrimaryExprContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExprContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *PrimaryExprContext) VarRef() IVarRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarRefContext)
}

func (s *PrimaryExprContext) ParenthesizedExpr() IParenthesizedExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesizedExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesizedExprContext)
}

func (s *PrimaryExprContext) ContextItemExpr() IContextItemExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContextItemExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContextItemExprContext)
}

func (s *PrimaryExprContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *PrimaryExprContext) FunctionItemExpr() IFunctionItemExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionItemExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionItemExprContext)
}

func (s *PrimaryExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterPrimaryExpr(s)
	}
}

func (s *PrimaryExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitPrimaryExpr(s)
	}
}

func (p *XPath3Parser) PrimaryExpr() (localctx IPrimaryExprContext) {
	localctx = NewPrimaryExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, XPath3ParserRULE_primaryExpr)
	p.SetState(616)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 41, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(610)
			p.Literal()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(611)
			p.VarRef()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(612)
			p.ParenthesizedExpr()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(613)
			p.ContextItemExpr()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(614)
			p.FunctionCall()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(615)
			p.FunctionItemExpr()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVarRefContext is an interface to support dynamic dispatch.
type IVarRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VarName() IVarNameContext

	// IsVarRefContext differentiates from other interfaces.
	IsVarRefContext()
}

type VarRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarRefContext() *VarRefContext {
	var p = new(VarRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_varRef
	return p
}

func InitEmptyVarRefContext(p *VarRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_varRef
}

func (*VarRefContext) IsVarRefContext() {}

func NewVarRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarRefContext {
	var p = new(VarRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_varRef

	return p
}

func (s *VarRefContext) GetParser() antlr.Parser { return s.parser }

func (s *VarRefContext) VarName() IVarNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarNameContext)
}

func (s *VarRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterVarRef(s)
	}
}

func (s *VarRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitVarRef(s)
	}
}

func (p *XPath3Parser) VarRef() (localctx IVarRefContext) {
	localctx = NewVarRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, XPath3ParserRULE_varRef)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(618)
		p.Match(XPath3ParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(619)
		p.VarName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVarNameContext is an interface to support dynamic dispatch.
type IVarNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EqName() IEqNameContext

	// IsVarNameContext differentiates from other interfaces.
	IsVarNameContext()
}

type VarNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarNameContext() *VarNameContext {
	var p = new(VarNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_varName
	return p
}

func InitEmptyVarNameContext(p *VarNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_varName
}

func (*VarNameContext) IsVarNameContext() {}

func NewVarNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarNameContext {
	var p = new(VarNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_varName

	return p
}

func (s *VarNameContext) GetParser() antlr.Parser { return s.parser }

func (s *VarNameContext) EqName() IEqNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqNameContext)
}

func (s *VarNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterVarName(s)
	}
}

func (s *VarNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitVarName(s)
	}
}

func (p *XPath3Parser) VarName() (localctx IVarNameContext) {
	localctx = NewVarNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, XPath3ParserRULE_varName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(621)
		p.EqName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NumericLiteral() antlr.TerminalNode
	StringLiteral() IStringLiteralContext

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_literal
	return p
}

func InitEmptyLiteralContext(p *LiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_literal
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) NumericLiteral() antlr.TerminalNode {
	return s.GetToken(XPath3ParserNumericLiteral, 0)
}

func (s *LiteralContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (p *XPath3Parser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, XPath3ParserRULE_literal)
	p.SetState(625)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserNumericLiteral:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(623)
			p.Match(XPath3ParserNumericLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case XPath3ParserT__89, XPath3ParserT__90:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(624)
			p.StringLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParenthesizedExprContext is an interface to support dynamic dispatch.
type IParenthesizedExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext

	// IsParenthesizedExprContext differentiates from other interfaces.
	IsParenthesizedExprContext()
}

type ParenthesizedExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParenthesizedExprContext() *ParenthesizedExprContext {
	var p = new(ParenthesizedExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_parenthesizedExpr
	return p
}

func InitEmptyParenthesizedExprContext(p *ParenthesizedExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_parenthesizedExpr
}

func (*ParenthesizedExprContext) IsParenthesizedExprContext() {}

func NewParenthesizedExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParenthesizedExprContext {
	var p = new(ParenthesizedExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_parenthesizedExpr

	return p
}

func (s *ParenthesizedExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ParenthesizedExprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ParenthesizedExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParenthesizedExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterParenthesizedExpr(s)
	}
}

func (s *ParenthesizedExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitParenthesizedExpr(s)
	}
}

func (p *XPath3Parser) ParenthesizedExpr() (localctx IParenthesizedExprContext) {
	localctx = NewParenthesizedExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, XPath3ParserRULE_parenthesizedExpr)
	p.SetState(633)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 43, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(627)
			p.Match(XPath3ParserT__13)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(628)
			p.Match(XPath3ParserT__14)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(629)
			p.Match(XPath3ParserT__13)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(630)
			p.expr(0)
		}
		{
			p.SetState(631)
			p.Match(XPath3ParserT__14)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IContextItemExprContext is an interface to support dynamic dispatch.
type IContextItemExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsContextItemExprContext differentiates from other interfaces.
	IsContextItemExprContext()
}

type ContextItemExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContextItemExprContext() *ContextItemExprContext {
	var p = new(ContextItemExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_contextItemExpr
	return p
}

func InitEmptyContextItemExprContext(p *ContextItemExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_contextItemExpr
}

func (*ContextItemExprContext) IsContextItemExprContext() {}

func NewContextItemExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContextItemExprContext {
	var p = new(ContextItemExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_contextItemExpr

	return p
}

func (s *ContextItemExprContext) GetParser() antlr.Parser { return s.parser }
func (s *ContextItemExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContextItemExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContextItemExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterContextItemExpr(s)
	}
}

func (s *ContextItemExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitContextItemExpr(s)
	}
}

func (p *XPath3Parser) ContextItemExpr() (localctx IContextItemExprContext) {
	localctx = NewContextItemExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, XPath3ParserRULE_contextItemExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(635)
		p.Match(XPath3ParserT__74)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionCallContext is an interface to support dynamic dispatch.
type IFunctionCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EqName() IEqNameContext
	ArgumentList() IArgumentListContext

	// IsFunctionCallContext differentiates from other interfaces.
	IsFunctionCallContext()
}

type FunctionCallContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionCallContext() *FunctionCallContext {
	var p = new(FunctionCallContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_functionCall
	return p
}

func InitEmptyFunctionCallContext(p *FunctionCallContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_functionCall
}

func (*FunctionCallContext) IsFunctionCallContext() {}

func NewFunctionCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallContext {
	var p = new(FunctionCallContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_functionCall

	return p
}

func (s *FunctionCallContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallContext) EqName() IEqNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqNameContext)
}

func (s *FunctionCallContext) ArgumentList() IArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterFunctionCall(s)
	}
}

func (s *FunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitFunctionCall(s)
	}
}

func (p *XPath3Parser) FunctionCall() (localctx IFunctionCallContext) {
	localctx = NewFunctionCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, XPath3ParserRULE_functionCall)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(637)
		p.EqName()
	}
	{
		p.SetState(638)
		p.ArgumentList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgumentContext is an interface to support dynamic dispatch.
type IArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExprSingle() IExprSingleContext
	ArgumentPlaceholder() IArgumentPlaceholderContext

	// IsArgumentContext differentiates from other interfaces.
	IsArgumentContext()
}

type ArgumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentContext() *ArgumentContext {
	var p = new(ArgumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_argument
	return p
}

func InitEmptyArgumentContext(p *ArgumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_argument
}

func (*ArgumentContext) IsArgumentContext() {}

func NewArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentContext {
	var p = new(ArgumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_argument

	return p
}

func (s *ArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentContext) ExprSingle() IExprSingleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprSingleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprSingleContext)
}

func (s *ArgumentContext) ArgumentPlaceholder() IArgumentPlaceholderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentPlaceholderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentPlaceholderContext)
}

func (s *ArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterArgument(s)
	}
}

func (s *ArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitArgument(s)
	}
}

func (p *XPath3Parser) Argument() (localctx IArgumentContext) {
	localctx = NewArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, XPath3ParserRULE_argument)
	p.SetState(642)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserT__1, XPath3ParserT__5, XPath3ParserT__7, XPath3ParserT__9, XPath3ParserT__10, XPath3ParserT__12, XPath3ParserT__13, XPath3ParserT__21, XPath3ParserT__22, XPath3ParserT__23, XPath3ParserT__53, XPath3ParserT__54, XPath3ParserT__55, XPath3ParserT__57, XPath3ParserT__58, XPath3ParserT__59, XPath3ParserT__60, XPath3ParserT__61, XPath3ParserT__62, XPath3ParserT__63, XPath3ParserT__64, XPath3ParserT__65, XPath3ParserT__66, XPath3ParserT__67, XPath3ParserT__68, XPath3ParserT__69, XPath3ParserT__70, XPath3ParserT__74, XPath3ParserT__77, XPath3ParserT__80, XPath3ParserT__81, XPath3ParserT__82, XPath3ParserT__83, XPath3ParserT__84, XPath3ParserT__85, XPath3ParserT__86, XPath3ParserT__87, XPath3ParserT__88, XPath3ParserT__89, XPath3ParserT__90, XPath3ParserNumericLiteral, XPath3ParserURIQualifiedName, XPath3ParserBracedURILiteral, XPath3ParserQNAME, XPath3ParserNC_NAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(640)
			p.ExprSingle()
		}

	case XPath3ParserT__75:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(641)
			p.ArgumentPlaceholder()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgumentPlaceholderContext is an interface to support dynamic dispatch.
type IArgumentPlaceholderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsArgumentPlaceholderContext differentiates from other interfaces.
	IsArgumentPlaceholderContext()
}

type ArgumentPlaceholderContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentPlaceholderContext() *ArgumentPlaceholderContext {
	var p = new(ArgumentPlaceholderContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_argumentPlaceholder
	return p
}

func InitEmptyArgumentPlaceholderContext(p *ArgumentPlaceholderContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_argumentPlaceholder
}

func (*ArgumentPlaceholderContext) IsArgumentPlaceholderContext() {}

func NewArgumentPlaceholderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentPlaceholderContext {
	var p = new(ArgumentPlaceholderContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_argumentPlaceholder

	return p
}

func (s *ArgumentPlaceholderContext) GetParser() antlr.Parser { return s.parser }
func (s *ArgumentPlaceholderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentPlaceholderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentPlaceholderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterArgumentPlaceholder(s)
	}
}

func (s *ArgumentPlaceholderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitArgumentPlaceholder(s)
	}
}

func (p *XPath3Parser) ArgumentPlaceholder() (localctx IArgumentPlaceholderContext) {
	localctx = NewArgumentPlaceholderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, XPath3ParserRULE_argumentPlaceholder)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(644)
		p.Match(XPath3ParserT__75)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionItemExprContext is an interface to support dynamic dispatch.
type IFunctionItemExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NamedFunctionRef() INamedFunctionRefContext
	InlineFunctionExpr() IInlineFunctionExprContext

	// IsFunctionItemExprContext differentiates from other interfaces.
	IsFunctionItemExprContext()
}

type FunctionItemExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionItemExprContext() *FunctionItemExprContext {
	var p = new(FunctionItemExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_functionItemExpr
	return p
}

func InitEmptyFunctionItemExprContext(p *FunctionItemExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_functionItemExpr
}

func (*FunctionItemExprContext) IsFunctionItemExprContext() {}

func NewFunctionItemExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionItemExprContext {
	var p = new(FunctionItemExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_functionItemExpr

	return p
}

func (s *FunctionItemExprContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionItemExprContext) NamedFunctionRef() INamedFunctionRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedFunctionRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedFunctionRefContext)
}

func (s *FunctionItemExprContext) InlineFunctionExpr() IInlineFunctionExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInlineFunctionExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInlineFunctionExprContext)
}

func (s *FunctionItemExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionItemExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionItemExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterFunctionItemExpr(s)
	}
}

func (s *FunctionItemExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitFunctionItemExpr(s)
	}
}

func (p *XPath3Parser) FunctionItemExpr() (localctx IFunctionItemExprContext) {
	localctx = NewFunctionItemExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, XPath3ParserRULE_functionItemExpr)
	p.SetState(648)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserURIQualifiedName, XPath3ParserQNAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(646)
			p.NamedFunctionRef()
		}

	case XPath3ParserT__77:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(647)
			p.InlineFunctionExpr()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedFunctionRefContext is an interface to support dynamic dispatch.
type INamedFunctionRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EqName() IEqNameContext
	IntegerLiteral() antlr.TerminalNode

	// IsNamedFunctionRefContext differentiates from other interfaces.
	IsNamedFunctionRefContext()
}

type NamedFunctionRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedFunctionRefContext() *NamedFunctionRefContext {
	var p = new(NamedFunctionRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_namedFunctionRef
	return p
}

func InitEmptyNamedFunctionRefContext(p *NamedFunctionRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_namedFunctionRef
}

func (*NamedFunctionRefContext) IsNamedFunctionRefContext() {}

func NewNamedFunctionRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedFunctionRefContext {
	var p = new(NamedFunctionRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_namedFunctionRef

	return p
}

func (s *NamedFunctionRefContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedFunctionRefContext) EqName() IEqNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqNameContext)
}

func (s *NamedFunctionRefContext) IntegerLiteral() antlr.TerminalNode {
	return s.GetToken(XPath3ParserIntegerLiteral, 0)
}

func (s *NamedFunctionRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedFunctionRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedFunctionRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterNamedFunctionRef(s)
	}
}

func (s *NamedFunctionRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitNamedFunctionRef(s)
	}
}

func (p *XPath3Parser) NamedFunctionRef() (localctx INamedFunctionRefContext) {
	localctx = NewNamedFunctionRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, XPath3ParserRULE_namedFunctionRef)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(650)
		p.EqName()
	}
	{
		p.SetState(651)
		p.Match(XPath3ParserT__76)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(652)
		p.Match(XPath3ParserIntegerLiteral)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInlineFunctionExprContext is an interface to support dynamic dispatch.
type IInlineFunctionExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionBody() IFunctionBodyContext
	ParamList() IParamListContext
	SequenceType() ISequenceTypeContext

	// IsInlineFunctionExprContext differentiates from other interfaces.
	IsInlineFunctionExprContext()
}

type InlineFunctionExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInlineFunctionExprContext() *InlineFunctionExprContext {
	var p = new(InlineFunctionExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_inlineFunctionExpr
	return p
}

func InitEmptyInlineFunctionExprContext(p *InlineFunctionExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_inlineFunctionExpr
}

func (*InlineFunctionExprContext) IsInlineFunctionExprContext() {}

func NewInlineFunctionExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InlineFunctionExprContext {
	var p = new(InlineFunctionExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_inlineFunctionExpr

	return p
}

func (s *InlineFunctionExprContext) GetParser() antlr.Parser { return s.parser }

func (s *InlineFunctionExprContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *InlineFunctionExprContext) ParamList() IParamListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParamListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParamListContext)
}

func (s *InlineFunctionExprContext) SequenceType() ISequenceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISequenceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISequenceTypeContext)
}

func (s *InlineFunctionExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlineFunctionExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InlineFunctionExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterInlineFunctionExpr(s)
	}
}

func (s *InlineFunctionExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitInlineFunctionExpr(s)
	}
}

func (p *XPath3Parser) InlineFunctionExpr() (localctx IInlineFunctionExprContext) {
	localctx = NewInlineFunctionExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, XPath3ParserRULE_inlineFunctionExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(654)
		p.Match(XPath3ParserT__77)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(655)
		p.Match(XPath3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(657)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == XPath3ParserT__1 {
		{
			p.SetState(656)
			p.ParamList()
		}

	}
	{
		p.SetState(659)
		p.Match(XPath3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(662)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == XPath3ParserT__34 {
		{
			p.SetState(660)
			p.Match(XPath3ParserT__34)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(661)
			p.SequenceType()
		}

	}
	{
		p.SetState(664)
		p.FunctionBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleTypeContext is an interface to support dynamic dispatch.
type ISingleTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleTypeName() ISimpleTypeNameContext

	// IsSingleTypeContext differentiates from other interfaces.
	IsSingleTypeContext()
}

type SingleTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleTypeContext() *SingleTypeContext {
	var p = new(SingleTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_singleType
	return p
}

func InitEmptySingleTypeContext(p *SingleTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_singleType
}

func (*SingleTypeContext) IsSingleTypeContext() {}

func NewSingleTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleTypeContext {
	var p = new(SingleTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_singleType

	return p
}

func (s *SingleTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleTypeContext) SimpleTypeName() ISimpleTypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleTypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleTypeNameContext)
}

func (s *SingleTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterSingleType(s)
	}
}

func (s *SingleTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitSingleType(s)
	}
}

func (p *XPath3Parser) SingleType() (localctx ISingleTypeContext) {
	localctx = NewSingleTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, XPath3ParserRULE_singleType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(666)
		p.SimpleTypeName()
	}
	p.SetState(668)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 48, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(667)
			p.Match(XPath3ParserT__75)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IType_declarationContext is an interface to support dynamic dispatch.
type IType_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SequenceType() ISequenceTypeContext

	// IsType_declarationContext differentiates from other interfaces.
	IsType_declarationContext()
}

type Type_declarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_declarationContext() *Type_declarationContext {
	var p = new(Type_declarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_type_declaration
	return p
}

func InitEmptyType_declarationContext(p *Type_declarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_type_declaration
}

func (*Type_declarationContext) IsType_declarationContext() {}

func NewType_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_declarationContext {
	var p = new(Type_declarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_type_declaration

	return p
}

func (s *Type_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_declarationContext) SequenceType() ISequenceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISequenceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISequenceTypeContext)
}

func (s *Type_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterType_declaration(s)
	}
}

func (s *Type_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitType_declaration(s)
	}
}

func (p *XPath3Parser) Type_declaration() (localctx IType_declarationContext) {
	localctx = NewType_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, XPath3ParserRULE_type_declaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(670)
		p.Match(XPath3ParserT__34)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(671)
		p.SequenceType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISequenceTypeContext is an interface to support dynamic dispatch.
type ISequenceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ItemType() IItemTypeContext
	OccurenceIndicator() IOccurenceIndicatorContext

	// IsSequenceTypeContext differentiates from other interfaces.
	IsSequenceTypeContext()
}

type SequenceTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequenceTypeContext() *SequenceTypeContext {
	var p = new(SequenceTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_sequenceType
	return p
}

func InitEmptySequenceTypeContext(p *SequenceTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_sequenceType
}

func (*SequenceTypeContext) IsSequenceTypeContext() {}

func NewSequenceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SequenceTypeContext {
	var p = new(SequenceTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_sequenceType

	return p
}

func (s *SequenceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SequenceTypeContext) ItemType() IItemTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IItemTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IItemTypeContext)
}

func (s *SequenceTypeContext) OccurenceIndicator() IOccurenceIndicatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOccurenceIndicatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOccurenceIndicatorContext)
}

func (s *SequenceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SequenceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SequenceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterSequenceType(s)
	}
}

func (s *SequenceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitSequenceType(s)
	}
}

func (p *XPath3Parser) SequenceType() (localctx ISequenceTypeContext) {
	localctx = NewSequenceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, XPath3ParserRULE_sequenceType)
	p.SetState(680)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserT__78:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(673)
			p.Match(XPath3ParserT__78)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(674)
			p.Match(XPath3ParserT__13)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(675)
			p.Match(XPath3ParserT__14)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case XPath3ParserT__13, XPath3ParserT__58, XPath3ParserT__77, XPath3ParserT__79, XPath3ParserT__80, XPath3ParserT__81, XPath3ParserT__82, XPath3ParserT__83, XPath3ParserT__84, XPath3ParserT__85, XPath3ParserT__86, XPath3ParserT__87, XPath3ParserT__88, XPath3ParserURIQualifiedName, XPath3ParserQNAME:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(676)
			p.ItemType()
		}
		p.SetState(678)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 49, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(677)
				p.OccurenceIndicator()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOccurenceIndicatorContext is an interface to support dynamic dispatch.
type IOccurenceIndicatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsOccurenceIndicatorContext differentiates from other interfaces.
	IsOccurenceIndicatorContext()
}

type OccurenceIndicatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOccurenceIndicatorContext() *OccurenceIndicatorContext {
	var p = new(OccurenceIndicatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_occurenceIndicator
	return p
}

func InitEmptyOccurenceIndicatorContext(p *OccurenceIndicatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_occurenceIndicator
}

func (*OccurenceIndicatorContext) IsOccurenceIndicatorContext() {}

func NewOccurenceIndicatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OccurenceIndicatorContext {
	var p = new(OccurenceIndicatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_occurenceIndicator

	return p
}

func (s *OccurenceIndicatorContext) GetParser() antlr.Parser { return s.parser }
func (s *OccurenceIndicatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OccurenceIndicatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OccurenceIndicatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterOccurenceIndicator(s)
	}
}

func (s *OccurenceIndicatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitOccurenceIndicator(s)
	}
}

func (p *XPath3Parser) OccurenceIndicator() (localctx IOccurenceIndicatorContext) {
	localctx = NewOccurenceIndicatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, XPath3ParserRULE_occurenceIndicator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(682)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-22)) & ^0x3f) == 0 && ((int64(1)<<(_la-22))&18014398509481989) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IItemTypeContext is an interface to support dynamic dispatch.
type IItemTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KindTest() IKindTestContext
	FunctionTest() IFunctionTestContext
	AtomicOrUnionType() IAtomicOrUnionTypeContext
	ParenthesizedItemType() IParenthesizedItemTypeContext

	// IsItemTypeContext differentiates from other interfaces.
	IsItemTypeContext()
}

type ItemTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyItemTypeContext() *ItemTypeContext {
	var p = new(ItemTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_itemType
	return p
}

func InitEmptyItemTypeContext(p *ItemTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_itemType
}

func (*ItemTypeContext) IsItemTypeContext() {}

func NewItemTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ItemTypeContext {
	var p = new(ItemTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_itemType

	return p
}

func (s *ItemTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ItemTypeContext) KindTest() IKindTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKindTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKindTestContext)
}

func (s *ItemTypeContext) FunctionTest() IFunctionTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionTestContext)
}

func (s *ItemTypeContext) AtomicOrUnionType() IAtomicOrUnionTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAtomicOrUnionTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAtomicOrUnionTypeContext)
}

func (s *ItemTypeContext) ParenthesizedItemType() IParenthesizedItemTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesizedItemTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesizedItemTypeContext)
}

func (s *ItemTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ItemTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ItemTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterItemType(s)
	}
}

func (s *ItemTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitItemType(s)
	}
}

func (p *XPath3Parser) ItemType() (localctx IItemTypeContext) {
	localctx = NewItemTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, XPath3ParserRULE_itemType)
	p.SetState(691)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserT__58, XPath3ParserT__80, XPath3ParserT__81, XPath3ParserT__82, XPath3ParserT__83, XPath3ParserT__84, XPath3ParserT__85, XPath3ParserT__86, XPath3ParserT__87, XPath3ParserT__88:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(684)
			p.KindTest()
		}

	case XPath3ParserT__79:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(685)
			p.Match(XPath3ParserT__79)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(686)
			p.Match(XPath3ParserT__13)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(687)
			p.Match(XPath3ParserT__14)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case XPath3ParserT__77:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(688)
			p.FunctionTest()
		}

	case XPath3ParserURIQualifiedName, XPath3ParserQNAME:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(689)
			p.AtomicOrUnionType()
		}

	case XPath3ParserT__13:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(690)
			p.ParenthesizedItemType()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAtomicOrUnionTypeContext is an interface to support dynamic dispatch.
type IAtomicOrUnionTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EqName() IEqNameContext

	// IsAtomicOrUnionTypeContext differentiates from other interfaces.
	IsAtomicOrUnionTypeContext()
}

type AtomicOrUnionTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomicOrUnionTypeContext() *AtomicOrUnionTypeContext {
	var p = new(AtomicOrUnionTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_atomicOrUnionType
	return p
}

func InitEmptyAtomicOrUnionTypeContext(p *AtomicOrUnionTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_atomicOrUnionType
}

func (*AtomicOrUnionTypeContext) IsAtomicOrUnionTypeContext() {}

func NewAtomicOrUnionTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomicOrUnionTypeContext {
	var p = new(AtomicOrUnionTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_atomicOrUnionType

	return p
}

func (s *AtomicOrUnionTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomicOrUnionTypeContext) EqName() IEqNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqNameContext)
}

func (s *AtomicOrUnionTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomicOrUnionTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomicOrUnionTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterAtomicOrUnionType(s)
	}
}

func (s *AtomicOrUnionTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitAtomicOrUnionType(s)
	}
}

func (p *XPath3Parser) AtomicOrUnionType() (localctx IAtomicOrUnionTypeContext) {
	localctx = NewAtomicOrUnionTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, XPath3ParserRULE_atomicOrUnionType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(693)
		p.EqName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKindTestContext is an interface to support dynamic dispatch.
type IKindTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DocumentTest() IDocumentTestContext
	ElementTest() IElementTestContext
	AttributeTest() IAttributeTestContext
	SchemaElementTest() ISchemaElementTestContext
	SchemaAttributeTest() ISchemaAttributeTestContext
	PiTest() IPiTestContext
	CommentTest() ICommentTestContext
	TextTest() ITextTestContext
	NamespaceNodeTest() INamespaceNodeTestContext
	AnyKindTest() IAnyKindTestContext

	// IsKindTestContext differentiates from other interfaces.
	IsKindTestContext()
}

type KindTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKindTestContext() *KindTestContext {
	var p = new(KindTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_kindTest
	return p
}

func InitEmptyKindTestContext(p *KindTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_kindTest
}

func (*KindTestContext) IsKindTestContext() {}

func NewKindTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KindTestContext {
	var p = new(KindTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_kindTest

	return p
}

func (s *KindTestContext) GetParser() antlr.Parser { return s.parser }

func (s *KindTestContext) DocumentTest() IDocumentTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDocumentTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDocumentTestContext)
}

func (s *KindTestContext) ElementTest() IElementTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementTestContext)
}

func (s *KindTestContext) AttributeTest() IAttributeTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeTestContext)
}

func (s *KindTestContext) SchemaElementTest() ISchemaElementTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISchemaElementTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISchemaElementTestContext)
}

func (s *KindTestContext) SchemaAttributeTest() ISchemaAttributeTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISchemaAttributeTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISchemaAttributeTestContext)
}

func (s *KindTestContext) PiTest() IPiTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPiTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPiTestContext)
}

func (s *KindTestContext) CommentTest() ICommentTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentTestContext)
}

func (s *KindTestContext) TextTest() ITextTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextTestContext)
}

func (s *KindTestContext) NamespaceNodeTest() INamespaceNodeTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceNodeTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceNodeTestContext)
}

func (s *KindTestContext) AnyKindTest() IAnyKindTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnyKindTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnyKindTestContext)
}

func (s *KindTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KindTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KindTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterKindTest(s)
	}
}

func (s *KindTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitKindTest(s)
	}
}

func (p *XPath3Parser) KindTest() (localctx IKindTestContext) {
	localctx = NewKindTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, XPath3ParserRULE_kindTest)
	p.SetState(705)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserT__81:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(695)
			p.DocumentTest()
		}

	case XPath3ParserT__87:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(696)
			p.ElementTest()
		}

	case XPath3ParserT__58:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(697)
			p.AttributeTest()
		}

	case XPath3ParserT__88:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(698)
			p.SchemaElementTest()
		}

	case XPath3ParserT__86:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(699)
			p.SchemaAttributeTest()
		}

	case XPath3ParserT__85:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(700)
			p.PiTest()
		}

	case XPath3ParserT__83:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(701)
			p.CommentTest()
		}

	case XPath3ParserT__82:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(702)
			p.TextTest()
		}

	case XPath3ParserT__84:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(703)
			p.NamespaceNodeTest()
		}

	case XPath3ParserT__80:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(704)
			p.AnyKindTest()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnyKindTestContext is an interface to support dynamic dispatch.
type IAnyKindTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAnyKindTestContext differentiates from other interfaces.
	IsAnyKindTestContext()
}

type AnyKindTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnyKindTestContext() *AnyKindTestContext {
	var p = new(AnyKindTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_anyKindTest
	return p
}

func InitEmptyAnyKindTestContext(p *AnyKindTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_anyKindTest
}

func (*AnyKindTestContext) IsAnyKindTestContext() {}

func NewAnyKindTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnyKindTestContext {
	var p = new(AnyKindTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_anyKindTest

	return p
}

func (s *AnyKindTestContext) GetParser() antlr.Parser { return s.parser }
func (s *AnyKindTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnyKindTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnyKindTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterAnyKindTest(s)
	}
}

func (s *AnyKindTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitAnyKindTest(s)
	}
}

func (p *XPath3Parser) AnyKindTest() (localctx IAnyKindTestContext) {
	localctx = NewAnyKindTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, XPath3ParserRULE_anyKindTest)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(707)
		p.Match(XPath3ParserT__80)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(708)
		p.Match(XPath3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(709)
		p.Match(XPath3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDocumentTestContext is an interface to support dynamic dispatch.
type IDocumentTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ElementTest() IElementTestContext
	SchemaElementTest() ISchemaElementTestContext

	// IsDocumentTestContext differentiates from other interfaces.
	IsDocumentTestContext()
}

type DocumentTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDocumentTestContext() *DocumentTestContext {
	var p = new(DocumentTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_documentTest
	return p
}

func InitEmptyDocumentTestContext(p *DocumentTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_documentTest
}

func (*DocumentTestContext) IsDocumentTestContext() {}

func NewDocumentTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DocumentTestContext {
	var p = new(DocumentTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_documentTest

	return p
}

func (s *DocumentTestContext) GetParser() antlr.Parser { return s.parser }

func (s *DocumentTestContext) ElementTest() IElementTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementTestContext)
}

func (s *DocumentTestContext) SchemaElementTest() ISchemaElementTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISchemaElementTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISchemaElementTestContext)
}

func (s *DocumentTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DocumentTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DocumentTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterDocumentTest(s)
	}
}

func (s *DocumentTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitDocumentTest(s)
	}
}

func (p *XPath3Parser) DocumentTest() (localctx IDocumentTestContext) {
	localctx = NewDocumentTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, XPath3ParserRULE_documentTest)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(711)
		p.Match(XPath3ParserT__81)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(712)
		p.Match(XPath3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(715)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case XPath3ParserT__87:
		{
			p.SetState(713)
			p.ElementTest()
		}

	case XPath3ParserT__88:
		{
			p.SetState(714)
			p.SchemaElementTest()
		}

	case XPath3ParserT__14:

	default:
	}
	{
		p.SetState(717)
		p.Match(XPath3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITextTestContext is an interface to support dynamic dispatch.
type ITextTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTextTestContext differentiates from other interfaces.
	IsTextTestContext()
}

type TextTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTextTestContext() *TextTestContext {
	var p = new(TextTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_textTest
	return p
}

func InitEmptyTextTestContext(p *TextTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_textTest
}

func (*TextTestContext) IsTextTestContext() {}

func NewTextTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TextTestContext {
	var p = new(TextTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_textTest

	return p
}

func (s *TextTestContext) GetParser() antlr.Parser { return s.parser }
func (s *TextTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TextTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TextTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterTextTest(s)
	}
}

func (s *TextTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitTextTest(s)
	}
}

func (p *XPath3Parser) TextTest() (localctx ITextTestContext) {
	localctx = NewTextTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, XPath3ParserRULE_textTest)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(719)
		p.Match(XPath3ParserT__82)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(720)
		p.Match(XPath3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(721)
		p.Match(XPath3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommentTestContext is an interface to support dynamic dispatch.
type ICommentTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsCommentTestContext differentiates from other interfaces.
	IsCommentTestContext()
}

type CommentTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommentTestContext() *CommentTestContext {
	var p = new(CommentTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_commentTest
	return p
}

func InitEmptyCommentTestContext(p *CommentTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_commentTest
}

func (*CommentTestContext) IsCommentTestContext() {}

func NewCommentTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommentTestContext {
	var p = new(CommentTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_commentTest

	return p
}

func (s *CommentTestContext) GetParser() antlr.Parser { return s.parser }
func (s *CommentTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommentTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterCommentTest(s)
	}
}

func (s *CommentTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitCommentTest(s)
	}
}

func (p *XPath3Parser) CommentTest() (localctx ICommentTestContext) {
	localctx = NewCommentTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, XPath3ParserRULE_commentTest)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(723)
		p.Match(XPath3ParserT__83)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(724)
		p.Match(XPath3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(725)
		p.Match(XPath3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamespaceNodeTestContext is an interface to support dynamic dispatch.
type INamespaceNodeTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsNamespaceNodeTestContext differentiates from other interfaces.
	IsNamespaceNodeTestContext()
}

type NamespaceNodeTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamespaceNodeTestContext() *NamespaceNodeTestContext {
	var p = new(NamespaceNodeTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_namespaceNodeTest
	return p
}

func InitEmptyNamespaceNodeTestContext(p *NamespaceNodeTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_namespaceNodeTest
}

func (*NamespaceNodeTestContext) IsNamespaceNodeTestContext() {}

func NewNamespaceNodeTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamespaceNodeTestContext {
	var p = new(NamespaceNodeTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_namespaceNodeTest

	return p
}

func (s *NamespaceNodeTestContext) GetParser() antlr.Parser { return s.parser }
func (s *NamespaceNodeTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamespaceNodeTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamespaceNodeTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterNamespaceNodeTest(s)
	}
}

func (s *NamespaceNodeTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitNamespaceNodeTest(s)
	}
}

func (p *XPath3Parser) NamespaceNodeTest() (localctx INamespaceNodeTestContext) {
	localctx = NewNamespaceNodeTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, XPath3ParserRULE_namespaceNodeTest)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(727)
		p.Match(XPath3ParserT__84)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(728)
		p.Match(XPath3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(729)
		p.Match(XPath3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPiTestContext is an interface to support dynamic dispatch.
type IPiTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NC_NAME() antlr.TerminalNode
	StringLiteral() IStringLiteralContext

	// IsPiTestContext differentiates from other interfaces.
	IsPiTestContext()
}

type PiTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPiTestContext() *PiTestContext {
	var p = new(PiTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_piTest
	return p
}

func InitEmptyPiTestContext(p *PiTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_piTest
}

func (*PiTestContext) IsPiTestContext() {}

func NewPiTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PiTestContext {
	var p = new(PiTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_piTest

	return p
}

func (s *PiTestContext) GetParser() antlr.Parser { return s.parser }

func (s *PiTestContext) NC_NAME() antlr.TerminalNode {
	return s.GetToken(XPath3ParserNC_NAME, 0)
}

func (s *PiTestContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *PiTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PiTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PiTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterPiTest(s)
	}
}

func (s *PiTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitPiTest(s)
	}
}

func (p *XPath3Parser) PiTest() (localctx IPiTestContext) {
	localctx = NewPiTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, XPath3ParserRULE_piTest)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(731)
		p.Match(XPath3ParserT__85)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(732)
		p.Match(XPath3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(735)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case XPath3ParserNC_NAME:
		{
			p.SetState(733)
			p.Match(XPath3ParserNC_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case XPath3ParserT__89, XPath3ParserT__90:
		{
			p.SetState(734)
			p.StringLiteral()
		}

	case XPath3ParserT__14:

	default:
	}
	{
		p.SetState(737)
		p.Match(XPath3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeTestContext is an interface to support dynamic dispatch.
type IAttributeTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AttribNameOrWildcard() IAttribNameOrWildcardContext
	TypeName() ITypeNameContext

	// IsAttributeTestContext differentiates from other interfaces.
	IsAttributeTestContext()
}

type AttributeTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeTestContext() *AttributeTestContext {
	var p = new(AttributeTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_attributeTest
	return p
}

func InitEmptyAttributeTestContext(p *AttributeTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_attributeTest
}

func (*AttributeTestContext) IsAttributeTestContext() {}

func NewAttributeTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeTestContext {
	var p = new(AttributeTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_attributeTest

	return p
}

func (s *AttributeTestContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeTestContext) AttribNameOrWildcard() IAttribNameOrWildcardContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttribNameOrWildcardContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttribNameOrWildcardContext)
}

func (s *AttributeTestContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *AttributeTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterAttributeTest(s)
	}
}

func (s *AttributeTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitAttributeTest(s)
	}
}

func (p *XPath3Parser) AttributeTest() (localctx IAttributeTestContext) {
	localctx = NewAttributeTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, XPath3ParserRULE_attributeTest)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(739)
		p.Match(XPath3ParserT__58)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(740)
		p.Match(XPath3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(746)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == XPath3ParserT__23 || _la == XPath3ParserURIQualifiedName || _la == XPath3ParserQNAME {
		{
			p.SetState(741)
			p.AttribNameOrWildcard()
		}
		p.SetState(744)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == XPath3ParserT__0 {
			{
				p.SetState(742)
				p.Match(XPath3ParserT__0)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(743)
				p.TypeName()
			}

		}

	}
	{
		p.SetState(748)
		p.Match(XPath3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttribNameOrWildcardContext is an interface to support dynamic dispatch.
type IAttribNameOrWildcardContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AttributeName() IAttributeNameContext

	// IsAttribNameOrWildcardContext differentiates from other interfaces.
	IsAttribNameOrWildcardContext()
}

type AttribNameOrWildcardContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttribNameOrWildcardContext() *AttribNameOrWildcardContext {
	var p = new(AttribNameOrWildcardContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_attribNameOrWildcard
	return p
}

func InitEmptyAttribNameOrWildcardContext(p *AttribNameOrWildcardContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_attribNameOrWildcard
}

func (*AttribNameOrWildcardContext) IsAttribNameOrWildcardContext() {}

func NewAttribNameOrWildcardContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttribNameOrWildcardContext {
	var p = new(AttribNameOrWildcardContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_attribNameOrWildcard

	return p
}

func (s *AttribNameOrWildcardContext) GetParser() antlr.Parser { return s.parser }

func (s *AttribNameOrWildcardContext) AttributeName() IAttributeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeNameContext)
}

func (s *AttribNameOrWildcardContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttribNameOrWildcardContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttribNameOrWildcardContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterAttribNameOrWildcard(s)
	}
}

func (s *AttribNameOrWildcardContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitAttribNameOrWildcard(s)
	}
}

func (p *XPath3Parser) AttribNameOrWildcard() (localctx IAttribNameOrWildcardContext) {
	localctx = NewAttribNameOrWildcardContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, XPath3ParserRULE_attribNameOrWildcard)
	p.SetState(752)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserURIQualifiedName, XPath3ParserQNAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(750)
			p.AttributeName()
		}

	case XPath3ParserT__23:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(751)
			p.Match(XPath3ParserT__23)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISchemaAttributeTestContext is an interface to support dynamic dispatch.
type ISchemaAttributeTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AttributeDeclaration() IAttributeDeclarationContext

	// IsSchemaAttributeTestContext differentiates from other interfaces.
	IsSchemaAttributeTestContext()
}

type SchemaAttributeTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySchemaAttributeTestContext() *SchemaAttributeTestContext {
	var p = new(SchemaAttributeTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_schemaAttributeTest
	return p
}

func InitEmptySchemaAttributeTestContext(p *SchemaAttributeTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_schemaAttributeTest
}

func (*SchemaAttributeTestContext) IsSchemaAttributeTestContext() {}

func NewSchemaAttributeTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SchemaAttributeTestContext {
	var p = new(SchemaAttributeTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_schemaAttributeTest

	return p
}

func (s *SchemaAttributeTestContext) GetParser() antlr.Parser { return s.parser }

func (s *SchemaAttributeTestContext) AttributeDeclaration() IAttributeDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeDeclarationContext)
}

func (s *SchemaAttributeTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SchemaAttributeTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SchemaAttributeTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterSchemaAttributeTest(s)
	}
}

func (s *SchemaAttributeTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitSchemaAttributeTest(s)
	}
}

func (p *XPath3Parser) SchemaAttributeTest() (localctx ISchemaAttributeTestContext) {
	localctx = NewSchemaAttributeTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, XPath3ParserRULE_schemaAttributeTest)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(754)
		p.Match(XPath3ParserT__86)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(755)
		p.Match(XPath3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(756)
		p.AttributeDeclaration()
	}
	{
		p.SetState(757)
		p.Match(XPath3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeDeclarationContext is an interface to support dynamic dispatch.
type IAttributeDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AttributeName() IAttributeNameContext

	// IsAttributeDeclarationContext differentiates from other interfaces.
	IsAttributeDeclarationContext()
}

type AttributeDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeDeclarationContext() *AttributeDeclarationContext {
	var p = new(AttributeDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_attributeDeclaration
	return p
}

func InitEmptyAttributeDeclarationContext(p *AttributeDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_attributeDeclaration
}

func (*AttributeDeclarationContext) IsAttributeDeclarationContext() {}

func NewAttributeDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeDeclarationContext {
	var p = new(AttributeDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_attributeDeclaration

	return p
}

func (s *AttributeDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeDeclarationContext) AttributeName() IAttributeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeNameContext)
}

func (s *AttributeDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterAttributeDeclaration(s)
	}
}

func (s *AttributeDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitAttributeDeclaration(s)
	}
}

func (p *XPath3Parser) AttributeDeclaration() (localctx IAttributeDeclarationContext) {
	localctx = NewAttributeDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, XPath3ParserRULE_attributeDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(759)
		p.AttributeName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementTestContext is an interface to support dynamic dispatch.
type IElementTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ElementNameOrWildcard() IElementNameOrWildcardContext
	TypeName() ITypeNameContext

	// IsElementTestContext differentiates from other interfaces.
	IsElementTestContext()
}

type ElementTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementTestContext() *ElementTestContext {
	var p = new(ElementTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_elementTest
	return p
}

func InitEmptyElementTestContext(p *ElementTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_elementTest
}

func (*ElementTestContext) IsElementTestContext() {}

func NewElementTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementTestContext {
	var p = new(ElementTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_elementTest

	return p
}

func (s *ElementTestContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementTestContext) ElementNameOrWildcard() IElementNameOrWildcardContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementNameOrWildcardContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementNameOrWildcardContext)
}

func (s *ElementTestContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *ElementTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterElementTest(s)
	}
}

func (s *ElementTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitElementTest(s)
	}
}

func (p *XPath3Parser) ElementTest() (localctx IElementTestContext) {
	localctx = NewElementTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, XPath3ParserRULE_elementTest)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(761)
		p.Match(XPath3ParserT__87)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(762)
		p.Match(XPath3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(771)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == XPath3ParserT__23 || _la == XPath3ParserURIQualifiedName || _la == XPath3ParserQNAME {
		{
			p.SetState(763)
			p.ElementNameOrWildcard()
		}
		p.SetState(769)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == XPath3ParserT__0 {
			{
				p.SetState(764)
				p.Match(XPath3ParserT__0)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(765)
				p.TypeName()
			}
			p.SetState(767)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == XPath3ParserT__75 {
				{
					p.SetState(766)
					p.Match(XPath3ParserT__75)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		}

	}
	{
		p.SetState(773)
		p.Match(XPath3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementNameOrWildcardContext is an interface to support dynamic dispatch.
type IElementNameOrWildcardContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ElementName() IElementNameContext

	// IsElementNameOrWildcardContext differentiates from other interfaces.
	IsElementNameOrWildcardContext()
}

type ElementNameOrWildcardContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementNameOrWildcardContext() *ElementNameOrWildcardContext {
	var p = new(ElementNameOrWildcardContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_elementNameOrWildcard
	return p
}

func InitEmptyElementNameOrWildcardContext(p *ElementNameOrWildcardContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_elementNameOrWildcard
}

func (*ElementNameOrWildcardContext) IsElementNameOrWildcardContext() {}

func NewElementNameOrWildcardContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementNameOrWildcardContext {
	var p = new(ElementNameOrWildcardContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_elementNameOrWildcard

	return p
}

func (s *ElementNameOrWildcardContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementNameOrWildcardContext) ElementName() IElementNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementNameContext)
}

func (s *ElementNameOrWildcardContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementNameOrWildcardContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementNameOrWildcardContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterElementNameOrWildcard(s)
	}
}

func (s *ElementNameOrWildcardContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitElementNameOrWildcard(s)
	}
}

func (p *XPath3Parser) ElementNameOrWildcard() (localctx IElementNameOrWildcardContext) {
	localctx = NewElementNameOrWildcardContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, XPath3ParserRULE_elementNameOrWildcard)
	p.SetState(777)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserURIQualifiedName, XPath3ParserQNAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(775)
			p.ElementName()
		}

	case XPath3ParserT__23:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(776)
			p.Match(XPath3ParserT__23)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISchemaElementTestContext is an interface to support dynamic dispatch.
type ISchemaElementTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ElementDeclaration() IElementDeclarationContext

	// IsSchemaElementTestContext differentiates from other interfaces.
	IsSchemaElementTestContext()
}

type SchemaElementTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySchemaElementTestContext() *SchemaElementTestContext {
	var p = new(SchemaElementTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_schemaElementTest
	return p
}

func InitEmptySchemaElementTestContext(p *SchemaElementTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_schemaElementTest
}

func (*SchemaElementTestContext) IsSchemaElementTestContext() {}

func NewSchemaElementTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SchemaElementTestContext {
	var p = new(SchemaElementTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_schemaElementTest

	return p
}

func (s *SchemaElementTestContext) GetParser() antlr.Parser { return s.parser }

func (s *SchemaElementTestContext) ElementDeclaration() IElementDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementDeclarationContext)
}

func (s *SchemaElementTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SchemaElementTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SchemaElementTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterSchemaElementTest(s)
	}
}

func (s *SchemaElementTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitSchemaElementTest(s)
	}
}

func (p *XPath3Parser) SchemaElementTest() (localctx ISchemaElementTestContext) {
	localctx = NewSchemaElementTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, XPath3ParserRULE_schemaElementTest)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(779)
		p.Match(XPath3ParserT__88)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(780)
		p.Match(XPath3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(781)
		p.ElementDeclaration()
	}
	{
		p.SetState(782)
		p.Match(XPath3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementDeclarationContext is an interface to support dynamic dispatch.
type IElementDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ElementName() IElementNameContext

	// IsElementDeclarationContext differentiates from other interfaces.
	IsElementDeclarationContext()
}

type ElementDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementDeclarationContext() *ElementDeclarationContext {
	var p = new(ElementDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_elementDeclaration
	return p
}

func InitEmptyElementDeclarationContext(p *ElementDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_elementDeclaration
}

func (*ElementDeclarationContext) IsElementDeclarationContext() {}

func NewElementDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementDeclarationContext {
	var p = new(ElementDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_elementDeclaration

	return p
}

func (s *ElementDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementDeclarationContext) ElementName() IElementNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementNameContext)
}

func (s *ElementDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterElementDeclaration(s)
	}
}

func (s *ElementDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitElementDeclaration(s)
	}
}

func (p *XPath3Parser) ElementDeclaration() (localctx IElementDeclarationContext) {
	localctx = NewElementDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, XPath3ParserRULE_elementDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(784)
		p.ElementName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeNameContext is an interface to support dynamic dispatch.
type IAttributeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EqName() IEqNameContext

	// IsAttributeNameContext differentiates from other interfaces.
	IsAttributeNameContext()
}

type AttributeNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeNameContext() *AttributeNameContext {
	var p = new(AttributeNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_attributeName
	return p
}

func InitEmptyAttributeNameContext(p *AttributeNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_attributeName
}

func (*AttributeNameContext) IsAttributeNameContext() {}

func NewAttributeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeNameContext {
	var p = new(AttributeNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_attributeName

	return p
}

func (s *AttributeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeNameContext) EqName() IEqNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqNameContext)
}

func (s *AttributeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterAttributeName(s)
	}
}

func (s *AttributeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitAttributeName(s)
	}
}

func (p *XPath3Parser) AttributeName() (localctx IAttributeNameContext) {
	localctx = NewAttributeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, XPath3ParserRULE_attributeName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(786)
		p.EqName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementNameContext is an interface to support dynamic dispatch.
type IElementNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EqName() IEqNameContext

	// IsElementNameContext differentiates from other interfaces.
	IsElementNameContext()
}

type ElementNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementNameContext() *ElementNameContext {
	var p = new(ElementNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_elementName
	return p
}

func InitEmptyElementNameContext(p *ElementNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_elementName
}

func (*ElementNameContext) IsElementNameContext() {}

func NewElementNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementNameContext {
	var p = new(ElementNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_elementName

	return p
}

func (s *ElementNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementNameContext) EqName() IEqNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqNameContext)
}

func (s *ElementNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterElementName(s)
	}
}

func (s *ElementNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitElementName(s)
	}
}

func (p *XPath3Parser) ElementName() (localctx IElementNameContext) {
	localctx = NewElementNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, XPath3ParserRULE_elementName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(788)
		p.EqName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleTypeNameContext is an interface to support dynamic dispatch.
type ISimpleTypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeName() ITypeNameContext

	// IsSimpleTypeNameContext differentiates from other interfaces.
	IsSimpleTypeNameContext()
}

type SimpleTypeNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleTypeNameContext() *SimpleTypeNameContext {
	var p = new(SimpleTypeNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_simpleTypeName
	return p
}

func InitEmptySimpleTypeNameContext(p *SimpleTypeNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_simpleTypeName
}

func (*SimpleTypeNameContext) IsSimpleTypeNameContext() {}

func NewSimpleTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleTypeNameContext {
	var p = new(SimpleTypeNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_simpleTypeName

	return p
}

func (s *SimpleTypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleTypeNameContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *SimpleTypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleTypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleTypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterSimpleTypeName(s)
	}
}

func (s *SimpleTypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitSimpleTypeName(s)
	}
}

func (p *XPath3Parser) SimpleTypeName() (localctx ISimpleTypeNameContext) {
	localctx = NewSimpleTypeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, XPath3ParserRULE_simpleTypeName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(790)
		p.TypeName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeNameContext is an interface to support dynamic dispatch.
type ITypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QNAME() antlr.TerminalNode

	// IsTypeNameContext differentiates from other interfaces.
	IsTypeNameContext()
}

type TypeNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeNameContext() *TypeNameContext {
	var p = new(TypeNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_typeName
	return p
}

func InitEmptyTypeNameContext(p *TypeNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_typeName
}

func (*TypeNameContext) IsTypeNameContext() {}

func NewTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeNameContext {
	var p = new(TypeNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_typeName

	return p
}

func (s *TypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeNameContext) QNAME() antlr.TerminalNode {
	return s.GetToken(XPath3ParserQNAME, 0)
}

func (s *TypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterTypeName(s)
	}
}

func (s *TypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitTypeName(s)
	}
}

func (p *XPath3Parser) TypeName() (localctx ITypeNameContext) {
	localctx = NewTypeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, XPath3ParserRULE_typeName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(792)
		p.Match(XPath3ParserQNAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionTestContext is an interface to support dynamic dispatch.
type IFunctionTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AnyFunctionTest() IAnyFunctionTestContext
	TypedFunctionTest() ITypedFunctionTestContext

	// IsFunctionTestContext differentiates from other interfaces.
	IsFunctionTestContext()
}

type FunctionTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionTestContext() *FunctionTestContext {
	var p = new(FunctionTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_functionTest
	return p
}

func InitEmptyFunctionTestContext(p *FunctionTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_functionTest
}

func (*FunctionTestContext) IsFunctionTestContext() {}

func NewFunctionTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionTestContext {
	var p = new(FunctionTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_functionTest

	return p
}

func (s *FunctionTestContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionTestContext) AnyFunctionTest() IAnyFunctionTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnyFunctionTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnyFunctionTestContext)
}

func (s *FunctionTestContext) TypedFunctionTest() ITypedFunctionTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedFunctionTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedFunctionTestContext)
}

func (s *FunctionTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterFunctionTest(s)
	}
}

func (s *FunctionTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitFunctionTest(s)
	}
}

func (p *XPath3Parser) FunctionTest() (localctx IFunctionTestContext) {
	localctx = NewFunctionTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, XPath3ParserRULE_functionTest)
	p.SetState(796)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 62, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(794)
			p.AnyFunctionTest()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(795)
			p.TypedFunctionTest()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnyFunctionTestContext is an interface to support dynamic dispatch.
type IAnyFunctionTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAnyFunctionTestContext differentiates from other interfaces.
	IsAnyFunctionTestContext()
}

type AnyFunctionTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnyFunctionTestContext() *AnyFunctionTestContext {
	var p = new(AnyFunctionTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_anyFunctionTest
	return p
}

func InitEmptyAnyFunctionTestContext(p *AnyFunctionTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_anyFunctionTest
}

func (*AnyFunctionTestContext) IsAnyFunctionTestContext() {}

func NewAnyFunctionTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnyFunctionTestContext {
	var p = new(AnyFunctionTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_anyFunctionTest

	return p
}

func (s *AnyFunctionTestContext) GetParser() antlr.Parser { return s.parser }
func (s *AnyFunctionTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnyFunctionTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnyFunctionTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterAnyFunctionTest(s)
	}
}

func (s *AnyFunctionTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitAnyFunctionTest(s)
	}
}

func (p *XPath3Parser) AnyFunctionTest() (localctx IAnyFunctionTestContext) {
	localctx = NewAnyFunctionTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, XPath3ParserRULE_anyFunctionTest)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(798)
		p.Match(XPath3ParserT__77)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(799)
		p.Match(XPath3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(800)
		p.Match(XPath3ParserT__23)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(801)
		p.Match(XPath3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypedFunctionTestContext is an interface to support dynamic dispatch.
type ITypedFunctionTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSequenceType() []ISequenceTypeContext
	SequenceType(i int) ISequenceTypeContext

	// IsTypedFunctionTestContext differentiates from other interfaces.
	IsTypedFunctionTestContext()
}

type TypedFunctionTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypedFunctionTestContext() *TypedFunctionTestContext {
	var p = new(TypedFunctionTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_typedFunctionTest
	return p
}

func InitEmptyTypedFunctionTestContext(p *TypedFunctionTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_typedFunctionTest
}

func (*TypedFunctionTestContext) IsTypedFunctionTestContext() {}

func NewTypedFunctionTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypedFunctionTestContext {
	var p = new(TypedFunctionTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_typedFunctionTest

	return p
}

func (s *TypedFunctionTestContext) GetParser() antlr.Parser { return s.parser }

func (s *TypedFunctionTestContext) AllSequenceType() []ISequenceTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISequenceTypeContext); ok {
			len++
		}
	}

	tst := make([]ISequenceTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISequenceTypeContext); ok {
			tst[i] = t.(ISequenceTypeContext)
			i++
		}
	}

	return tst
}

func (s *TypedFunctionTestContext) SequenceType(i int) ISequenceTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISequenceTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISequenceTypeContext)
}

func (s *TypedFunctionTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypedFunctionTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypedFunctionTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterTypedFunctionTest(s)
	}
}

func (s *TypedFunctionTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitTypedFunctionTest(s)
	}
}

func (p *XPath3Parser) TypedFunctionTest() (localctx ITypedFunctionTestContext) {
	localctx = NewTypedFunctionTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, XPath3ParserRULE_typedFunctionTest)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(803)
		p.Match(XPath3ParserT__77)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(804)
		p.Match(XPath3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(813)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == XPath3ParserT__13 || _la == XPath3ParserT__58 || ((int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&17829887) != 0) {
		{
			p.SetState(805)
			p.SequenceType()
		}
		p.SetState(810)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == XPath3ParserT__0 {
			{
				p.SetState(806)
				p.Match(XPath3ParserT__0)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(807)
				p.SequenceType()
			}

			p.SetState(812)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(815)
		p.Match(XPath3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(816)
		p.Match(XPath3ParserT__34)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(817)
		p.SequenceType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParenthesizedItemTypeContext is an interface to support dynamic dispatch.
type IParenthesizedItemTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ItemType() IItemTypeContext

	// IsParenthesizedItemTypeContext differentiates from other interfaces.
	IsParenthesizedItemTypeContext()
}

type ParenthesizedItemTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParenthesizedItemTypeContext() *ParenthesizedItemTypeContext {
	var p = new(ParenthesizedItemTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_parenthesizedItemType
	return p
}

func InitEmptyParenthesizedItemTypeContext(p *ParenthesizedItemTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_parenthesizedItemType
}

func (*ParenthesizedItemTypeContext) IsParenthesizedItemTypeContext() {}

func NewParenthesizedItemTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParenthesizedItemTypeContext {
	var p = new(ParenthesizedItemTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_parenthesizedItemType

	return p
}

func (s *ParenthesizedItemTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ParenthesizedItemTypeContext) ItemType() IItemTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IItemTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IItemTypeContext)
}

func (s *ParenthesizedItemTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedItemTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParenthesizedItemTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterParenthesizedItemType(s)
	}
}

func (s *ParenthesizedItemTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitParenthesizedItemType(s)
	}
}

func (p *XPath3Parser) ParenthesizedItemType() (localctx IParenthesizedItemTypeContext) {
	localctx = NewParenthesizedItemTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, XPath3ParserRULE_parenthesizedItemType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(819)
		p.Match(XPath3ParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(820)
		p.ItemType()
	}
	{
		p.SetState(821)
		p.Match(XPath3ParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEqNameContext is an interface to support dynamic dispatch.
type IEqNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QNAME() antlr.TerminalNode
	URIQualifiedName() antlr.TerminalNode

	// IsEqNameContext differentiates from other interfaces.
	IsEqNameContext()
}

type EqNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEqNameContext() *EqNameContext {
	var p = new(EqNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_eqName
	return p
}

func InitEmptyEqNameContext(p *EqNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_eqName
}

func (*EqNameContext) IsEqNameContext() {}

func NewEqNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EqNameContext {
	var p = new(EqNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_eqName

	return p
}

func (s *EqNameContext) GetParser() antlr.Parser { return s.parser }

func (s *EqNameContext) QNAME() antlr.TerminalNode {
	return s.GetToken(XPath3ParserQNAME, 0)
}

func (s *EqNameContext) URIQualifiedName() antlr.TerminalNode {
	return s.GetToken(XPath3ParserURIQualifiedName, 0)
}

func (s *EqNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EqNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterEqName(s)
	}
}

func (s *EqNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitEqName(s)
	}
}

func (p *XPath3Parser) EqName() (localctx IEqNameContext) {
	localctx = NewEqNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, XPath3ParserRULE_eqName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(823)
		_la = p.GetTokenStream().LA(1)

		if !(_la == XPath3ParserURIQualifiedName || _la == XPath3ParserQNAME) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringLiteralContext is an interface to support dynamic dispatch.
type IStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllESCAPE_QUOTE() []antlr.TerminalNode
	ESCAPE_QUOTE(i int) antlr.TerminalNode
	AllESCAPE_APOS() []antlr.TerminalNode
	ESCAPE_APOS(i int) antlr.TerminalNode

	// IsStringLiteralContext differentiates from other interfaces.
	IsStringLiteralContext()
}

type StringLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringLiteralContext() *StringLiteralContext {
	var p = new(StringLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_stringLiteral
	return p
}

func InitEmptyStringLiteralContext(p *StringLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = XPath3ParserRULE_stringLiteral
}

func (*StringLiteralContext) IsStringLiteralContext() {}

func NewStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringLiteralContext {
	var p = new(StringLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath3ParserRULE_stringLiteral

	return p
}

func (s *StringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *StringLiteralContext) AllESCAPE_QUOTE() []antlr.TerminalNode {
	return s.GetTokens(XPath3ParserESCAPE_QUOTE)
}

func (s *StringLiteralContext) ESCAPE_QUOTE(i int) antlr.TerminalNode {
	return s.GetToken(XPath3ParserESCAPE_QUOTE, i)
}

func (s *StringLiteralContext) AllESCAPE_APOS() []antlr.TerminalNode {
	return s.GetTokens(XPath3ParserESCAPE_APOS)
}

func (s *StringLiteralContext) ESCAPE_APOS(i int) antlr.TerminalNode {
	return s.GetToken(XPath3ParserESCAPE_APOS, i)
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath3Listener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

func (p *XPath3Parser) StringLiteral() (localctx IStringLiteralContext) {
	localctx = NewStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, XPath3ParserRULE_stringLiteral)
	var _alt int

	p.SetState(843)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case XPath3ParserT__89:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(825)
			p.Match(XPath3ParserT__89)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(830)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 66, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1+1 {
				p.SetState(828)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 65, p.GetParserRuleContext()) {
				case 1:
					{
						p.SetState(826)
						p.Match(XPath3ParserESCAPE_QUOTE)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case 2:
					p.SetState(827)
					p.MatchWildcard()

				case antlr.ATNInvalidAltNumber:
					goto errorExit
				}

			}
			p.SetState(832)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 66, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		{
			p.SetState(833)
			p.Match(XPath3ParserT__89)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case XPath3ParserT__90:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(834)
			p.Match(XPath3ParserT__90)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(839)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 68, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1+1 {
				p.SetState(837)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 67, p.GetParserRuleContext()) {
				case 1:
					{
						p.SetState(835)
						p.Match(XPath3ParserESCAPE_APOS)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case 2:
					p.SetState(836)
					p.MatchWildcard()

				case antlr.ATNInvalidAltNumber:
					goto errorExit
				}

			}
			p.SetState(841)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 68, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		{
			p.SetState(842)
			p.Match(XPath3ParserT__90)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *XPath3Parser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 5:
		var t *ExprContext = nil
		if localctx != nil {
			t = localctx.(*ExprContext)
		}
		return p.Expr_Sempred(t, predIndex)

	case 9:
		var t *ForBindingListContext = nil
		if localctx != nil {
			t = localctx.(*ForBindingListContext)
		}
		return p.ForBindingList_Sempred(t, predIndex)

	case 13:
		var t *LetBindingListContext = nil
		if localctx != nil {
			t = localctx.(*LetBindingListContext)
		}
		return p.LetBindingList_Sempred(t, predIndex)

	case 16:
		var t *QuantifiedBindingListContext = nil
		if localctx != nil {
			t = localctx.(*QuantifiedBindingListContext)
		}
		return p.QuantifiedBindingList_Sempred(t, predIndex)

	case 19:
		var t *OrExprContext = nil
		if localctx != nil {
			t = localctx.(*OrExprContext)
		}
		return p.OrExpr_Sempred(t, predIndex)

	case 20:
		var t *AndExprContext = nil
		if localctx != nil {
			t = localctx.(*AndExprContext)
		}
		return p.AndExpr_Sempred(t, predIndex)

	case 22:
		var t *StringConcatExprContext = nil
		if localctx != nil {
			t = localctx.(*StringConcatExprContext)
		}
		return p.StringConcatExpr_Sempred(t, predIndex)

	case 23:
		var t *RangeExprContext = nil
		if localctx != nil {
			t = localctx.(*RangeExprContext)
		}
		return p.RangeExpr_Sempred(t, predIndex)

	case 24:
		var t *AdditiveExprContext = nil
		if localctx != nil {
			t = localctx.(*AdditiveExprContext)
		}
		return p.AdditiveExpr_Sempred(t, predIndex)

	case 25:
		var t *MultiplicativeExprContext = nil
		if localctx != nil {
			t = localctx.(*MultiplicativeExprContext)
		}
		return p.MultiplicativeExpr_Sempred(t, predIndex)

	case 26:
		var t *UnionExprContext = nil
		if localctx != nil {
			t = localctx.(*UnionExprContext)
		}
		return p.UnionExpr_Sempred(t, predIndex)

	case 27:
		var t *IntersectExceptExprContext = nil
		if localctx != nil {
			t = localctx.(*IntersectExceptExprContext)
		}
		return p.IntersectExceptExpr_Sempred(t, predIndex)

	case 37:
		var t *SimpleMapExprContext = nil
		if localctx != nil {
			t = localctx.(*SimpleMapExprContext)
		}
		return p.SimpleMapExpr_Sempred(t, predIndex)

	case 39:
		var t *RelativePathExprContext = nil
		if localctx != nil {
			t = localctx.(*RelativePathExprContext)
		}
		return p.RelativePathExpr_Sempred(t, predIndex)

	case 51:
		var t *PostfixExprContext = nil
		if localctx != nil {
			t = localctx.(*PostfixExprContext)
		}
		return p.PostfixExpr_Sempred(t, predIndex)

	case 53:
		var t *ArgumentsContext = nil
		if localctx != nil {
			t = localctx.(*ArgumentsContext)
		}
		return p.Arguments_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *XPath3Parser) Expr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *XPath3Parser) ForBindingList_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 1:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *XPath3Parser) LetBindingList_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *XPath3Parser) QuantifiedBindingList_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 3:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *XPath3Parser) OrExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 4:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *XPath3Parser) AndExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 5:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *XPath3Parser) StringConcatExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 6:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *XPath3Parser) RangeExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 7:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *XPath3Parser) AdditiveExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 8:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *XPath3Parser) MultiplicativeExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 9:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *XPath3Parser) UnionExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 10:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *XPath3Parser) IntersectExceptExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 11:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *XPath3Parser) SimpleMapExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 12:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *XPath3Parser) RelativePathExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 13:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *XPath3Parser) PostfixExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 14:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 15:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *XPath3Parser) Arguments_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 16:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
